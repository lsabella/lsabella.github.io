<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>全栈工程师修炼指南</title>
    <url>/2021/04/08/fullstack/guide/</url>
    <content><![CDATA[<h3 id="网络协议和Web接口"><a href="#网络协议和Web接口" class="headerlink" title="网络协议和Web接口"></a>网络协议和Web接口</h3><h4 id="网络互联的昨天、今天和明天：Http协议的演化"><a href="#网络互联的昨天、今天和明天：Http协议的演化" class="headerlink" title="网络互联的昨天、今天和明天：Http协议的演化"></a>网络互联的昨天、今天和明天：Http协议的演化</h4><h5 id="演进：Http-0-9、Http-1-0、Http-1-1、Http-2"><a href="#演进：Http-0-9、Http-1-0、Http-1-1、Http-2" class="headerlink" title="演进：Http/0.9、Http/1.0、Http/1.1、Http/2"></a>演进：Http/0.9、Http/1.0、Http/1.1、Http/2</h5><h5 id="长连接和分块传输"><a href="#长连接和分块传输" class="headerlink" title="长连接和分块传输"></a>长连接和分块传输</h5><h5 id="动手实践：工具的使用-请求发送和抓包"><a href="#动手实践：工具的使用-请求发送和抓包" class="headerlink" title="动手实践：工具的使用 - 请求发送和抓包"></a>动手实践：工具的使用 - 请求发送和抓包</h5><h4 id="为Http穿上盔甲：Https"><a href="#为Http穿上盔甲：Https" class="headerlink" title="为Http穿上盔甲：Https"></a>为Http穿上盔甲：Https</h4><h5 id="对称-非对称性加密，SSL-TLS-和Https"><a href="#对称-非对称性加密，SSL-TLS-和Https" class="headerlink" title="对称/非对称性加密，SSL/TLS 和Https"></a>对称/非对称性加密，SSL/TLS 和Https</h5><h5 id="动手实践：捕获TLS报文"><a href="#动手实践：捕获TLS报文" class="headerlink" title="动手实践：捕获TLS报文"></a>动手实践：捕获TLS报文</h5><h5 id="TLS连接建立过程"><a href="#TLS连接建立过程" class="headerlink" title="TLS连接建立过程"></a>TLS连接建立过程</h5><h5 id="证书有效校验"><a href="#证书有效校验" class="headerlink" title="证书有效校验"></a>证书有效校验</h5><h4 id="换个角度解决问题：服务端推送技术"><a href="#换个角度解决问题：服务端推送技术" class="headerlink" title="换个角度解决问题：服务端推送技术"></a>换个角度解决问题：服务端推送技术</h4><h5 id="比较-Pull和Push"><a href="#比较-Pull和Push" class="headerlink" title="比较:Pull和Push"></a>比较:Pull和Push</h5><h5 id="服务端推送技术：Comet"><a href="#服务端推送技术：Comet" class="headerlink" title="服务端推送技术：Comet"></a>服务端推送技术：Comet</h5><h5 id="服务端推送技术：WebSocket"><a href="#服务端推送技术：WebSocket" class="headerlink" title="服务端推送技术：WebSocket"></a>服务端推送技术：WebSocket</h5><h5 id="动手实践：Chrome下观察连接和推送消息"><a href="#动手实践：Chrome下观察连接和推送消息" class="headerlink" title="动手实践：Chrome下观察连接和推送消息"></a>动手实践：Chrome下观察连接和推送消息</h5><h4 id="工整与自由的风格之争：SOAP和REST"><a href="#工整与自由的风格之争：SOAP和REST" class="headerlink" title="工整与自由的风格之争：SOAP和REST"></a>工整与自由的风格之争：SOAP和REST</h4><h5 id="比较：SOAP和REST"><a href="#比较：SOAP和REST" class="headerlink" title="比较：SOAP和REST"></a>比较：SOAP和REST</h5><h5 id="风格之争"><a href="#风格之争" class="headerlink" title="风格之争"></a>风格之争</h5><h5 id="动手实践：调用Restfull-API"><a href="#动手实践：调用Restfull-API" class="headerlink" title="动手实践：调用Restfull API"></a>动手实践：调用Restfull API</h5><h4 id="权衡的艺术：漫谈Web-API的设计"><a href="#权衡的艺术：漫谈Web-API的设计" class="headerlink" title="权衡的艺术：漫谈Web API的设计"></a>权衡的艺术：漫谈Web API的设计</h4><h5 id="明确核心问题，确定问题域"><a href="#明确核心问题，确定问题域" class="headerlink" title="明确核心问题，确定问题域"></a>明确核心问题，确定问题域</h5><h5 id="结合实际需求和限制，选择承载技术"><a href="#结合实际需求和限制，选择承载技术" class="headerlink" title="结合实际需求和限制，选择承载技术"></a>结合实际需求和限制，选择承载技术</h5><h5 id="确定接口风格"><a href="#确定接口风格" class="headerlink" title="确定接口风格"></a>确定接口风格</h5><h5 id="定义具体接口形式"><a href="#定义具体接口形式" class="headerlink" title="定义具体接口形式"></a>定义具体接口形式</h5><h3 id="服务端MVC"><a href="#服务端MVC" class="headerlink" title="服务端MVC"></a>服务端MVC</h3><h4 id="解耦是永恒的主题：MVC框架的发展"><a href="#解耦是永恒的主题：MVC框架的发展" class="headerlink" title="解耦是永恒的主题：MVC框架的发展"></a>解耦是永恒的主题：MVC框架的发展</h4><h5 id="JSP和Servlet"><a href="#JSP和Servlet" class="headerlink" title="JSP和Servlet"></a>JSP和Servlet</h5><h5 id="演进：JSP-Model1-Model2"><a href="#演进：JSP-Model1-Model2" class="headerlink" title="演进：JSP Model1/Model2"></a>演进：JSP Model1/Model2</h5><h5 id="比较：MVC的一般化，MVC的变体"><a href="#比较：MVC的一般化，MVC的变体" class="headerlink" title="比较：MVC的一般化，MVC的变体"></a>比较：MVC的一般化，MVC的变体</h5><h4 id="MVC架构解析：模型（Model）"><a href="#MVC架构解析：模型（Model）" class="headerlink" title="MVC架构解析：模型（Model）"></a>MVC架构解析：模型（Model）</h4><h5 id="比较：贫血模型和充血模型"><a href="#比较：贫血模型和充血模型" class="headerlink" title="比较：贫血模型和充血模型"></a>比较：贫血模型和充血模型</h5><h5 id="内部层次划分"><a href="#内部层次划分" class="headerlink" title="内部层次划分"></a>内部层次划分</h5><h5 id="CQRS模式"><a href="#CQRS模式" class="headerlink" title="CQRS模式"></a>CQRS模式</h5><h4 id="MVC架构解析：视图（View）"><a href="#MVC架构解析：视图（View）" class="headerlink" title="MVC架构解析：视图（View）"></a>MVC架构解析：视图（View）</h4><h5 id="比较：服务端和客户端页面聚合技术"><a href="#比较：服务端和客户端页面聚合技术" class="headerlink" title="比较：服务端和客户端页面聚合技术"></a>比较：服务端和客户端页面聚合技术</h5><h5 id="模版引擎的工作机制"><a href="#模版引擎的工作机制" class="headerlink" title="模版引擎的工作机制"></a>模版引擎的工作机制</h5><h5 id="动手实践：HTML5的模版标签"><a href="#动手实践：HTML5的模版标签" class="headerlink" title="动手实践：HTML5的模版标签"></a>动手实践：HTML5的模版标签</h5><h4 id="MVC架构解析：控制层（Controller）"><a href="#MVC架构解析：控制层（Controller）" class="headerlink" title="MVC架构解析：控制层（Controller）"></a>MVC架构解析：控制层（Controller）</h4><h5 id="路径映射和视图指向"><a href="#路径映射和视图指向" class="headerlink" title="路径映射和视图指向"></a>路径映射和视图指向</h5><h5 id="请求参数绑定"><a href="#请求参数绑定" class="headerlink" title="请求参数绑定"></a>请求参数绑定</h5><h5 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h5><h5 id="视图上下文绑定"><a href="#视图上下文绑定" class="headerlink" title="视图上下文绑定"></a>视图上下文绑定</h5><h5 id="动手实践：实现一个简单的MVC系统"><a href="#动手实践：实现一个简单的MVC系统" class="headerlink" title="动手实践：实现一个简单的MVC系统"></a>动手实践：实现一个简单的MVC系统</h5><h4 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h4><h5 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h5><h5 id="Spring中的应用"><a href="#Spring中的应用" class="headerlink" title="Spring中的应用"></a>Spring中的应用</h5><h5 id="比较：静态织入和动态代理"><a href="#比较：静态织入和动态代理" class="headerlink" title="比较：静态织入和动态代理"></a>比较：静态织入和动态代理</h5><h5 id="控制反转loC"><a href="#控制反转loC" class="headerlink" title="控制反转loC"></a>控制反转loC</h5><h5 id="动手实践：AOP的运行时动态代理"><a href="#动手实践：AOP的运行时动态代理" class="headerlink" title="动手实践：AOP的运行时动态代理"></a>动手实践：AOP的运行时动态代理</h5><h4 id="JaveEE的模式"><a href="#JaveEE的模式" class="headerlink" title="JaveEE的模式"></a>JaveEE的模式</h4><h5 id="核心模式概览"><a href="#核心模式概览" class="headerlink" title="核心模式概览"></a>核心模式概览</h5><h5 id="拦截过滤器模式"><a href="#拦截过滤器模式" class="headerlink" title="拦截过滤器模式"></a>拦截过滤器模式</h5><h5 id="数据访问对象"><a href="#数据访问对象" class="headerlink" title="数据访问对象"></a>数据访问对象</h5><h5 id="比较：MyBatis和Hibernate"><a href="#比较：MyBatis和Hibernate" class="headerlink" title="比较：MyBatis和Hibernate"></a>比较：MyBatis和Hibernate</h5><h3 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h3><h4 id="从后端到前端"><a href="#从后端到前端" class="headerlink" title="从后端到前端"></a>从后端到前端</h4><h5 id="前端技术的现状和意义"><a href="#前端技术的现状和意义" class="headerlink" title="前端技术的现状和意义"></a>前端技术的现状和意义</h5><h5 id="思维模式转变：应用事件驱动编程"><a href="#思维模式转变：应用事件驱动编程" class="headerlink" title="思维模式转变：应用事件驱动编程"></a>思维模式转变：应用事件驱动编程</h5><h5 id="思维模式转变：学写声明式代码"><a href="#思维模式转变：学写声明式代码" class="headerlink" title="思维模式转变：学写声明式代码"></a>思维模式转变：学写声明式代码</h5><h5 id="思维模式转变：培养交互思维"><a href="#思维模式转变：培养交互思维" class="headerlink" title="思维模式转变：培养交互思维"></a>思维模式转变：培养交互思维</h5><h4 id="JavaScript面向对象"><a href="#JavaScript面向对象" class="headerlink" title="JavaScript面向对象"></a>JavaScript面向对象</h4><h5 id="JavaScript实现封装"><a href="#JavaScript实现封装" class="headerlink" title="JavaScript实现封装"></a>JavaScript实现封装</h5><h5 id="JavaScript实现继承"><a href="#JavaScript实现继承" class="headerlink" title="JavaScript实现继承"></a>JavaScript实现继承</h5><h5 id="理解对象创建"><a href="#理解对象创建" class="headerlink" title="理解对象创建"></a>理解对象创建</h5><h5 id="函数成为一等公民"><a href="#函数成为一等公民" class="headerlink" title="函数成为一等公民"></a>函数成为一等公民</h5><h4 id="前端MVC框架"><a href="#前端MVC框架" class="headerlink" title="前端MVC框架"></a>前端MVC框架</h4><h5 id="演进：前端MVC的变革"><a href="#演进：前端MVC的变革" class="headerlink" title="演进：前端MVC的变革"></a>演进：前端MVC的变革</h5><h5 id="Angular：双向绑定、依赖注入、过滤器"><a href="#Angular：双向绑定、依赖注入、过滤器" class="headerlink" title="Angular：双向绑定、依赖注入、过滤器"></a>Angular：双向绑定、依赖注入、过滤器</h5><h5 id="React-Redux：JSX，Redux的状态管理"><a href="#React-Redux：JSX，Redux的状态管理" class="headerlink" title="React + Redux：JSX，Redux的状态管理"></a>React + Redux：JSX，Redux的状态管理</h5><h4 id="交互设计和页面布局"><a href="#交互设计和页面布局" class="headerlink" title="交互设计和页面布局"></a>交互设计和页面布局</h4><h5 id="单页面应用"><a href="#单页面应用" class="headerlink" title="单页面应用"></a>单页面应用</h5><h5 id="渐进增强和优雅降级"><a href="#渐进增强和优雅降级" class="headerlink" title="渐进增强和优雅降级"></a>渐进增强和优雅降级</h5><h5 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h5><h4 id="谈谈数据可视化"><a href="#谈谈数据可视化" class="headerlink" title="谈谈数据可视化"></a>谈谈数据可视化</h4><h5 id="比较：Web绘图标准，SVG和Canvas"><a href="#比较：Web绘图标准，SVG和Canvas" class="headerlink" title="比较：Web绘图标准，SVG和Canvas"></a>比较：Web绘图标准，SVG和Canvas</h5><h5 id="数据可视化的Javascript库：Flot"><a href="#数据可视化的Javascript库：Flot" class="headerlink" title="数据可视化的Javascript库：Flot"></a>数据可视化的Javascript库：Flot</h5><h5 id="数据可视化的Javascript库：D3-js"><a href="#数据可视化的Javascript库：D3-js" class="headerlink" title="数据可视化的Javascript库：D3.js"></a>数据可视化的Javascript库：D3.js</h5><h4 id="Javascript异步编程"><a href="#Javascript异步编程" class="headerlink" title="Javascript异步编程"></a>Javascript异步编程</h4><h5 id="演进：用Promise来优化嵌套回调"><a href="#演进：用Promise来优化嵌套回调" class="headerlink" title="演进：用Promise来优化嵌套回调"></a>演进：用Promise来优化嵌套回调</h5><h5 id="用生成器来实现协程"><a href="#用生成器来实现协程" class="headerlink" title="用生成器来实现协程"></a>用生成器来实现协程</h5><h5 id="异步错误处理"><a href="#异步错误处理" class="headerlink" title="异步错误处理"></a>异步错误处理</h5><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="缓存的本质"><a href="#缓存的本质" class="headerlink" title="缓存的本质"></a>缓存的本质</h5><h5 id="缓存的应用"><a href="#缓存的应用" class="headerlink" title="缓存的应用"></a>缓存的应用</h5><h5 id="比较：常见的缓存模式"><a href="#比较：常见的缓存模式" class="headerlink" title="比较：常见的缓存模式"></a>比较：常见的缓存模式</h5><h5 id="常见缓存使用问题"><a href="#常见缓存使用问题" class="headerlink" title="常见缓存使用问题"></a>常见缓存使用问题</h5><h5 id="缓存框架的设计要点"><a href="#缓存框架的设计要点" class="headerlink" title="缓存框架的设计要点"></a>缓存框架的设计要点</h5><h4 id="数据的持久化和一致性"><a href="#数据的持久化和一致性" class="headerlink" title="数据的持久化和一致性"></a>数据的持久化和一致性</h4><h5 id="理解数据一致性"><a href="#理解数据一致性" class="headerlink" title="理解数据一致性"></a>理解数据一致性</h5><h5 id="高可用架构技术：简单备份"><a href="#高可用架构技术：简单备份" class="headerlink" title="高可用架构技术：简单备份"></a>高可用架构技术：简单备份</h5><h5 id="高可用架构技术：Multi-Master"><a href="#高可用架构技术：Multi-Master" class="headerlink" title="高可用架构技术：Multi-Master"></a>高可用架构技术：Multi-Master</h5><h5 id="高可用架构技术：Multi-Slave"><a href="#高可用架构技术：Multi-Slave" class="headerlink" title="高可用架构技术：Multi-Slave"></a>高可用架构技术：Multi-Slave</h5><h5 id="一致性Hash"><a href="#一致性Hash" class="headerlink" title="一致性Hash"></a>一致性Hash</h5><h4 id="CAP和数据存储技术选择"><a href="#CAP和数据存储技术选择" class="headerlink" title="CAP和数据存储技术选择"></a>CAP和数据存储技术选择</h4><h5 id="从本质理解CAP"><a href="#从本质理解CAP" class="headerlink" title="从本质理解CAP"></a>从本质理解CAP</h5><h5 id="“三选二”的误区"><a href="#“三选二”的误区" class="headerlink" title="“三选二”的误区"></a>“三选二”的误区</h5><h5 id="NoSQL三角形"><a href="#NoSQL三角形" class="headerlink" title="NoSQL三角形"></a>NoSQL三角形</h5><h5 id="比较：ACID和BASE"><a href="#比较：ACID和BASE" class="headerlink" title="比较：ACID和BASE"></a>比较：ACID和BASE</h5><h4 id="设计数据持久层：理论分析"><a href="#设计数据持久层：理论分析" class="headerlink" title="设计数据持久层：理论分析"></a>设计数据持久层：理论分析</h4><h5 id="关系数据库的范式"><a href="#关系数据库的范式" class="headerlink" title="关系数据库的范式"></a>关系数据库的范式</h5><h5 id="NoSQL数据库的分类"><a href="#NoSQL数据库的分类" class="headerlink" title="NoSQL数据库的分类"></a>NoSQL数据库的分类</h5><h5 id="演进：Scale-Up-到-Scale-Out"><a href="#演进：Scale-Up-到-Scale-Out" class="headerlink" title="演进：Scale Up 到 Scale Out"></a>演进：Scale Up 到 Scale Out</h5><h5 id="演进：结构化到非结构化"><a href="#演进：结构化到非结构化" class="headerlink" title="演进：结构化到非结构化"></a>演进：结构化到非结构化</h5><h4 id="设计数据持久层：案例介绍"><a href="#设计数据持久层：案例介绍" class="headerlink" title="设计数据持久层：案例介绍"></a>设计数据持久层：案例介绍</h4><h5 id="搜索引擎的持久层设计"><a href="#搜索引擎的持久层设计" class="headerlink" title="搜索引擎的持久层设计"></a>搜索引擎的持久层设计</h5><h5 id="地理信息系统的持久层设计"><a href="#地理信息系统的持久层设计" class="headerlink" title="地理信息系统的持久层设计"></a>地理信息系统的持久层设计</h5><h5 id="电商网站的持久层技术选型"><a href="#电商网站的持久层技术选型" class="headerlink" title="电商网站的持久层技术选型"></a>电商网站的持久层技术选型</h5><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><h4 id="Ops三部曲：配置管理"><a href="#Ops三部曲：配置管理" class="headerlink" title="Ops三部曲：配置管理"></a>Ops三部曲：配置管理</h4><h5 id="比较：常见配置方式"><a href="#比较：常见配置方式" class="headerlink" title="比较：常见配置方式"></a>比较：常见配置方式</h5><h5 id="配置层级关系"><a href="#配置层级关系" class="headerlink" title="配置层级关系"></a>配置层级关系</h5><h5 id="规约优于配置"><a href="#规约优于配置" class="headerlink" title="规约优于配置"></a>规约优于配置</h5><h5 id="动手实践：配置模版"><a href="#动手实践：配置模版" class="headerlink" title="动手实践：配置模版"></a>动手实践：配置模版</h5><h5 id="程序员的独立性"><a href="#程序员的独立性" class="headerlink" title="程序员的独立性"></a>程序员的独立性</h5><h4 id="Ops三部曲：集群部署"><a href="#Ops三部曲：集群部署" class="headerlink" title="Ops三部曲：集群部署"></a>Ops三部曲：集群部署</h4><h5 id="负载分担"><a href="#负载分担" class="headerlink" title="负载分担"></a>负载分担</h5><h5 id="负载分担的策略算法"><a href="#负载分担的策略算法" class="headerlink" title="负载分担的策略算法"></a>负载分担的策略算法</h5><h5 id="比较：服务端Session和客户端Cookie"><a href="#比较：服务端Session和客户端Cookie" class="headerlink" title="比较：服务端Session和客户端Cookie"></a>比较：服务端Session和客户端Cookie</h5><h5 id="比较：集群部署的不同方式"><a href="#比较：集群部署的不同方式" class="headerlink" title="比较：集群部署的不同方式"></a>比较：集群部署的不同方式</h5><h5 id="动手实践：理解Cookie和Session的原理"><a href="#动手实践：理解Cookie和Session的原理" class="headerlink" title="动手实践：理解Cookie和Session的原理"></a>动手实践：理解Cookie和Session的原理</h5><h4 id="Ops三部曲：测试和发布"><a href="#Ops三部曲：测试和发布" class="headerlink" title="Ops三部曲：测试和发布"></a>Ops三部曲：测试和发布</h4><h5 id="CI-CD和Pipeline"><a href="#CI-CD和Pipeline" class="headerlink" title="CI/CD和Pipeline"></a>CI/CD和Pipeline</h5><h5 id="比较：不同测试的集成"><a href="#比较：不同测试的集成" class="headerlink" title="比较：不同测试的集成"></a>比较：不同测试的集成</h5><h5 id="CI-CD的更多挑战：代码静态分析"><a href="#CI-CD的更多挑战：代码静态分析" class="headerlink" title="CI/CD的更多挑战：代码静态分析"></a>CI/CD的更多挑战：代码静态分析</h5><h5 id="CI-CD的更多挑战：依赖管理"><a href="#CI-CD的更多挑战：依赖管理" class="headerlink" title="CI/CD的更多挑战：依赖管理"></a>CI/CD的更多挑战：依赖管理</h5><h5 id="CI-CD的更多挑战：环境监控"><a href="#CI-CD的更多挑战：环境监控" class="headerlink" title="CI/CD的更多挑战：环境监控"></a>CI/CD的更多挑战：环境监控</h5><h4 id="网站安全问题窥视"><a href="#网站安全问题窥视" class="headerlink" title="网站安全问题窥视"></a>网站安全问题窥视</h4><h5 id="鉴权和授权"><a href="#鉴权和授权" class="headerlink" title="鉴权和授权"></a>鉴权和授权</h5><h5 id="常见的Web攻击方式：XSS"><a href="#常见的Web攻击方式：XSS" class="headerlink" title="常见的Web攻击方式：XSS"></a>常见的Web攻击方式：XSS</h5><h5 id="常见的Web攻击方式：XSRF"><a href="#常见的Web攻击方式：XSRF" class="headerlink" title="常见的Web攻击方式：XSRF"></a>常见的Web攻击方式：XSRF</h5><h5 id="常见的Web攻击方式：SQL注入"><a href="#常见的Web攻击方式：SQL注入" class="headerlink" title="常见的Web攻击方式：SQL注入"></a>常见的Web攻击方式：SQL注入</h5><h5 id="常见的Web攻击方式：HTTP劫持"><a href="#常见的Web攻击方式：HTTP劫持" class="headerlink" title="常见的Web攻击方式：HTTP劫持"></a>常见的Web攻击方式：HTTP劫持</h5><h5 id="常见的Web攻击方式：DNS劫持"><a href="#常见的Web攻击方式：DNS劫持" class="headerlink" title="常见的Web攻击方式：DNS劫持"></a>常见的Web攻击方式：DNS劫持</h5><h5 id="常见的Web攻击方式：DDos攻击"><a href="#常见的Web攻击方式：DDos攻击" class="headerlink" title="常见的Web攻击方式：DDos攻击"></a>常见的Web攻击方式：DDos攻击</h5><h4 id="SEO的原理和基础"><a href="#SEO的原理和基础" class="headerlink" title="SEO的原理和基础"></a>SEO的原理和基础</h4><h5 id="搜索引擎的组成"><a href="#搜索引擎的组成" class="headerlink" title="搜索引擎的组成"></a>搜索引擎的组成</h5><h5 id="PageRank算法"><a href="#PageRank算法" class="headerlink" title="PageRank算法"></a>PageRank算法</h5><h5 id="SEO常见技术：白帽和黑帽"><a href="#SEO常见技术：白帽和黑帽" class="headerlink" title="SEO常见技术：白帽和黑帽"></a>SEO常见技术：白帽和黑帽</h5><h5 id="SEO常见技术：站内优化和站外优化"><a href="#SEO常见技术：站内优化和站外优化" class="headerlink" title="SEO常见技术：站内优化和站外优化"></a>SEO常见技术：站内优化和站外优化</h5><h5 id="SEO常见技术：roberts-txt"><a href="#SEO常见技术：roberts-txt" class="headerlink" title="SEO常见技术：roberts.txt"></a>SEO常见技术：roberts.txt</h5><h5 id="SEO常见技术：网站地图"><a href="#SEO常见技术：网站地图" class="headerlink" title="SEO常见技术：网站地图"></a>SEO常见技术：网站地图</h5><h5 id="SEO常见技术：统计分析"><a href="#SEO常见技术：统计分析" class="headerlink" title="SEO常见技术：统计分析"></a>SEO常见技术：统计分析</h5><h3 id="专题和其它"><a href="#专题和其它" class="headerlink" title="专题和其它"></a>专题和其它</h3><h4 id="网站性能优化"><a href="#网站性能优化" class="headerlink" title="网站性能优化"></a>网站性能优化</h4><h5 id="性能优化和软件设计的关系"><a href="#性能优化和软件设计的关系" class="headerlink" title="性能优化和软件设计的关系"></a>性能优化和软件设计的关系</h5><h5 id="性能指标与关注点：资源角度"><a href="#性能指标与关注点：资源角度" class="headerlink" title="性能指标与关注点：资源角度"></a>性能指标与关注点：资源角度</h5><h5 id="寻找性能瓶颈：思路"><a href="#寻找性能瓶颈：思路" class="headerlink" title="寻找性能瓶颈：思路"></a>寻找性能瓶颈：思路</h5><h5 id="寻找性能瓶颈：工具"><a href="#寻找性能瓶颈：工具" class="headerlink" title="寻找性能瓶颈：工具"></a>寻找性能瓶颈：工具</h5><h5 id="性能优化之产品和架构调整"><a href="#性能优化之产品和架构调整" class="headerlink" title="性能优化之产品和架构调整"></a>性能优化之产品和架构调整</h5><h5 id="性能优化之后端和持久层优化"><a href="#性能优化之后端和持久层优化" class="headerlink" title="性能优化之后端和持久层优化"></a>性能优化之后端和持久层优化</h5><h5 id="性能优化之前端和网络层优化"><a href="#性能优化之前端和网络层优化" class="headerlink" title="性能优化之前端和网络层优化"></a>性能优化之前端和网络层优化</h5><h4 id="全栈开发中的算法"><a href="#全栈开发中的算法" class="headerlink" title="全栈开发中的算法"></a>全栈开发中的算法</h4><h5 id="流量控制算法"><a href="#流量控制算法" class="headerlink" title="流量控制算法"></a>流量控制算法</h5><h5 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h5><h5 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h5><h5 id="RLE编码"><a href="#RLE编码" class="headerlink" title="RLE编码"></a>RLE编码</h5><h5 id="算数编码"><a href="#算数编码" class="headerlink" title="算数编码"></a>算数编码</h5><h4 id="分页的那些事儿"><a href="#分页的那些事儿" class="headerlink" title="分页的那些事儿"></a>分页的那些事儿</h4><h5 id="比较：物理分页和逻辑分页"><a href="#比较：物理分页和逻辑分页" class="headerlink" title="比较：物理分页和逻辑分页"></a>比较：物理分页和逻辑分页</h5><h5 id="比较：分页代码设计"><a href="#比较：分页代码设计" class="headerlink" title="比较：分页代码设计"></a>比较：分页代码设计</h5><h5 id="比较：SQL实现"><a href="#比较：SQL实现" class="headerlink" title="比较：SQL实现"></a>比较：SQL实现</h5><h5 id="重复数据问题"><a href="#重复数据问题" class="headerlink" title="重复数据问题"></a>重复数据问题</h5><h4 id="XML、JSON、YAML比较"><a href="#XML、JSON、YAML比较" class="headerlink" title="XML、JSON、YAML比较"></a>XML、JSON、YAML比较</h4><h5 id="比较：简洁和严谨"><a href="#比较：简洁和严谨" class="headerlink" title="比较：简洁和严谨"></a>比较：简洁和严谨</h5><h5 id="和JavaScript的亲和力"><a href="#和JavaScript的亲和力" class="headerlink" title="和JavaScript的亲和力"></a>和JavaScript的亲和力</h5><h5 id="路径表达式"><a href="#路径表达式" class="headerlink" title="路径表达式"></a>路径表达式</h5><h5 id="特殊字符处理"><a href="#特殊字符处理" class="headerlink" title="特殊字符处理"></a>特殊字符处理</h5><h4 id="代码审查"><a href="#代码审查" class="headerlink" title="代码审查"></a>代码审查</h4><h5 id="审查的流程"><a href="#审查的流程" class="headerlink" title="审查的流程"></a>审查的流程</h5><h5 id="常见的争议"><a href="#常见的争议" class="headerlink" title="常见的争议"></a>常见的争议</h5><h5 id="审查的好处"><a href="#审查的好处" class="headerlink" title="审查的好处"></a>审查的好处</h5><h5 id="审查的技巧"><a href="#审查的技巧" class="headerlink" title="审查的技巧"></a>审查的技巧</h5><h4 id="程序员学英语"><a href="#程序员学英语" class="headerlink" title="程序员学英语"></a>程序员学英语</h4><h5 id="为什么是必选项"><a href="#为什么是必选项" class="headerlink" title="为什么是必选项"></a>为什么是必选项</h5><h5 id="学英语的策略"><a href="#学英语的策略" class="headerlink" title="学英语的策略"></a>学英语的策略</h5>]]></content>
      <categories>
        <category>全栈</category>
      </categories>
      <tags>
        <tag>全栈</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonJS AMD CMD UMD esm 对比</title>
    <url>/2020/05/13/js/commonjs/</url>
    <content><![CDATA[<h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><p>CommonJS 是服务端模块的规范，Node.js采用了这个规范。</p>
<h5 id="CommonJS特性"><a href="#CommonJS特性" class="headerlink" title="CommonJS特性"></a>CommonJS特性</h5><pre><code>1. 一个文件就是一个模块，拥有单独的作用域。
2. CommonJS 模块输出的是一个值的拷贝。
3. CommonJS 模块是运行时加载。
4. CommonJS 模块的require()是同步加载模块。
</code></pre>
<h5 id="CommonJs的使用"><a href="#CommonJs的使用" class="headerlink" title="CommonJs的使用"></a>CommonJs的使用</h5><pre><code>CommonJs通过require来加载模块,通过module.exports或者exports来暴露模块中的内容。

//lib.js
function incCounter() &#123;
counter++;
&#125;
module.exports = &#123;
    incCounter: incCounter,
&#125;;

//main.js
const mod = require(&#39;./lib&#39;);
console.log(mod.counter);  // 3
mod.incCounter();
</code></pre>
<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>AMD的全称是Asynchronous Module Definition 异步加载模块， 它主要是使用在浏览器上，AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。</p>
<h5 id="AMD特性"><a href="#AMD特性" class="headerlink" title="AMD特性"></a>AMD特性</h5><pre><code>1. 采用异步方式加载模块，模块的加载不影响它后面语句的运行.
2. 所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行
3. 推崇依赖前置，在定义模块的时候就要声明其依赖的模块
</code></pre>
<h5 id="AMD的使用"><a href="#AMD的使用" class="headerlink" title="AMD的使用"></a>AMD的使用</h5><pre><code>使用require.js来实现AMD规范的模块化：用require.config()指定引用路径。用define()来定义模块用require来加载模块。

//通过数组引入依赖 ，回调函数通过形参传入依赖
define([&#39;someModule1&#39;, ‘someModule2’], function (someModule1, someModule2) &#123;

    function foo () &#123;
        /// someing
        someModule1.test();
    &#125;

    return &#123;foo: foo&#125;
&#125;);

AMD 规范允许输出模块兼容 CommonJS 规范，这时 define 方法如下：

define(function (require, exports, module) &#123;

    var reqModule = require(&quot;./someModule&quot;);
    requModule.test();
    
    exports.asplode = function () &#123;
        //someing
    &#125;
&#125;);
</code></pre>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><pre><code>CMD的全称是Common Module Definition通用模块定义,与AMD类似.不同点在于：AMD推崇依赖前置，提前执行，而CMD推崇依赖就近，延迟执行.它的使用和定义需要使用SeaJS.
</code></pre>
<h5 id="CMD特性"><a href="#CMD特性" class="headerlink" title="CMD特性"></a>CMD特性</h5><pre><code>1.采用异步方式加载模块，模块的加载不影响它后面语句的运行.
2.推崇就近依赖，只有在用到某个模块的时候再去require
</code></pre>
<h5 id="CMD的使用"><a href="#CMD的使用" class="headerlink" title="CMD的使用"></a>CMD的使用</h5><pre><code>使用define来定义define(id?, deps?, factory)
factory：一个函数，有三个参数，function(require, exports, module)
require：一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口：require(id)
exports：一个对象，用来向外提供模块接口
module：一个对象，上面存储了与当前模块相关联的一些属性和方法

// 定义模块  module.js
define(function(require, exports, module) &#123;
    var $ = require(&#39;jquery.min.js&#39;)
    $(&#39;div&#39;).addClass(&#39;active&#39;);
&#125;);

// 加载模块
seajs.use([&#39;module.js&#39;], function(my)&#123;
&#125;);

//AMD
define([&#39;./a&#39;,&#39;./b&#39;], function (a, b) &#123;

    //依赖一开始就写好
    a.test();
    b.test();
&#125;);

//CMD
define(function (requie, exports, module) &#123;
    
    //依赖可以就近书写
    var a = require(&#39;./a&#39;);
    a.test();
    
    ...
    //软依赖
    if (status) &#123;
    
        var b = requie(&#39;./b&#39;);
        b.test();
    &#125;
&#125;);
</code></pre>
<h4 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h4><pre><code>UMD的全称为Universal Module Definition，是一种javascript通用模块定义规范，让你的模块能在javascript所有运行环境中发挥作用，是跨平台的解决方案

    UMD 先判断是否支持 Node.js 的模块（exports）是否存在，存在则使用 Node.js 模块模式。 
    再判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块。

    (function (window, factory) &#123;
        if (typeof exports === &#39;object&#39;) &#123;
        
            module.exports = factory();
        &#125; else if (typeof define === &#39;function&#39; &amp;&amp; define.amd) &#123;
        
            define(factory);
        &#125; else &#123;
        
            window.eventUtil = factory();
        &#125;
    &#125;)(this, function () &#123;
        //module ...
    &#125;);
</code></pre>
<h4 id="esm"><a href="#esm" class="headerlink" title="esm"></a>esm</h4><pre><code>esm即ES6模块
</code></pre>
<h5 id="esm特性"><a href="#esm特性" class="headerlink" title="esm特性"></a>esm特性</h5><pre><code>1. 浏览器可以直接加载ES6模块,也是使用&lt;script&gt;标签,但是要加入type=&quot;module&quot;属性. &lt;script type=&quot;module&quot; src=&quot;./foo.js&quot;&gt;&lt;/script&gt;
2. ES6 的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。
3. ES6 模块输出的是值的引用。
4. ES6 模块是编译时输出接口。
5. ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。
</code></pre>
<h5 id="esm的使用"><a href="#esm的使用" class="headerlink" title="esm的使用"></a>esm的使用</h5><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的<br>对外接口，import命令用于输入其他模块提供的功能.</p>
<pre><code>// profile.js
    var year = 1958;
    export &#123; year &#125;;
    export default year;

//test.js
    import &#123; year &#125; from &#39;./profile.js&#39;; //对应export &#123;&#125;
    import year from &#39;./profile.js&#39;;  //对应export default
</code></pre>
<h4 id="ES6-模块与-CommonJS-模块的差异"><a href="#ES6-模块与-CommonJS-模块的差异" class="headerlink" title="ES6 模块与 CommonJS 模块的差异"></a>ES6 模块与 CommonJS 模块的差异</h4><pre><code>1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值
- ES6模块的运行机制与CommonJS不一样。JS引擎对脚本静态分析的时候，遇到模块加载命令import，
就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。
换句话说，ES6的import有点像Unix系统的“符号连接”，原始值变了，import加载的值也会跟着变。
因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

2. CommonJS模块是运行时加载，ES6模块是编译时输出接口
- 运行时加载: CommonJS模块就是对象；即在输入时是先加载整个模块，生成一个对象，
然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
- 编译时加载: ES6模块不是对象，而是通过export命令显式指定输出的代码，import时采用静态命令的形式。
即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。
</code></pre>
]]></content>
      <categories>
        <category>模块</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 软连接 硬连接作用</title>
    <url>/2020/01/08/linux/link/</url>
    <content><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><pre><code>实际生产环境中，使用第三方的工具，可能这个工具的库很大，很占用磁盘的空间。
想把它搬个位置，但是搬了位置这个工具岂不是找不到这个目录下的文件了，然而修改第三方工具显然不现实。
那么软连接的作用就来了，把文件搬去其他地方，在原来的位置创建软链接，简直完美。
好处: 仅仅是个链接，不占用空间，使用还是照常使用
</code></pre>
<h4 id="建立软链接和硬链接的语法"><a href="#建立软链接和硬链接的语法" class="headerlink" title="建立软链接和硬链接的语法"></a>建立软链接和硬链接的语法</h4><ul>
<li><p>软链接</p>
<blockquote>
<p>ln -s 源文件 目标文件</p>
</blockquote>
</li>
<li><p>硬链接</p>
<blockquote>
<p>ln 源文件 目标文件</p>
</blockquote>
<div class="info">
源文件：即你要对谁建立链接
</div></li>
</ul>
<h4 id="什么是软链接和硬链接"><a href="#什么是软链接和硬链接" class="headerlink" title="什么是软链接和硬链接"></a>什么是软链接和硬链接</h4><ul>
<li><p>软链接</p>
<blockquote>
<p>可以理解成快捷方式。它和windows下的快捷方式作用是一样的</p>
</blockquote>
</li>
<li><p>硬链接</p>
<blockquote>
<p>等于 cp -p 加同步更新<br> 在多用户的操作系统里，你写一个脚本，程序等，没有完成，保存后等下次有时间继续写，但是其他用户有可能将你未写完的东西当成垃圾清理掉，这时，你对你的程序，脚本等做一个硬链接，利用硬链接的同步更新，就可以防止别人误删你的源文件了。 </p>
</blockquote>
</li>
<li><p>建立软链接和硬链接<br><img src="/images/linux/link.png" alt="创建" loading="lazy"></p>
<pre><code>区别：
  1. 软链接
   软链接文件的大小和创建时间和源文件不同。
   软链接文件只是维持了从软链接到源文件的指向关系（从baishu.soft-&gt;baishu可以看出），
   不是源文件的内容，大小不一样容易理解。
  2. 硬链接
   硬链接文件和源文件的大小和创建时间一样。硬链接文件的内容和源文件的内容一模一样，
   相当于copy了一份。
   那么cp -p的文件是不是就相当于硬链接了呢？
   其实不然，对于源文件的内容有修改，硬链接文件会同步更新修改，始终保持和源文件的内容相同，
   而复制的文件则不可能做到这一点。
   所以，硬链接等于cp -p加同步更新。
</code></pre>
</li>
</ul>
<h4 id="删除源文件多软链接和硬链接的影响"><a href="#删除源文件多软链接和硬链接的影响" class="headerlink" title="删除源文件多软链接和硬链接的影响"></a>删除源文件多软链接和硬链接的影响</h4><pre><code>    和windows一样，删除源文件，快捷方式也用不了。
</code></pre>
<p><img src="/images/linux/link1.png" alt="创建" loading="lazy"><br>        但是删除源文件，为什么硬链接文件还可以查看呢？<br>        这里要简单说下i节点。<br>        i节点是文件和目录的唯一标识，每个文件和目录必有i节点，不然操作系统就无法识别该文件或系统，就像没有上户口的黑户。<br>        linux操作系统是不识别些字母的，像这些baishu ,baishu.hard操作系统根本不知道是什么玩意。<br><img src="/images/linux/link2.png" alt="创建" loading="lazy"><br>        如图，删除了baishu,只是删除了从922445到baishu的映射关系，不影响它和baishu.hard的映射关系。<br>        此图也解释了硬链接的同步更新，对源文件修改，操作系统只认i节点，<br>        于是操作系统就将修改内容写进所有i节点相同名字不同的文件。<br>        写到这里我突发奇想，如果对硬链接文件进行修改那么源文件会不会同步更新呢？<br>        这里肯定会的，大家可以把硬连接看成 - 对象的指针，如果修改原文件，引用打开同样也被修改了，像 java 内存回收一样，如果所有硬连接不存在，才会被回收删除。<br><img src="/images/linux/link3.png" alt="创建" loading="lazy"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql远程导入导出备份数据库/数据表</title>
    <url>/2019/03/15/mysql/mysql/</url>
    <content><![CDATA[<h4 id="导出数据库"><a href="#导出数据库" class="headerlink" title="导出数据库"></a>导出数据库</h4><h5 id="导出完整数据：表结构-数据"><a href="#导出完整数据：表结构-数据" class="headerlink" title="导出完整数据：表结构+数据"></a>导出完整数据：表结构+数据</h5> <div class="warning">

<blockquote>
<p>mysqldump -u 用户名 -p 数据库名 &gt; 数据库名.sql;</p>
</blockquote>
 </div>

<p> <img src="/images/mysql/mysql1.png" alt="mysql" loading="lazy"></p>
<ul>
<li>注意：如不指定生成文件的所在路径，则默认在当前命令行所在路径下。</li>
</ul>
<blockquote>
<p>dump -u root -p feature-workorder &gt; test.sql; test.sql则在 /tmp目录下</p>
</blockquote>
<blockquote>
<p>mysqldump -u root -p feature-workorder &gt; /usr/test.sql; test.sql则在 /usr目录下</p>
</blockquote>
<h5 id="导出完整数据：某一张数据表-数据"><a href="#导出完整数据：某一张数据表-数据" class="headerlink" title="导出完整数据：某一张数据表+数据"></a>导出完整数据：某一张数据表+数据</h5><div class="warning">

<blockquote>
<p>mysqldump -u 用户名 -p 数据库名 数据表名 &gt; 数据库名.sql;</p>
</blockquote>
</div>
#### 导出完整数据：某全部数据库+数据表+数据
<div class="warning">

<blockquote>
<p> mysqldump -u root -p –all-databases &gt; 文件.sql</p>
</blockquote>
 </div>
##### 只导出表结构（-d 选项）
 <div class="warning">

<blockquote>
<p> mysqldump -u 用户名 -p -d 数据库名 &gt; 数据库名.sql;</p>
</blockquote>
 </div>


<h4 id="导入数据库"><a href="#导入数据库" class="headerlink" title="导入数据库"></a>导入数据库</h4><h5 id="使用-mysql-命令导入"><a href="#使用-mysql-命令导入" class="headerlink" title="使用 mysql 命令导入"></a>使用 mysql 命令导入</h5> <div class="warning">

<blockquote>
<p> mysql -u 用户名 -p 数据库名 &lt; 数据库名.sql;</p>
</blockquote>
 </div>
- 将备份的数据库 test.sql 导入到数据库test中： 
<div class="warning">

<blockquote>
<p> mysql -u root -p test &lt; test.sql;</p>
</blockquote>
 </div>


<h5 id="使用-source-命令导入-常使用"><a href="#使用-source-命令导入-常使用" class="headerlink" title="使用 source 命令导入(常使用)"></a>使用 source 命令导入(常使用)</h5><ul>
<li>使用 source 命令需要我们先登录到 mysql 中，并创建一个空的数据库：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database test;      # 创建数据库</span><br><span class="line">mysql&gt; use test;                  # 使用已创建的数据库 </span><br><span class="line">mysql&gt; set names utf8;           # 设置编码</span><br><span class="line">mysql&gt; source /tmp/test.sql  # 导入备份数据库</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="远程导出主机的指定数据库全部数据表（数据-结构）"><a href="#远程导出主机的指定数据库全部数据表（数据-结构）" class="headerlink" title="远程导出主机的指定数据库全部数据表（数据+结构）"></a>远程导出主机的指定数据库全部数据表（数据+结构）</h5><div class="warning">

<blockquote>
<p> mysqldump  -u 用户名 -p –host=主机地址 数据库名 &gt; 文件名.sql</p>
</blockquote>
 </div>]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs中where条件sql字符串拼装</title>
    <url>/2022/02/18/mysql/where/</url>
    <content><![CDATA[<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>通常在复杂的查询中都会用到where语句，自然各条件可能传可能不传值，如下</p>
<pre><code>function createSql(search,state) &#123;
        let sql = &#39;&#39;
        if (search !== undefined &amp;&amp; state === undefined) &#123;
            sql = `where remark LIKE &#39;%$&#123;search&#125;%&#39;`
        &#125;else if (search === undefined &amp;&amp; state !== undefined) &#123;
            sql = `where state=$&#123;state&#125;`
        &#125;else if (search !== undefined &amp;&amp; state !== undefined) &#123;
            sql = `where remark LIKE &#39;%$&#123;search&#125;%&#39; and state=$&#123;state&#125;`
        &#125;
        return sql
    &#125;
</code></pre>
<ul>
<li> 示例：</li>
</ul>
<pre><code>createSql(&#39;关键&#39;,0)
=&gt; &quot;where remark LIKE &#39;%关键%&#39; and state=0&quot;
</code></pre>
<h4 id="封装成工具函数"><a href="#封装成工具函数" class="headerlink" title="封装成工具函数"></a>封装成工具函数</h4><pre><code>1. 参数全为undefined
2. 参数个数不限制

const createwhere = (arr) =&gt; &#123;
let _isFirst = true
const _sql = arr.map((it,idx) =&gt; &#123;
    const _key = Object.keys(it)[0]
    const _value = Object.values(it)[0]
    if(_value===undefined) return
    if(_isFirst)&#123;
    _isFirst = false
    return `where $&#123;_key&#125; = &#39;$&#123;_value&#125;&#39;`
    &#125;
    return `and $&#123;_key&#125; = &#39;$&#123;_value&#125;&#39;`
&#125;)
console.log(_sql.join(&#39; &#39;))
return _sql.join(&#39; &#39;)
&#125;
</code></pre>
<ul>
<li> 示例：</li>
</ul>
<pre><code>const val1 = &#39;test&#39;
const val2 = &#39;0&#39;
const val3 = undefined
createwhere([&#123;name:val1&#125;,&#123;remark:val2&#125;,&#123;key:val3&#125;])
=&gt; where name = &#39;test&#39; and remark = &#39;11&#39; 
</code></pre>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS</title>
    <url>/2019/03/27/network/dns/</url>
    <content><![CDATA[<h4 id="HTTP请求完整过程"><a href="#HTTP请求完整过程" class="headerlink" title="HTTP请求完整过程"></a>HTTP请求完整过程</h4><blockquote>
<p>当用户在浏览器输入网址回车之后，网络协议都做了哪些工作呢？</p>
</blockquote>
<p><img src="/images/network/dns.png" alt="dns查询" loading="lazy"></p>
<ol>
<li>首先干活的是浏览器应用程序，他要解析出URL中的域名</li>
<li>根据域名获取对应的ip地址，首先从浏览器缓存中查看，如下可以查看浏览器中域名对应ip的解析</li>
</ol>
<ul>
<li>chrome://net-internals/#events<br>如果没有则从本机域名解析文件hosts（/etc/hosts）中查看，还没有则从LDNS（Localdnsserver）、Rootserver域名服务器、国际顶级域名服务商的DNS的层层解析</li>
</ul>
<div class="danger">

<blockquote>
<p>新开一个标签页，输入：chrome://net-internals/#sockets，点击“Flush socket pools”</p>
</blockquote>
</div>

<ol start="3">
<li>拿到IP地址后，浏览器就可以发起与服务器的三次握手</li>
<li>握手建立之后，就开始组装http请求报文，发送报文</li>
<li>服务器收到请求报文之后，请求报文解析，生成响应数据，发送响应数据</li>
<li>浏览器收到响应之后，开始渲染页面<br><img src="/images/network/dnshttp.png" alt="http分层解析" loading="lazy"></li>
</ol>
<h4 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h4><ol>
<li>查找浏览器缓存</li>
</ol>
<ul>
<li>浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就将结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等。这个缓存时间太长和太短都不好，如果缓存时间太长，一旦域名被解析到的IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致该域名不能正常解析，这段时间内有可能会有一部分用户无法访问网站。如果时间设置太短，会导致用户每次访问网站都要重新解析一次域名。</li>
</ul>
<ol start="2">
<li>查找系统缓存</li>
</ol>
<ul>
<li>如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。其实操作系统也会有一个域名解析的过程，在Windows中可以通过C:\Windows\System32\drivers\etc\hosts文件来设置，你可以将任何域名解析到任何能够访问的IP地址。如果你在这里指定了一个域名对应的IP地址，那么浏览器会首先使用这个IP地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地DNS解析的规程，所以黑客就有可能通过修改你的域名解析来把特定的域名解析到它指定的IP地址上，导致这些域名被劫持。</li>
</ul>
<ol start="3">
<li>查找路由器缓存</li>
</ol>
<ul>
<li>如果系统缓存中也找不到，那么查询请求就会发向路由器，它一般会有自己的DNS缓存。</li>
</ul>
<ol start="4">
<li>查找ISP DNS 缓存</li>
</ol>
<ul>
<li>运气实在不好，就只能查询ISP DNS 缓存服务器了。在我们的网络配置中都会有”DNS服务器地址”这一项，操作系统会把这个域名发送给这里设置的DNS，也就是本地区的域名服务器，通常是提供给你接入互联网的应用提供商。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受域名的失效时间控制的，一般缓存空间不是影响域名失效的主要因素。大约80%的域名解析都到这里就已经完成了，所以ISP DNS主要承担了域名的解析工作。</li>
</ul>
<ol start="5">
<li>递归搜索</li>
</ol>
<ul>
<li>在前面都没有办法命中的DNS缓存的情况下,</li>
<li><ul>
<li>(1)本地 DNS服务器即将该请求转发到互联网上的根域（即一个完整域名最后面的那个点，通常省略不写）。</li>
</ul>
</li>
<li><ul>
<li>(2)根域将所要查询域名中的顶级域（假设要查询ke.qq.com，该域名的顶级域就是com）的服务器IP地址返回到本地DNS。</li>
</ul>
</li>
<li><ul>
<li>(3) 本地DNS根据返回的IP地址，再向顶级域（就是com域）发送请求。</li>
</ul>
</li>
<li><ul>
<li>(4) com域服务器再将域名中的二级域（即ke.qq.com中的qq）的IP地址返回给本地DNS。</li>
</ul>
</li>
<li><ul>
<li>(5) 本地DNS再向二级域发送请求进行查询。</li>
</ul>
</li>
<li><ul>
<li>(6) 之后不断重复这样的过程，直到本地DNS服务器得到最终的查询结果，并返回到主机。这时候主机才能通过域名访问该网站。</li>
</ul>
</li>
</ul>
<h4 id="DNS有关的网络性能优化"><a href="#DNS有关的网络性能优化" class="headerlink" title="DNS有关的网络性能优化"></a>DNS有关的网络性能优化</h4><ol>
<li>减少DNS查找，避免重定向 　　浏览器DNS缓存 、计算机DNS缓存、 服务器DNS缓存、使用Keep-Alive特性 来减少DNS查找。考虑影响DNS缓存的因素：</li>
</ol>
<ul>
<li>服务器可以设置TTL值表示DNS记录的存活时间。本机DNS缓存将根据这个TTL值判断DNS记录什么时候被抛弃，这个TTL值一般都不会设置很大，主要是考虑到快速故障转移的问题。</li>
<li>浏览器DNS缓存也有自己的过期时间，这个时间是独立于本机DNS缓存的，相对也比较短，例如chrome只有1分钟左右。</li>
<li>浏览器DNS记录的数量也有限制，如果短时间内访问了大量不同域名的网站，则较早的DNS记录将被抛弃，必须重新查找。不过即使浏览器丢弃了DNS记录，操作系统的DNS缓存也有很大机率保留着该记录，这样可以避免通过网络查询而带来的延迟。</li>
</ul>
<ol start="2">
<li>DNS的预解析</li>
</ol>
<ul>
<li>可以通过用meta信息来告知浏览器, 我这页面要做DNS预解析<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>可以使用link标签来强制对DNS做预解析:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;dns-prefetch&quot; href=&quot;http://ke.qq.com/&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li>当客户端的DNS缓存为空时，DNS查找的数量与Web页面中唯一主机名的数量相等。减少唯一主机名的数量就可以减少DNS查找的数量。较少的域名来减少DNS查找（2-4个主机）</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP</title>
    <url>/2019/01/07/network/tcpip/</url>
    <content><![CDATA[<h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h4><blockquote>
<p>TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。</p>
</blockquote>
<h5 id="TCP-IP模型与OSI模型各层的对照关系"><a href="#TCP-IP模型与OSI模型各层的对照关系" class="headerlink" title="TCP/IP模型与OSI模型各层的对照关系"></a>TCP/IP模型与OSI模型各层的对照关系</h5><p><img src="/images/network/tcpip.png" alt="TCP/IP模型与OSI模型" loading="lazy"></p>
<h5 id="数据进入协议栈时的封装过程"><a href="#数据进入协议栈时的封装过程" class="headerlink" title="数据进入协议栈时的封装过程"></a>数据进入协议栈时的封装过程</h5><p><img src="/images/network/data.png" alt="封装过程" loading="lazy"></p>
<h5 id="HTTP协议通信过程"><a href="#HTTP协议通信过程" class="headerlink" title="HTTP协议通信过程"></a>HTTP协议通信过程</h5><p>TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程，下图以HTTP协议为例<br><img src="/images/network/httpdata.png" alt="数据入栈与出栈" loading="lazy"></p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Http服务器性能测试</title>
    <url>/2021/03/01/node/http/</url>
    <content><![CDATA[<pre><code>想要优化性能，首先要做性能检查
</code></pre>
<h4 id="压力测试工具"><a href="#压力测试工具" class="headerlink" title="压力测试工具"></a>压力测试工具</h4><pre><code>1. ab ApacheBench
2. webbench
</code></pre>
<h4 id="AB的简介"><a href="#AB的简介" class="headerlink" title="AB的简介"></a>AB的简介</h4><pre><code>ab是apacheBench命令的缩写。
ab是apache自带的压力测试工具。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其他类型的服务器进行压力测试。比如nginx、tomcat、IIS等
</code></pre>
<h4 id="AB的原理"><a href="#AB的原理" class="headerlink" title="AB的原理"></a>AB的原理</h4><pre><code>ab命令会创建多个并发访问线程，模拟多个访问者同时对某一个URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。
ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也需要注意，否则一次上太多的负载。可能造成目标服务器资源耗完，严重时甚至导致死机
</code></pre>
<h4 id="ab的使用"><a href="#ab的使用" class="headerlink" title="ab的使用"></a>ab的使用</h4><pre><code>常用方式：ab -c 500 -n 5000 http://localhost/
-n 在测试会话中所执行的请求个数（总数）
-c 一次产生的请求个数（单次请求次数）

[root@baishu /]# ab -c 500 -n 5000 http://localhost/
            This is ApacheBench, Version 2.3 &lt;$Revision: 1430300 $&gt;
            Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
            Licensed to The Apache Software Foundation, http://www.apache.org/

            Benchmarking localhost (be patient)
            Completed 500 requests
            Completed 1000 requests
            Completed 1500 requests
            Completed 2000 requests
            Completed 2500 requests
            Completed 3000 requests
            Completed 3500 requests
            Completed 4000 requests
            Completed 4500 requests
            Completed 5000 requests
            Finished 5000 requests


            Server Software:        nginx/1.15.3        #测试服务器的名字
            Server Hostname:        localhost            #请求的URL主机名
            Server Port:            80                          #请求端口

            Document Path:          /                        #请求路径
            Document Length:        613 bytes          #HTTP响应数据的正文长度

            Concurrency Level:      500                    #并发用户数，这是我们设置的参数之一
            Time taken for tests:   0.407 seconds     #所有这些请求被处理完成所花费的总时间 单位秒
            Complete requests:      5000                  #总请求数量，这是我们设置的参数之一
            Failed requests:        0                           #表示失败的请求数量
            Write errors:           0                            
            Total transferred:      4230000 bytes       #所有请求的响应数据长度总和。包括每个HTTP响应数据的头信息和正文数据的长度
            HTML transferred:       3065000 bytes     #所有请求的响应数据中正文数据的总和，也就是减去了Total transferred中HTTP响应数据中的头信息的长度
            Requests per second:    12284.44 [#/sec] (mean)    #吞吐量，计算公式：Complete requests/Time taken for tests  总请求数/处理完成这些请求数所花费的时间
            Time per request:       40.702 [ms] (mean)             #用户平均请求等待时间，计算公式：Time token for tests/（Complete requests/Concurrency Level）。处理完成所有请求数所花费的时间/（总请求数/并发用户数）     
            Time per request:       0.081 [ms] (mean, across all concurrent requests)    #服务器平均请求等待时间，计算公式：Time taken for tests/Complete requests，正好是吞吐率的倒数。也可以这么统计：Time per request/Concurrency Level
            Transfer rate:          10149.06 [Kbytes/sec] received。  #表示这些请求在单位时间内从服务器获取的数据长度，计算公式：Total trnasferred/ Time taken for tests，这个统计很好的说明服务器的处理能力达到极限时，其出口宽带的需求量。

            Connection Times (ms)
                        min  mean[+/-sd] median   max
            Connect:        0    2   0.8      1       6
            Processing:     3    5   7.9      5     399
            Waiting:        0    4   7.9      4     399
            Total:          4    7   8.0      7     404
            WARNING: The median and mean for the initial connection time are not within a normal deviation
                    These results are probably not that reliable.

            Percentage of the requests served within a certain time (ms)
            50%      7               #50%用户请求在7ms内返回
            66%      7               #60%用户请求在7ms内返回
            75%      7
            80%      7
            90%      7
            95%      7
            98%     12              #98%用户请求在12ms内返回
            99%     12
            100%    404 (longest request)
</code></pre>
]]></content>
      <categories>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP1.0、1.1、2.0协议的特性及区别</title>
    <url>/2019/03/02/network/http/</url>
    <content><![CDATA[<h4 id="HTTP的历史"><a href="#HTTP的历史" class="headerlink" title="HTTP的历史"></a>HTTP的历史</h4><p><img src="/images/network/http1.png" alt="HTTP历史" loading="lazy"></p>
<h4 id="HTTP-1-0-——-无状态无连接的应用层协议"><a href="#HTTP-1-0-——-无状态无连接的应用层协议" class="headerlink" title="HTTP/1.0 —— 无状态无连接的应用层协议"></a>HTTP/1.0 —— 无状态无连接的应用层协议</h4><ul>
<li>无状态：服务器不跟踪不记录请求过的状态</li>
<li>无连接：浏览器每次请求都需要建立tcp连接<br>HTTP/1.0规定浏览器和服务器保持短暂的连接。浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）<h5 id="无状态导致的问题："><a href="#无状态导致的问题：" class="headerlink" title="无状态导致的问题："></a>无状态导致的问题：</h5><blockquote>
<p>可以借助cookie/session机制来做身份认证和状态记录解决。</p>
</blockquote>
<h5 id="无连接导致的问题："><a href="#无连接导致的问题：" class="headerlink" title="无连接导致的问题："></a>无连接导致的问题：</h5><blockquote>
<ol>
<li>无法复用连接。每次发送请求的时候，都需要进行一次TCP连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会导致网络的利用率非常低。</li>
<li>队头堵塞(head of line blocking)。由于HTTP/1.0规定下一个请求必须在前一个请求响应到达之前才能发送。假设一个请求响应一直不到达，那么下一个请求就不发送，就到导致阻塞后面的请求。</li>
</ol>
</blockquote>
</li>
</ul>
<p>为了解决这些问题，HTTP/1.1出现了。</p>
<h4 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h4><ul>
<li>长连接: HTTP/1.1增加了一个Connection字段，通过设置Keep-alive（默认已设置）可以保持连接不断开，避免了每次客户端与服务器请求都要重复建立释放TCP连接，提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带Connection:false来告知服务器关闭请求</li>
<li>支持请求管道化（pipelining）。基于HTTP/1.1的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。举个例子来说，假如响应的主体是一个html页面，页面中包含了很多img，这个时候keep-alive就起了很大的作用，能够进行“并行”发送多个请求。<br>此外，HTTP/1.1还加入了缓存处理，新的字段如cache-control，支持断点传输，以及增加了Host字段（使得一个服务器能够用来创建多个Web站点）。</li>
</ul>
<h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h4><ul>
<li>帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。</li>
<li>流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。</li>
<li>消息：与逻辑消息对应的完整的一系列数据帧。<h5 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a><font color="#dd0000">二进制分帧</font></h5>HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式，二进制协议解析起来更高效。 HTTP / 1 的请求和响应报文，都是由起始行，首部和实体正文（可选）组成，各部分之间以文本换行符分隔。HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码。<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a><font color="#dd0000">多路复用</font></h5></li>
<li>同域名下的所有通信都在单个连接中完成。</li>
<li>单个连接可以承载任意数量的双向数据流。</li>
<li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。<blockquote>
<ul>
<li>同个域名只需要占用一个TCP连接，消除了因多个TCP连接而带来的延时和内存消耗。</li>
<li>单个连接上可以并行交错地请求和响应，之间互不干扰。</li>
<li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。<br>可见，HTTP/2.0实现了真正的并行传输，它能够在一个TCP上进行任意数量HTTP请求。而这个强大的功能则是基于“二进制分帧”的特性。</li>
</ul>
</blockquote>
<h5 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a><font color="#dd0000">头部压缩</font></h5>在HTTP/1.x中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500~800字节的负荷。<br>比如说cookie，默认情况下，浏览器会在每次请求的时候，把cookie附在header上面发送给服务器。（由于cookie比较大且每次都重复发送，一般不存储信息，只是用来做状态记录和身份认证）<br>HTTP/2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。<h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a><font color="#dd0000">服务器推送</font></h5>服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。<br>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。<h4 id="各个协议的区别"><a href="#各个协议的区别" class="headerlink" title="各个协议的区别"></a>各个协议的区别</h4><h5 id="HTTP-1-x-keep-alive-与-HTTP-2-多路复用区别"><a href="#HTTP-1-x-keep-alive-与-HTTP-2-多路复用区别" class="headerlink" title="HTTP/1.x keep-alive 与 HTTP/2 多路复用区别"></a><font color="#dd0000">HTTP/1.x keep-alive 与 HTTP/2 多路复用区别</font></h5></li>
<li>HTTP/1.x 是基于文本的，只能整体去传；HTTP/2 是基于二进制流的，可以分解为独立的帧，交错发送</li>
<li>HTTP/1.x keep-alive 必须按照请求发送的顺序返回响应；HTTP/2 多路复用不按序响应</li>
<li>HTTP/1.x keep-alive 为了解决队头阻塞，将同一个页面的资源分散到不同域名下，开启了多个 TCP 连接；HTTP/2 同域名下所有通信都在单个连接上完成</li>
<li>TTP/1.x keep-alive 单个 TCP 连接在同一时刻只能处理一个请求（两个请求的生命周期不能重叠）；HTTP/2 单个 TCP 同一时刻可以发送多个请求和响应</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js性能分析工具</title>
    <url>/2021/03/07/node/nodeanalysis/</url>
    <content><![CDATA[<h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><h5 id="Node-js自带profile"><a href="#Node-js自带profile" class="headerlink" title="Node.js自带profile"></a>Node.js自带profile</h5><pre><code>1. node --prof app.js
</code></pre>
<p><img src="/images/node/prof.png" alt="node --prof" loading="lazy"><br>    2. ab -c 50 -t 15 <a href="http://localhost:4000/dashboard/robotData">http://localhost:4000/dashboard/robotData</a><br>    3. node –prof-process isolate-0x1046cc000-6970-v8.log &gt; processed.txt<br><img src="/images/node/txt.png" alt="node txt" loading="lazy"><br><img src="/images/node/profile.png" alt="node --profile" loading="lazy"></p>
<h5 id="Chrome-devtool"><a href="#Chrome-devtool" class="headerlink" title="Chrome devtool"></a>Chrome devtool</h5><pre><code>1. node --inspect-brk app.js
2. open chrome://inspect/#devices
3. profiler

缺点：图形化工具，不能用命令行搜集数据
</code></pre>
<h5 id="npm-clinic"><a href="#npm-clinic" class="headerlink" title="npm - clinic"></a>npm - clinic</h5><p><a href="https://clinicjs.org/doctor/">https://clinicjs.org/doctor/</a></p>
<h4 id="Javascript-代码性能优化"><a href="#Javascript-代码性能优化" class="headerlink" title="Javascript 代码性能优化"></a>Javascript 代码性能优化</h4><h5 id="计算性能优化的本质"><a href="#计算性能优化的本质" class="headerlink" title="计算性能优化的本质"></a>计算性能优化的本质</h5><pre><code>1. 减少不必要的计算
2. 空间换时间

思考：在用户能感知到的时间里，这个计算是不是必要的？
</code></pre>
<h5 id="Node-js-Http服务性能优化准则："><a href="#Node-js-Http服务性能优化准则：" class="headerlink" title="Node.js Http服务性能优化准则："></a>Node.js Http服务性能优化准则：</h5><pre><code>1. 提前计算
</code></pre>
<p><img src="/images/node/principle.png" alt="node principle" loading="lazy"></p>
]]></content>
      <categories>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs 学习路线</title>
    <url>/2020/05/01/node/what/</url>
    <content><![CDATA[<h4 id="Node-js到底是什么"><a href="#Node-js到底是什么" class="headerlink" title="Node.js到底是什么"></a>Node.js到底是什么</h4><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型。</p>
<pre><code>是框架？❌ 库？❌ 语言？❌
</code></pre>
<p>⚠️统统不是⚠️<br>Nodejs -&gt; JavaScript运行平台/运行时（platform / Runtime）</p>
<h5 id="什么是运行平台-运行时"><a href="#什么是运行平台-运行时" class="headerlink" title="什么是运行平台/运行时"></a>什么是运行平台/运行时</h5><p><img src="/images/node/what_node_1.png" alt="what_node_1" loading="lazy"></p>
<pre><code>定义：运行平台一般就是指一个代码的运行环境
作用：开发者可以使用指定的编程语言，基于某个环境开发特定的应用
</code></pre>
<p>🏷️ 平台就是为编程语言「赋能」，基于某个环境开发特定的应用</p>
<p><img src="/images/node/what_node_2.png" alt="what_node_2" loading="lazy"><br><img src="/images/node/what_node_3.png" alt="what_node_3" loading="lazy"><br><img src="/images/node/what_node_4.png" alt="what_node_4" loading="lazy"></p>
<h4 id="Node-js可以做什么"><a href="#Node-js可以做什么" class="headerlink" title="Node.js可以做什么"></a>Node.js可以做什么</h4><pre><code>平台的作用就是提供「舞台」
- 理论上平台没有绝对只能干什么的限制

平台提供的能力 约等于 提供的底层APIs
- 能不能实现，就看有没有相应的API
</code></pre>
<p><img src="/images/node/what_node_5.png" alt="what_node_5" loading="lazy"></p>
<blockquote>
<p>🌟 Node.js「无所不能」，既然「无所不能」,为何没有「无处不在」❓</p>
</blockquote>
<pre><code>人员角度：
- Node.js平台采用的语言是JavaScript，适合前端开发者使用

技术角度：
- Node.js平台的特点是非阻塞IO，适合处理高并发请求
</code></pre>
<p>结论：</p>
<blockquote>
<ol>
<li>Node.js适合开发服务器端的中间层（BFF）<br><img src="/images/node/what_node_6.png" alt="what_node_6" loading="lazy"></li>
<li>Node.js适合用于开发前端方向的各种工具<br>webpack、Gulp、vite、BABEL、TS 等</li>
</ol>
</blockquote>
<h4 id="Node-js全局对象"><a href="#Node-js全局对象" class="headerlink" title="Node.js全局对象"></a>Node.js全局对象</h4><ul>
<li><p>global</p>
</li>
<li><p>__filename</p>
<pre><code>  __filename 表示当前正在执行的脚本的文件名
</code></pre>
</li>
<li><p>__dirname</p>
<pre><code>  __dirname 表示当前执行脚本所在的目录
</code></pre>
</li>
<li><p>setTimeout(cb, ms)</p>
</li>
<li><p>clearTimeout(t)</p>
</li>
<li><p>setInterval(cb, ms)</p>
</li>
<li><p>console</p>
</li>
<li><p>process</p>
<pre><code>  exit： 当进程准备退出时触发。
  beforeExit： 当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 &#39;beforeExit&#39; 的监听器可以异步调用，这样 node 就会继续执行。
  uncaughtException：当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。
  Signal 事件：当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。
  stdout：标准输出流。
  stderr：标准错误流。
  stdin：标准输入流。
  argv：argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。
  env：返回一个对象，成员为当前 shell 的环境变量
  pid：当前进程的进程号。
  title：进程名，默认值为&quot;node&quot;，可以自定义该值。
  arch：当前 CPU 的架构：&#39;arm&#39;、&#39;ia32&#39; 或者 &#39;x64&#39;。
  platform：运行程序所在的平台系统 &#39;darwin&#39;, &#39;freebsd&#39;, &#39;linux&#39;, &#39;sunos&#39; 或 &#39;win32&#39;
  mainModule：require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。
  abort()：这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。
  cwd()：返回当前进程的 工作 目录
  exit([code])：使用指定的 code 结束进程。如果忽略，将会使用 code 0。
  memoryUsage()：返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。
  nextTick(callback)：一旦当前事件循环结束，调用回调函数。
</code></pre>
</li>
</ul>
<h4 id="为何一定要掌握Node-js？"><a href="#为何一定要掌握Node-js？" class="headerlink" title="为何一定要掌握Node.js？"></a>为何一定要掌握Node.js？</h4><pre><code>理由一：现代化的Web开发离不开
- 定制打包、构建等自动化任务需求
- 高体验的开发服务器需求

理由二：高性能Web服务的中间层
- 非阻塞IO、事件循环，处理高并发，天生高手
- 前端人也能轻易玩转的服务端技术，更适合中间层
</code></pre>
<h4 id="小案例：批量修改文件名字"><a href="#小案例：批量修改文件名字" class="headerlink" title="小案例：批量修改文件名字"></a>小案例：批量修改文件名字</h4><ul>
<li><ol>
<li>mkdir renames<br>index.js<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node  // 不能缺少</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.readdir(process.cwd(),<span class="function">(<span class="params">err,files</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(files,<span class="string">&#x27;files&#x27;</span>)</span><br><span class="line">    files.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        fs.rename(</span><br><span class="line">            path.join(process.cwd(),item),</span><br><span class="line">            path.join(process.cwd(),<span class="string">&#x27;prefix_&#x27;</span>+item),</span><br><span class="line">            <span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(err) <span class="keyword">throw</span> err</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span>--&gt;prefix_<span class="subst">$&#123;item&#125;</span>`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
package.json<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;renames&quot;</span>,</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;bin&quot;</span>: <span class="string">&quot;index.js&quot;</span>, <span class="comment">//   脚本</span></span><br><span class="line">    <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;keywords&quot;</span>: [],</span><br><span class="line">    <span class="string">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>npm link 软连接</li>
</ol>
</li>
<li><ol start="3">
<li>测试<br><img src="/images/node/node_tool.png" alt="node_tool" loading="lazy"></li>
</ol>
</li>
</ul>
<h4 id="Node-js可以满足前端开发中那些「奇怪」的想法"><a href="#Node-js可以满足前端开发中那些「奇怪」的想法" class="headerlink" title="Node.js可以满足前端开发中那些「奇怪」的想法"></a>Node.js可以满足前端开发中那些「奇怪」的想法</h4><pre><code>- 自动化创建项目
- 自动化构建
- 自动化测试
- 自动化部署
- 跨平台转译
</code></pre>
<h4 id="Node-js开发Cli工具"><a href="#Node-js开发Cli工具" class="headerlink" title="Node.js开发Cli工具"></a>Node.js开发Cli工具</h4><ul>
<li><ol>
<li>mkdir myvuecli<br>npm init –y<br>tsc –init<br><img src="/images/node/node_cli.png" alt="node_cli" loading="lazy"><br>package.json<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;myvuecli&quot;,</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;&quot;,</span><br><span class="line">    &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">    &quot;bin&quot;: &quot;cli.js&quot;,</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;build&quot;: &quot;tsc&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;keywords&quot;: [],</span><br><span class="line">    &quot;author&quot;: &quot;&quot;,</span><br><span class="line">    &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">    &quot;dependencies&quot;: &#123;</span><br><span class="line">        &quot;ejs&quot;: &quot;^3.1.7&quot;,</span><br><span class="line">        &quot;inquirer&quot;: &quot;^8.2.4&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
cli.ts<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env node</span><br><span class="line">const inquirer = require(&#x27;inquirer&#x27;)</span><br><span class="line">const path = require(&#x27;path&#x27;)</span><br><span class="line">const fs = require(&#x27;fs&#x27;)</span><br><span class="line">const ejs = require(&#x27;ejs&#x27;)</span><br><span class="line"></span><br><span class="line">inquirer.prompt([</span><br><span class="line">    &#123;</span><br><span class="line">        type:&#x27;input&#x27;,</span><br><span class="line">        name:&#x27;name&#x27;,</span><br><span class="line">        message:&#x27;Project name::&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">]).then((answers:object)=&gt;&#123;</span><br><span class="line">    const tempDir = path.join(__dirname,&#x27;templates&#x27;)</span><br><span class="line">    const destDir = process.cwd()</span><br><span class="line"></span><br><span class="line">    fs.readdir(tempDir,(err:object,files:Array&lt;string&gt;)=&gt;&#123;</span><br><span class="line">        if(err) throw err</span><br><span class="line">        files.forEach((file:string)=&gt;&#123;</span><br><span class="line">            console.log(file)</span><br><span class="line">            ejs.renderFile(path.join(tempDir,file),answers,(err:object,result:string)=&gt;&#123;</span><br><span class="line">                if(err) throw err</span><br><span class="line">                fs.writeFileSync(path.join(destDir,file),result)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(answers,&#x27;answers answers&#x27;,destDir)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol start="2">
<li>npm run build </li>
</ol>
</li>
<li><ol start="3">
<li>npm link</li>
</ol>
</li>
<li><ol start="4">
<li>mkdir testvuecli</li>
</ol>
</li>
<li><ol start="5">
<li>cd testvuecli -&gt; myvuecli<br><img src="/images/node/node_test.png" alt="node_test" loading="lazy"></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac用scp上传或下载文件</title>
    <url>/2019/02/09/practical/scp/</url>
    <content><![CDATA[<h4 id="scp-的使用"><a href="#scp-的使用" class="headerlink" title="scp 的使用"></a>scp 的使用</h4><h5 id="传输本地文件到服务器"><a href="#传输本地文件到服务器" class="headerlink" title="传输本地文件到服务器"></a>传输本地文件到服务器</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#scp 文件名 用户名@服务器ip:目标路径</span><br><span class="line">scp /file-path/ root@server-ip:<span class="regexp">/file-path/</span></span><br></pre></td></tr></table></figure>

<h5 id="传输本地文件夹到服务器"><a href="#传输本地文件夹到服务器" class="headerlink" title="传输本地文件夹到服务器"></a>传输本地文件夹到服务器</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scp -r 文件夹目录 用户名@服务器ip:目标路径</span><br><span class="line">scp -r /path/folder root@server-ip:<span class="regexp">/path/</span></span><br></pre></td></tr></table></figure>

<h5 id="下载服务器文件到本地"><a href="#下载服务器文件到本地" class="headerlink" title="下载服务器文件到本地"></a>下载服务器文件到本地</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scp 用户名@服务器ip:文件路径 目标路径</span><br><span class="line">scp root@server-ip:<span class="regexp">/file-path/</span> <span class="regexp">/file-path/</span></span><br></pre></td></tr></table></figure>

<h5 id="如果服务器指定了端口"><a href="#如果服务器指定了端口" class="headerlink" title="如果服务器指定了端口"></a>如果服务器指定了端口</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scp -P 端口号 文件路径 用户名@服务器ip:文件保存路径</span><br><span class="line">scp -P port /file/path root@server-ip:<span class="regexp">/path/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简易的webpack</title>
    <url>/2022/03/16/webpack/build/</url>
    <content><![CDATA[<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><h5 id="模块化：增强代码可读性和维护性"><a href="#模块化：增强代码可读性和维护性" class="headerlink" title="模块化：增强代码可读性和维护性"></a>模块化：增强代码可读性和维护性</h5><pre><code>传统的网页开发转变成 Web Apps 开发 
代码复杂度在逐步增高 
分离的 JS文件/模块，便于后续代码的维护性 部
署时希望把代码优化成几个 HTTP 请求
</code></pre>
<h5 id="常见的几种模块化方式"><a href="#常见的几种模块化方式" class="headerlink" title="常见的几种模块化方式"></a>常见的几种模块化方式</h5><pre><code>1.ES module
import * as largeNumber from &#39;large-number&#39;;
// ...
largeNumber.add(&#39;999&#39;, &#39;1&#39;);

2.CJS
const largeNumbers = require(&#39;large-number&#39;);
// ...
largeNumber.add(&#39;999&#39;, &#39;1&#39;);

3.AMD
require([&#39;large-number&#39;], function (large-number) &#123;
//...
largeNumber.add(&#39;999&#39;, &#39;1&#39;);
&#125;);
</code></pre>
<h5 id="AST-基础知识"><a href="#AST-基础知识" class="headerlink" title="AST 基础知识"></a>AST 基础知识</h5><pre><code>抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是 源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都 表示源代码中的一种结构。
</code></pre>
<p><img src="/images/webpack/ast.png" alt="ast" loading="lazy"></p>
<h5 id="Webpack-模块机制"><a href="#Webpack-模块机制" class="headerlink" title="Webpack 模块机制"></a>Webpack 模块机制</h5><p><img src="/images/webpack/modules.png" alt="modules" loading="lazy"><br>    · 打包出来的是一个 IIFE (匿名闭包)<br>    · modules 是一个数组，每一项是一个模块初始化函数<br>    · __webpack_require 用来加载模块，返回 module.exports<br>    · 通过 WEBPACK_REQUIRE_METHOD(0) 启动程序</p>
<h4 id="简易webpack"><a href="#简易webpack" class="headerlink" title="简易webpack"></a>简易webpack</h4><pre><code>1. 可以将 ES6 语法转换成 ES5 的语法
    ·通过 babylon 生成AST
    ·通过 babel-core 将AST重新生成源码
2. 可以分析模块之间的依赖关系
    ·通过 babel-traverse 的 ImportDeclaration 方法获取依赖属性
3. 生成的 JS 文件可以在浏览器中运行
</code></pre>
<h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p><img src="/images/webpack/catalog.png" alt="catalog" loading="lazy"></p>
<h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h5><pre><code>    &#123;
        &quot;name&quot;: &quot;spack&quot;,
        &quot;version&quot;: &quot;1.0.0&quot;,
        &quot;description&quot;: &quot;&quot;,
        &quot;main&quot;: &quot;index.js&quot;,
        &quot;scripts&quot;: &#123;
            &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
        &#125;,
        &quot;keywords&quot;: [],
        &quot;author&quot;: &quot;&quot;,
        &quot;license&quot;: &quot;ISC&quot;,
        &quot;dependencies&quot;: &#123;
            &quot;@babel/preset-env&quot;: &quot;^7.16.11&quot;,
            &quot;babel-core&quot;: &quot;^6.26.3&quot;,
            &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,
            &quot;babel-traverse&quot;: &quot;^6.26.0&quot;,
            &quot;babylon&quot;: &quot;^6.18.0&quot;
        &#125;
    &#125;
</code></pre>
<h5 id="src-index-js"><a href="#src-index-js" class="headerlink" title="src/index.js"></a>src/index.js</h5><pre><code>    import &#123; greeting &#125; from &#39;./greeting.js&#39;
    import &#123;hh&#125; from &#39;./hh.js&#39;
    const a = greeting(&#39;baishu&#39;)
    const b = hh()
    document.write(`$&#123;a&#125; $&#123;b&#125;`)
</code></pre>
<h5 id="src-greeting-js"><a href="#src-greeting-js" class="headerlink" title="src/greeting.js"></a>src/greeting.js</h5><pre><code>    export function greeting(name)&#123;
        return &#39;hello &#39; + name
    &#125;
</code></pre>
<h5 id="src-hh-js"><a href="#src-hh-js" class="headerlink" title="src/hh.js"></a>src/hh.js</h5><pre><code>    export function hh () &#123;
        return &#39;hai webpack&#39;
    &#125;
</code></pre>
<h5 id="lib-index-js"><a href="#lib-index-js" class="headerlink" title="lib/index.js"></a>lib/index.js</h5><pre><code>    const Compiler = require(&#39;./compiler.js&#39;)
    const options = require(&#39;../simplepack.config&#39;)
    new Compiler(options).run();
</code></pre>
<h5 id="simplepack-config-js"><a href="#simplepack-config-js" class="headerlink" title="simplepack.config.js"></a>simplepack.config.js</h5><pre><code>&#39;use strict&#39;;

const path = require(&#39;path&#39;)

module.exports = &#123;
    entry: path.join(__dirname,&#39;./src/index.js&#39;),
    output:&#123;
        path: path.join(__dirname,&#39;./dist&#39;),
        filename:&#39;main.js&#39;
    &#125;
&#125;
</code></pre>
<h5 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h5><pre><code>&#123;
    &quot;presets&quot;: [
        &quot;@babel/preset-env&quot;
    ]
&#125;
</code></pre>
<h5 id="dist-index-html"><a href="#dist-index-html" class="headerlink" title="dist/index.html"></a>dist/index.html</h5><pre><code>    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
        &lt;title&gt;Document&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;./main.js&quot;&gt;&lt;/script&gt;
    &lt;/body&gt;
    &lt;/html&gt;
</code></pre>
<h5 id="lib-compiler-js"><a href="#lib-compiler-js" class="headerlink" title="lib/compiler.js"></a>lib/compiler.js</h5><pre><code>    const fs = require(&#39;fs&#39;)
    const &#123; getAST, getDependencies, transform &#125; = require(&#39;./parser&#39;)
    const path = require(&#39;path&#39;)
    module.exports = class Compiler &#123;
        constructor(options)&#123;
            const &#123; entry, output &#125; = options
            this.entry = entry
            this.output = output
            this.modules = []
        &#125;

        run()&#123;
            const entryModule = this.buildModule(this.entry,true)
            this.modules.push(entryModule)
            this.modules.map((_module)=&gt;&#123;
                _module.dependencies.map((dependency) =&gt; &#123;
                    this.modules.push(this.buildModule(dependency))
                &#125;)
            &#125;)
            this.emitFiles()
        &#125;

        buildModule(filename, isEntry)&#123;
            let ast
            if(isEntry)&#123;
                ast = getAST(filename)
            &#125;else&#123;
                let absolutePath = path.join(process.cwd(), &#39;./src&#39;, filename);
                ast = getAST(absolutePath)
            &#125;

            return &#123;
                filename,
                dependencies: getDependencies(ast),
                source:transform(ast)
            &#125;

        &#125;

        // 输出内容输出到哪里
        emitFiles()&#123;
            const outputPath = path.join(this.output.path, this.output.filename)
            let modules = &#39;&#39;;
            this.modules.map((_module) =&gt; &#123;
                modules += `&#39;$&#123; _module.filename &#125;&#39;: function (require, module, exports) &#123; $&#123; _module.source &#125; &#125;,`
            &#125;);
            
            const bundle = `
                (function(modules) &#123;
                    function require(fileName) &#123;
                        const fn = modules[fileName];
            
                        const module = &#123; exports : &#123;&#125; &#125;;
            
                        fn(require, module, module.exports);
            
                        return module.exports;
                    &#125;

                    require(&#39;$&#123;this.entry&#125;&#39;);
                &#125;)(&#123;$&#123;modules&#125;&#125;)
            `;
            // console.log(bundle,&#39;bundle&#39;)
        
            fs.writeFileSync(outputPath,bundle,&#39;utf-8&#39;)
        &#125;
    &#125;
</code></pre>
<h5 id="lib-parser-js"><a href="#lib-parser-js" class="headerlink" title="lib/parser.js"></a>lib/parser.js</h5><pre><code>    const fs = require(&#39;fs&#39;)
    const babylon = require(&#39;babylon&#39;)
    const traverse = require(&#39;babel-traverse&#39;).default
    const &#123; transformFromAst &#125; = require(&#39;babel-core&#39;)
    module.exports = &#123;
        getAST:(path) =&gt; &#123;
            const source = fs.readFileSync(path,&#39;utf-8&#39;)

            return babylon.parse(source,&#123;
                sourceType:&#39;module&#39;
            &#125;)
        &#125;,

        getDependencies:(ast) =&gt; &#123;
            const dependencies = []
            traverse(ast,&#123;
                ImportDeclaration: (&#123; node &#125;)=&gt;&#123;
                    dependencies.push(node.source.value)
                &#125;
            &#125;)

            return dependencies
        &#125;,

        transform:(ast) =&gt; &#123;
            const &#123;code&#125; = transformFromAst(ast,null,&#123;
                presets:[&#39;env&#39;]
            &#125;)
            return code
        &#125;
    &#125;
</code></pre>
<h5 id="lib-test-js"><a href="#lib-test-js" class="headerlink" title="lib/test.js"></a>lib/test.js</h5><pre><code>    const &#123; getAST, getDependencies, transform &#125; = require(&#39;./parser&#39;)
    const path = require(&#39;path&#39;)

    const ast = getAST(path.join(__dirname,&#39;../src/index.js&#39;))
    const dependences = getDependencies(ast)

    if(process.argv[2] === &#39;ast&#39;)&#123;
        console.log(ast)
        return
    &#125;
    if(process.argv[2] === &#39;source&#39;)&#123;
        const source = transform(ast)
        console.log(source)
        return
    &#125;
    if(process.argv[2] === &#39;d&#39;)&#123;
        const dependences = getDependencies(ast)
        console.log(dependences)
        return
    &#125;
</code></pre>
<ul>
<li>测试parser功能， node lib/test.js d</li>
</ul>
<h5 id="浏览器中运行"><a href="#浏览器中运行" class="headerlink" title="浏览器中运行"></a>浏览器中运行</h5><p><img src="/images/webpack/html.png" alt="html" loading="lazy"></p>
]]></content>
      <categories>
        <category>前端构建</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的Loader配置</title>
    <url>/2022/03/17/webpack/loader/</url>
    <content><![CDATA[<h4 id="一个最简单的-loader-代码结构"><a href="#一个最简单的-loader-代码结构" class="headerlink" title="一个最简单的 loader 代码结构"></a>一个最简单的 loader 代码结构</h4><blockquote>
<p>定义：loader 只是一个导出为函数的 JavaScript 模块</p>
</blockquote>
<pre><code>    module.exports = function(source) &#123; return source; &#125;;
</code></pre>
<h4 id="多-Loader-时的执行顺序"><a href="#多-Loader-时的执行顺序" class="headerlink" title="多 Loader 时的执行顺序"></a>多 Loader 时的执行顺序</h4><blockquote>
<p>多个 Loader 串行执行, 顺序从后到前</p>
</blockquote>
<pre><code>    module.exports = &#123; 
        entry: &#39;./src/index.js&#39;, 
        output: &#123; 
            filename: &#39;bundle.js&#39;, 
            path: path.resolve(__dirname, &#39;dist&#39;) &#125;, 
            module: &#123; 
                rules: [ 
                        &#123; 
                            test: /\.less$/, 
                            use: [ 
                                &#39;style-loader&#39;, 
                                &#39;css-loader&#39;, 
                                &#39; less-loader&#39;
                                ]
                            &#125; 
                        ] 
                    &#125; 
        &#125;;
</code></pre>
<h4 id="函数组合的两种情况"><a href="#函数组合的两种情况" class="headerlink" title="函数组合的两种情况"></a>函数组合的两种情况</h4><pre><code>1. Unix 中的 pipline
2. Compose(webpack采取的是这种)
    compose = (f, g) =&gt; (...args) =&gt; f(g(...args));
</code></pre>
<h4 id="验证loader-的执行顺序"><a href="#验证loader-的执行顺序" class="headerlink" title="验证loader 的执行顺序"></a>验证loader 的执行顺序</h4><pre><code>        a-loader.js: 
        module.exports = function(source) &#123; 
            console.log (&#39;loader a is executed&#39;); 
            return source; 
        &#125;;
        b-loader.js: 
        module.exports = function(source) &#123; 
            console.log (&#39;loader b is executed&#39;); 
            return source; 
        &#125;;
</code></pre>
<p><img src="/images/webpack/load_tree.png" alt="load_tree" loading="lazy"></p>
<h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h5><pre><code>    &#123;
        &quot;name&quot;: &quot;loader-order&quot;,
        &quot;version&quot;: &quot;1.0.0&quot;,
        &quot;description&quot;: &quot;&quot;,
        &quot;main&quot;: &quot;index.js&quot;,
        &quot;scripts&quot;: &#123;
            &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
            &quot;build&quot;: &quot;webpack&quot;
        &#125;,
        &quot;keywords&quot;: [],
        &quot;author&quot;: &quot;&quot;,
        &quot;license&quot;: &quot;ISC&quot;,
        &quot;devDependencies&quot;: &#123;
            &quot;loader-utils&quot;: &quot;^1.2.3&quot;,
            &quot;webpack&quot;: &quot;^4.39.1&quot;,
            &quot;webpack-cli&quot;: &quot;^3.3.6&quot;
        &#125;
    &#125;
</code></pre>
<h5 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h5><pre><code>const path = require(&#39;path&#39;);

module.exports = &#123;
    entry: &#39;./src/index.js&#39;,
    output: &#123;
        path: path.join(__dirname, &#39;dist&#39;),
        filename: &#39;main.js&#39;
    &#125;,
    module: &#123;
        rules: [
            &#123;
                test: /\.js$/,
                use: [
                    path.resolve(&#39;./loaders/a-loader&#39;),
                    path.resolve(&#39;./loaders/b-loader&#39;)
                ]
            &#125;
        ]
    &#125;
&#125;
</code></pre>
<h5 id="loaders-a-loader-js"><a href="#loaders-a-loader-js" class="headerlink" title="loaders/a-loader.js"></a>loaders/a-loader.js</h5><pre><code>const loaderUtils = require(&#39;loader-utils&#39;);

module.exports = function(source) &#123;
    console.log(&#39;Loader a is excuted!&#39;);

    const url = loaderUtils.interpolateName(this, &#39;[name].[ext]&#39;, source);

    console.log(url);
    this.emitFile(url, source);
    return source;
&#125;
</code></pre>
<h5 id="loaders-b-loader-js"><a href="#loaders-b-loader-js" class="headerlink" title="loaders/b-loader.js"></a>loaders/b-loader.js</h5><pre><code>module.exports = function(source) &#123;
    console.log(&#39;Loader b is excuted!&#39;);
    return source;
&#125;
</code></pre>
<h5 id="src-index-js"><a href="#src-index-js" class="headerlink" title="src/index.js"></a>src/index.js</h5><pre><code>const a = 1;
</code></pre>
<h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><p><img src="/images/webpack/loader_order.png" alt="loader_order" loading="lazy"></p>
<h4 id="loader-runner"><a href="#loader-runner" class="headerlink" title="loader-runner"></a>loader-runner</h4><h5 id="loader-runner-的介绍"><a href="#loader-runner-的介绍" class="headerlink" title="loader-runner 的介绍"></a>loader-runner 的介绍</h5><blockquote>
<p>定义：loader-runner 允许你在不安装 webpack 的情况下运行 loaders</p>
</blockquote>
<pre><code>    作用：
        1.作为 webpack 的依赖，webpack 中使用它执行 loader
        2.进行 loader 的开发和调试
</code></pre>
<h5 id="loader-runner-的使用"><a href="#loader-runner-的使用" class="headerlink" title="loader-runner 的使用"></a>loader-runner 的使用</h5><pre><code>    import &#123; runLoaders &#125; from &quot;loader-runner&quot;; 

    runLoaders(&#123; 
        resource: &quot;/abs/path/to/file.txt?query&quot;, // String: 资源的绝对路径(可以增加查询字符串) 
        loaders: [&quot;/abs/path/to/loader.js?query&quot;], // String[]: loader 的绝对路径(可以增加查询字符串) 
        context: &#123; minimize: true &#125;, // 基础上下文之外的额外 loader 上下文 
        readResource: fs.readFile.bind(fs) // 读取资源的函数 
    &#125;, function(err, result) &#123; 
        // err: Error? 
        // result.result: Buffer | String 
    &#125;)
</code></pre>
<h4 id="开发一个raw-loader"><a href="#开发一个raw-loader" class="headerlink" title="开发一个raw-loader"></a>开发一个raw-loader</h4><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p><img src="/images/webpack/raw_loader.png" alt="raw_loader" loading="lazy"></p>
<h5 id="run-loader-js"><a href="#run-loader-js" class="headerlink" title="run-loader.js"></a>run-loader.js</h5><pre><code>    const &#123; runLoaders &#125; = require(&#39;loader-runner&#39;);
    const fs = require(&#39;fs&#39;);
    const path = require(&#39;path&#39;);

    runLoaders(&#123;
        resource: path.join(__dirname, &#39;./src/demo.txt&#39;),
        loaders: [
            &#123;
                loader: path.join(__dirname, &#39;./src/raw-loader.js&#39;),
                options: &#123;
                    name: &#39;test&#39;
                &#125;
            &#125;
        ],
        context: &#123;
            emitFile: () =&gt; &#123;&#125;
        &#125;,
        readResource: fs.readFile.bind(fs)
    &#125;, (err, result) =&gt; &#123;
        err ? console.log(err) : console.log(result);
    &#125;);
</code></pre>
<h5 id="package-json-1"><a href="#package-json-1" class="headerlink" title="package.json"></a>package.json</h5><pre><code>    &#123;
        &quot;name&quot;: &quot;raw-loader&quot;,
        &quot;version&quot;: &quot;1.0.0&quot;,
        &quot;description&quot;: &quot;&quot;,
        &quot;main&quot;: &quot;index.js&quot;,
        &quot;scripts&quot;: &#123;
            &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
        &#125;,
        &quot;keywords&quot;: [],
        &quot;author&quot;: &quot;&quot;,
        &quot;license&quot;: &quot;ISC&quot;,
        &quot;dependencies&quot;: &#123;
            &quot;loader-runner&quot;: &quot;^3.0.0&quot;
        &#125;,
        &quot;devDependencies&quot;: &#123;
            &quot;loader-utils&quot;: &quot;^1.2.3&quot;
        &#125;
    &#125;
</code></pre>
<h5 id="src-raw-loader-js"><a href="#src-raw-loader-js" class="headerlink" title="src/raw-loader.js"></a>src/raw-loader.js</h5><pre><code>    const loaderUtils = require(&#39;loader-utils&#39;);
    const fs = require(&#39;fs&#39;);
    const path = require(&#39;path&#39;);

    module.exports = function(source) &#123;
        const &#123; name &#125; = loaderUtils.getOptions(this);

        const url = loaderUtils.interpolateName(this, &quot;[name].[ext]&quot;, &#123;
            source,
        &#125;);

        console.log(url);
        this.emitFile(path.join(__dirname, url), source);
        
        // this.cacheable(false);
        // const callback = this.async();
        // console.log(&#39;name&#39;, name);

        const json = JSON.stringify(source)
           // .replace(&#39;foo&#39;, &#39;baishu&#39;)
            .replace(/\u2028/g, &#39;\\u2028&#39;)
            .replace(/\u2029/g, &#39;\\u2029&#39;);

        // fs.readFile(path.join(__dirname, &#39;./async.txt&#39;), &#39;utf-8&#39;, (err, data) =&gt; &#123;
        //     if (err) &#123;
        //         callback(err, &#39;&#39;);
        //     &#125;
        //     callback(null, data);
        // &#125;);
        // 

        // throw new Error(&#39;Error&#39;);

        return `export default $&#123;json&#125;`;
        // this.callback(null, json, 2, 3, 4);

    &#125;
</code></pre>
<h5 id="src-async-txt"><a href="#src-async-txt" class="headerlink" title="src/async.txt"></a>src/async.txt</h5><pre><code>    async   
</code></pre>
<h5 id="src-demo-txt"><a href="#src-demo-txt" class="headerlink" title="src/demo.txt"></a>src/demo.txt</h5><pre><code>    foobar
</code></pre>
<h5 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h5><pre><code>    node run-loader.js
</code></pre>
<p><img src="/images/webpack/raw_loader_result.png" alt="raw_loader" loading="lazy"></p>
<h4 id="loader的参数获取"><a href="#loader的参数获取" class="headerlink" title="loader的参数获取"></a>loader的参数获取</h4><pre><code>    通过 loader-utils 的 getOptions 方法获取

    const loaderUtils = require(&quot;loader-utils&quot;); 
    module.exports = function(content) &#123; 
        const &#123; name &#125; = loaderUtils.getOptions(this); 
    &#125;;
</code></pre>
<h4 id="loader的异常处理"><a href="#loader的异常处理" class="headerlink" title="loader的异常处理"></a>loader的异常处理</h4><pre><code>    1.loader 内直接通过 throw 抛出
    2.通过 this.callback 传递错误 
    this.callback( 
        err: Error | null, 
        content: string | Buffer, 
        sourceMap?: SourceMap, 
        meta?: any );
</code></pre>
<h4 id="loader-的异步处理"><a href="#loader-的异步处理" class="headerlink" title="loader 的异步处理"></a>loader 的异步处理</h4><pre><code>    通过 this.async 来返回一个异步函数
    第一个参数是 Error，第二个参数是处理的结果
    示意代码：
    module.exports = function(input) &#123; 
        const callback = this.async(); 
        // No callback -&gt; return synchronous results 
        // if (callback) &#123; ... &#125; 
        callback(null, input + input); 
    &#125;;
</code></pre>
<h4 id="在-loader-中使用缓存"><a href="#在-loader-中使用缓存" class="headerlink" title="在 loader 中使用缓存"></a>在 loader 中使用缓存</h4><pre><code>    webpack 中默认开启 loader 缓存
    ·可以使用 this.cacheable(false) 关掉缓存

    缓存条件： loader 的结果在相同的输入下有确定的输出
    ·有依赖的 loader 无法使用缓存
</code></pre>
<h4 id="loader-如何进行文件输出？"><a href="#loader-如何进行文件输出？" class="headerlink" title="loader 如何进行文件输出？"></a>loader 如何进行文件输出？</h4><pre><code>    通过 this.emitFile 进行文件写入
    const loaderUtils = require(&quot;loader-utils&quot;);
    module.exports = function(content) &#123; 
        const url = loaderUtils.interpolateName(this, &quot;[hash].[ext]&quot;, &#123; content, 
        &#125;); 
        this.emitFile(url, content); 
        const path = `__webpack_public_path__ + $&#123;JSON.stringify(url)&#125;;`; return `export default $&#123;path&#125;`; 
    &#125;;
</code></pre>
<h4 id="实战开发一个自动合成雪碧图的-loader"><a href="#实战开发一个自动合成雪碧图的-loader" class="headerlink" title="实战开发一个自动合成雪碧图的 loader"></a>实战开发一个自动合成雪碧图的 loader</h4><h5 id="支持的语法"><a href="#支持的语法" class="headerlink" title="支持的语法"></a>支持的语法</h5><pre><code>    background: url(&#39;a.png?__sprite&#39;);
    background: url(&#39;b.png?__sprite&#39;); 
    -&gt; background: url(&#39;sprite.png&#39;);
</code></pre>
<h5 id="准备知识：如何将两张图片合成一张图片？"><a href="#准备知识：如何将两张图片合成一张图片？" class="headerlink" title="准备知识：如何将两张图片合成一张图片？"></a>准备知识：如何将两张图片合成一张图片？</h5><pre><code>    使用 spritesmith: https://www.npmjs.com/package/spritesmith
    spritesmith 使用示例 
    const sprites = [&#39;./images/1.jpg&#39;, &#39;./images/2.jpg&#39;]; 
    Spritesmith.run(&#123;src: sprites&#125;, function handleResult (err, result) &#123; 
        result.image; 
        result.coordinates; 
        result.properties; 
    &#125;);
</code></pre>
<h5 id="目录结构-1"><a href="#目录结构-1" class="headerlink" title="目录结构"></a>目录结构</h5><p><img src="/images/webpack/sprite-loader.png" alt="sprite-loader" loading="lazy"></p>
<h5 id="run-loader-js-1"><a href="#run-loader-js-1" class="headerlink" title="run-loader.js"></a>run-loader.js</h5><pre><code>    const &#123; runLoaders &#125; = require(&#39;loader-runner&#39;);
    const fs = require(&#39;fs&#39;);
    const path = require(&#39;path&#39;);

    runLoaders(&#123;
        resource: path.join(__dirname, &#39;./loaders/index.css&#39;),
        loaders: [path.resolve(__dirname, &#39;./loaders/sprite-loader.js&#39;)],
        readResource: fs.readFile.bind(fs)
    &#125;, (err, result) =&gt; &#123;
        err ? console.log(err) : console.log(result);
    &#125;);
</code></pre>
<h5 id="test-js"><a href="#test-js" class="headerlink" title="test.js"></a>test.js</h5><pre><code>    const Spritesmith = require(&#39;spritesmith&#39;)
    const fs = require(&#39;fs&#39;);
    const path = require(&#39;path&#39;);

    const sprites = [&#39;./loaders/images/1.jpg&#39;, &#39;./loaders/images/2.jpg&#39;]; 
    Spritesmith.run(&#123;src: sprites&#125;, (err, result)=&gt;&#123; 
        console.log(result.image)
        console.log(result.coordinates)
        console.log(result.properties)
        fs.writeFileSync(path.join(__dirname,&#39;dist/sprite.jpg&#39;),result.image)
    &#125;);
</code></pre>
<h5 id="package-json-2"><a href="#package-json-2" class="headerlink" title="package.json"></a>package.json</h5><pre><code>    &#123;
        &quot;name&quot;: &quot;raw-loader&quot;,
        &quot;version&quot;: &quot;1.0.0&quot;,
        &quot;description&quot;: &quot;&quot;,
        &quot;main&quot;: &quot;index.js&quot;,
        &quot;scripts&quot;: &#123;
            &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
        &#125;,
        &quot;keywords&quot;: [],
        &quot;author&quot;: &quot;&quot;,
        &quot;license&quot;: &quot;ISC&quot;,
        &quot;dependencies&quot;: &#123;
            &quot;loader-runner&quot;: &quot;^3.0.0&quot;,
            &quot;spritesmith&quot;: &quot;^3.4.0&quot;
        &#125;
    &#125;
</code></pre>
<h5 id="loaders-sprite-loader-js"><a href="#loaders-sprite-loader-js" class="headerlink" title="loaders/sprite-loader.js"></a>loaders/sprite-loader.js</h5><pre><code>    const Spritesmith = require(&#39;spritesmith&#39;)
    const fs = require(&#39;fs&#39;);
    const path = require(&#39;path&#39;);
    const loaderUtils = require(&#39;loader-utils&#39;);
    module.exports = function(source) &#123;
        const callback = this.async();
        const imgs = source.match(/url\((\S*)\?__sprite/g);
        const matchedImgs = [];

        for(let i = 0; i &lt; imgs.length; i++)&#123;
            const img = imgs[i].match(/url\((\S*)\?__sprite/)[1];
            matchedImgs.push(path.join(__dirname,img));
        &#125;

        Spritesmith.run(&#123;
            src: matchedImgs
        &#125;, (err, result)=&gt;&#123; 
            fs.writeFileSync(path.join(process.cwd(),&#39;dist/sprite.jpg&#39;),result.image)
            source = source.replace(/url\((\S*)\?__sprite/g,(match) =&gt; &#123;
                return `url(&quot;dist/sprite.jpg&quot;`
            &#125;)
            fs.writeFileSync(path.join(process.cwd(),&#39;dist/index.css&#39;),source)
            callback(null,source)
        &#125;);
    &#125;
</code></pre>
<h5 id="loaders-index-css"><a href="#loaders-index-css" class="headerlink" title="loaders/index.css"></a>loaders/index.css</h5><pre><code>    .img1&#123;
        background: url(./images/1.jpg?__sprite);
    &#125;
    .img2&#123;
        background: url(./images/2.jpg?__sprite);
    &#125;
</code></pre>
<h5 id="dist-index-css"><a href="#dist-index-css" class="headerlink" title="dist/index.css"></a>dist/index.css</h5><pre><code>    .img1&#123;
        background: url(&quot;dist/sprite.jpg&quot;);
    &#125;
    .img2&#123;
        background: url(&quot;dist/sprite.jpg&quot;);
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>前端构建</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack打包库和组件</title>
    <url>/2022/03/14/webpack/pack/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><pre><code>    webpack 除了可以用来打包应用，也可以用来打包js库
</code></pre>
<h4 id="加法库打包"><a href="#加法库打包" class="headerlink" title="加法库打包"></a>加法库打包</h4><h5 id="目标：实现一个大整数加法库的打包"><a href="#目标：实现一个大整数加法库的打包" class="headerlink" title="目标：实现一个大整数加法库的打包"></a>目标：实现一个大整数加法库的打包</h5><pre><code>    1. 需要打包压缩版和非压缩版本
    2. 支持AMD/CJS/ESM 模块引用
</code></pre>
<h5 id="库的目录结构和打包要求"><a href="#库的目录结构和打包要求" class="headerlink" title="库的目录结构和打包要求"></a>库的目录结构和打包要求</h5><pre><code>    打包输出的库名称：
        未压缩版：large-number.js
        压缩版：large-number.min.js

            + |- /dist
            + |-- large-number.js
            + |-- large-number.min.j
            + |- webpack.config.js
            + |- package.json
            + |- index.js
            + |- /src
            + |-- index.js
</code></pre>
<h5 id="支持的使用方式⽀持-ES-module"><a href="#支持的使用方式⽀持-ES-module" class="headerlink" title="支持的使用方式⽀持 ES module"></a>支持的使用方式⽀持 ES module</h5><pre><code>    ⽀持 ES module
    import * as largeNumber from &#39;large-number&#39;;
    // ...
    largeNumber.add(&#39;999&#39;, &#39;1&#39;);

    ⽀持 CJS
    const largeNumbers = require(&#39;large-number&#39;);
    // ...
    largeNumber.add(&#39;999&#39;, &#39;1&#39;);

    ⽀持 AMD
    require([&#39;large-number&#39;], function (large-number) &#123;
    // ...
    largeNumber.add(&#39;999&#39;, &#39;1&#39;);
    &#125;);
</code></pre>
<h5 id="如何将库暴露出去"><a href="#如何将库暴露出去" class="headerlink" title="如何将库暴露出去"></a>如何将库暴露出去</h5><pre><code>    library: 指定库的全局变量
    libraryTarget: ⽀持库引⼊的⽅式

    module.exports = &#123;
        mode: &quot;production&quot;,
        entry: &#123;
        &quot;large-number&quot;: &quot;./src/index.js&quot;,
        &quot;large-number.min&quot;: &quot;./src/index.js&quot;
        &#125;,
        output: &#123;
        filename: &quot;[name].js&quot;,
        library: &quot;largeNumber&quot;,
        libraryExport: &quot;default&quot;,
        libraryTarget: &quot;umd&quot;
        &#125;
    &#125;;
</code></pre>
<h5 id="如何指对-min-压缩"><a href="#如何指对-min-压缩" class="headerlink" title="如何指对.min 压缩"></a>如何指对.min 压缩</h5><pre><code>    通过 include 设置只压缩 min.js 结尾的⽂件

    module.exports = &#123;
        mode: &quot;none&quot;,
        entry: &#123;
            &quot;large-number&quot;: &quot;./src/index.js&quot;,
            &quot;large-number.min&quot;: &quot;./src/index.js&quot;
        &#125;,
        output: &#123;
            filename: &quot;[name].js&quot;,
            library: &quot;largeNumber&quot;,
            libraryTarget: &quot;umd&quot;
        &#125;,
        optimization: &#123;
            minimize: true,
            minimizer: [
            new TerserPlugin(&#123;
            include: /\.min\.js$/,
             &#125;),
            ],
        &#125;
    &#125;;
</code></pre>
<h5 id="src-index-js"><a href="#src-index-js" class="headerlink" title="src - index.js"></a>src - index.js</h5><pre><code>    export default function add(a, b) &#123;
        let i = a.length - 1;
        let j = b.length - 1;

        let carry = 0;
        let ret = &#39;&#39;;
        while (i &gt;= 0 || j &gt;= 0) &#123;
            let x = 0;
            let y = 0;
            let sum;

            if (i &gt;= 0) &#123;
                x = a[i] - &#39;0&#39;;
                i --;
            &#125;

            if (j &gt;= 0) &#123;
                y = b[j] - &#39;0&#39;;
                j --;
            &#125;

            sum = x + y + carry;

            if (sum &gt;= 10) &#123;
                carry = 1;
                sum -= 10;
            &#125; else &#123;
                carry = 0;
            &#125;
            // 0 + &#39;&#39;
            ret = sum + ret;
        &#125;

        if (carry) &#123;
            ret = carry + ret;
        &#125;

        return ret;
    &#125;

    // add(&#39;999&#39;, &#39;1&#39;);
    // add(&#39;1&#39;, &#39;999&#39;);
    // add(&#39;123&#39;, &#39;321&#39;);
</code></pre>
<h5 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h5><pre><code>    const TerserPlugin = require(&#39;terser-webpack-plugin&#39;);

    module.exports = &#123;
        entry: &#123;
            &#39;large-number&#39;: &#39;./src/index.js&#39;,
            &#39;large-number.min&#39;: &#39;./src/index.js&#39;
        &#125;,
        output: &#123;
            filename: &#39;[name].js&#39;,
            library: &#39;largeNumber&#39;,
            libraryTarget: &#39;umd&#39;,
            libraryExport: &#39;default&#39;
        &#125;,
        mode: &#39;none&#39;,
        optimization: &#123;
            minimize: true,
            minimizer: [
                new TerserPlugin(&#123;
                    include: /\.min\.js$/,
                &#125;)
            ]
        &#125;
        
    &#125;
</code></pre>
<h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h5><pre><code>    &#123;
        &quot;name&quot;: &quot;large-number&quot;,
        &quot;version&quot;: &quot;1.0.1&quot;,
        &quot;description&quot;: &quot;加法打包&quot;,
        &quot;main&quot;: &quot;index.js&quot;,
        &quot;scripts&quot;: &#123;
            &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
            &quot;build&quot;: &quot;webpack&quot;,
            &quot;prepublish&quot;: &quot;webpack&quot;
        &#125;,
        &quot;keywords&quot;: [],
        &quot;author&quot;: &quot;&quot;,
        &quot;license&quot;: &quot;ISC&quot;,
        &quot;devDependencies&quot;: &#123;
            &quot;terser-webpack-plugin&quot;: &quot;^1.3.0&quot;,
            &quot;webpack&quot;: &quot;^4.34.0&quot;,
            &quot;webpack-cli&quot;: &quot;^3.3.4&quot;
        &#125;
    &#125;
</code></pre>
<h5 id="设置入口文件-index-js"><a href="#设置入口文件-index-js" class="headerlink" title="设置入口文件 index.js"></a>设置入口文件 index.js</h5><pre><code>    package.json 的 main 字段为 index.js

    index.js: 
        if (process.env.NODE_ENV === &#39;production&#39;) &#123;
            module.exports = require(&#39;./dist/large-number.min.js&#39;);
        &#125; else &#123;
            module.exports = require(&#39;./dist/large-number.js&#39;);
        &#125;
</code></pre>
]]></content>
      <categories>
        <category>前端构建</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack的Plugin配置</title>
    <url>/2022/03/17/webpack/plugin/</url>
    <content><![CDATA[<h4 id="插件的运行环境"><a href="#插件的运行环境" class="headerlink" title="插件的运行环境"></a>插件的运行环境</h4><pre><code>  插件没有像 loader 那样的独立运行环境
  只能在 webpack 里面运行
</code></pre>
<h4 id="插件的基本结构"><a href="#插件的基本结构" class="headerlink" title="插件的基本结构"></a>插件的基本结构</h4><pre><code>  基本结构：
  // 插件名称
  class MyPlugin &#123;
    // 插件上的apply方法                                                    
    apply(compiler) &#123; 
      // 插件的hooks
      compiler.hooks.done.tap(&#39; My Plugin&#39;, ( 
        stats /* stats is passed as argument when done hook is tapped. */ 
        ) =&gt; &#123; 
          // 插件处理逻辑
          console.log(&#39;Hello World!&#39;);
        &#125;); 
    &#125; 
  &#125;
  module.exports = MyPlugin;

  插件使用：
  plugins: [ new MyPlugin() ]
</code></pre>
<h4 id="搭建插件运行环境"><a href="#搭建插件运行环境" class="headerlink" title="搭建插件运行环境"></a>搭建插件运行环境</h4><pre><code>  const path = require(&quot;path&quot;); 
  const DemoPlugin = require(&quot;./plugins/demo-plugin.js&quot;); 
  const PATHS = &#123; 
    lib: path.join(__dirname, &quot;app&quot;, &quot;shake.js&quot;), 
    build: path.join(__dirname, &quot;build&quot;), 
    &#125;;
  module.exports = &#123; 
    entry: &#123; lib: PATHS.lib, &#125;,
    output: &#123; path: PATHS.build, 
    filename: &quot;[name].js&quot;, &#125;,
    plugins: [new DemoPlugin()], 
  &#125;;
</code></pre>
<h4 id="一个简单插件"><a href="#一个简单插件" class="headerlink" title="一个简单插件"></a>一个简单插件</h4><pre><code>  src/demo-plugin.js
  module.exports = class DemoPlugin &#123; 
    constructor(options) &#123; 
      this.options = options; 
    &#125;
    apply() &#123; 
      console.log(&quot;apply&quot;, this.options); 
    &#125;
  &#125;;

  加入到 webpack 配置中
  module.exports = &#123;
    ...
    plugins: [new DemoPlugin(&#123; name: &quot;demo&quot; &#125;)] 
  &#125;
</code></pre>
<h4 id="插件中如何获取传递的参数？"><a href="#插件中如何获取传递的参数？" class="headerlink" title="插件中如何获取传递的参数？"></a>插件中如何获取传递的参数？</h4><pre><code>  通过插件的构造函数进行获取
  module.exports = class MyPlugin &#123; 
    constructor(options) &#123; 
      this.options = options; 
    &#125;
    apply() &#123; 
      console.log(&quot;apply&quot;, this.options); 
    &#125; 
  &#125;;
</code></pre>
<h4 id="插件的错误处理"><a href="#插件的错误处理" class="headerlink" title="插件的错误处理"></a>插件的错误处理</h4><pre><code>  1.参数校验阶段可以直接 throw 的方式抛出
      throw new Error(“ Error Message”)
  2.通过 compilation 对象的 warnings 和 errors 接收
      compilation.warnings.push(&quot;warning&quot;);
      compilation.errors.push(&quot;error&quot;);
</code></pre>
<h4 id="通过-Compilation-进行文件写入"><a href="#通过-Compilation-进行文件写入" class="headerlink" title="通过 Compilation 进行文件写入"></a>通过 Compilation 进行文件写入</h4><pre><code>  Compilation 上的 assets 可以用于文件写入
  ·可以将 zip 资源包设置到 compilation.assets 对象上

  文件写入需要使用 webpack-sources：https://www.npmjs.com/package/webpack-sources

  const &#123; RawSource &#125; = require(&quot;webpack-sources&quot;); 
  module.exports = class DemoPlugin &#123; 
    constructor(options) &#123; 
      this.options = options; 
    &#125;
    apply(compiler) &#123; 
      const &#123; name &#125; = this.options; 
      compiler.hooks.emit.tap(&#39;DemoPlugin&#39;, ( 
        stats /* stats is passed as argument when done hook is tapped. */ 
        ) =&gt; &#123; 
          // 插件处理逻辑
          compilation.assets[name] = new RawSource(&quot;demo&quot;); cb(); 
        &#125;); 
    &#125; 
  &#125;
</code></pre>
<h4 id="插件扩展：编写插件的插件"><a href="#插件扩展：编写插件的插件" class="headerlink" title="插件扩展：编写插件的插件"></a>插件扩展：编写插件的插件</h4><pre><code>    插件自身也可以通过暴露 hooks 的方式进行自身扩展，以 html- webpack-plugin 为例：
    ·html-webpack-plugin-alter-chunks (Sync)
    ·html-webpack-plugin-before-html-generation (Async)
    ·html-webpack-plugin-alter-asset-tags (Async)
    ·html-webpack-plugin-after-html-processing (Async)
    ·html-webpack-plugin-after-emit (Async)
</code></pre>
<h4 id="编写一个压缩构建资源为zip包的插件"><a href="#编写一个压缩构建资源为zip包的插件" class="headerlink" title="编写一个压缩构建资源为zip包的插件"></a>编写一个压缩构建资源为zip包的插件</h4><pre><code>    要求： 
    ·生成的 zip 包文件名称可以通过插件传入
    ·需要使用 compiler 对象上的特地 hooks 进行资源的生成
</code></pre>
<h5 id="Node-js-里面将文件压缩为-zip-包"><a href="#Node-js-里面将文件压缩为-zip-包" class="headerlink" title="Node.js 里面将文件压缩为 zip 包"></a>Node.js 里面将文件压缩为 zip 包</h5><pre><code>    jszip: https://www.npmjs.com/package/jszip

    jszip 使用示例

    var zip = new JSZip();
    zip.file(&quot;Hello.txt&quot;, &quot;Hello World\n&quot;);
    var img = zip.folder(&quot;images&quot;);
    img.file(&quot;smile.gif&quot;, imgData, &#123;base64: true&#125;);
    zip.generateAsync(&#123;type:&quot;blob&quot;&#125;).then(function(content) &#123;
      // see FileSaver.js 
      saveAs(content, &quot;example.zip&quot;);
    &#125;);
</code></pre>
<h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p><img src="/images/webpack/zip_plugin.png" alt="zip_plugin" loading="lazy"></p>
<h5 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h5><pre><code>  const path = require(&#39;path&#39;);
  const ZipPlugin = require(&#39;./plugins/zip-plugin&#39;);

  module.exports = &#123;
      entry: &#39;./src/index.js&#39;,
      output: &#123;
          path: path.join(__dirname, &#39;dist&#39;),
          filename: &#39;main.js&#39;
      &#125;,
      mode: &#39;production&#39;,
      plugins: [
          new ZipPlugin(&#123;
              filename: &#39;offline&#39;
          &#125;)
      ]
  &#125;
</code></pre>
<h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h5><pre><code>  &#123;
    &quot;name&quot;: &quot;loader-order&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;description&quot;: &quot;&quot;,
    &quot;main&quot;: &quot;index.js&quot;,
    &quot;scripts&quot;: &#123;
      &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
      &quot;build&quot;: &quot;webpack&quot;
    &#125;,
    &quot;keywords&quot;: [],
    &quot;author&quot;: &quot;&quot;,
    &quot;license&quot;: &quot;ISC&quot;,
    &quot;devDependencies&quot;: &#123;
      &quot;loader-utils&quot;: &quot;^1.2.3&quot;,
      &quot;webpack&quot;: &quot;^4.39.1&quot;,
      &quot;webpack-cli&quot;: &quot;^3.3.6&quot;,
      &quot;yazl&quot;: &quot;^2.5.1&quot;
    &#125;,
    &quot;dependencies&quot;: &#123;
      &quot;jszip&quot;: &quot;^3.2.2&quot;
    &#125;
  &#125;
</code></pre>
<h5 id="plugins-zip-plugin-js"><a href="#plugins-zip-plugin-js" class="headerlink" title="plugins/zip-plugin.js"></a>plugins/zip-plugin.js</h5><pre><code>  const JSZip = require(&#39;jszip&#39;);
  const path = require(&#39;path&#39;);
  const RawSource = require(&#39;webpack-sources&#39;).RawSource;
  const zip = new JSZip();

  module.exports = class ZipPlugin &#123;
      constructor(options) &#123;
          this.options = options;
      &#125;

      apply(compiler) &#123;
          compiler.hooks.emit.tapAsync(&#39;ZipPlugin&#39;, (compilation, callback) =&gt; &#123;
              const folder = zip.folder(this.options.filename);

              for (let filename in compilation.assets) &#123;
                  const source = compilation.assets[filename].source();
                  folder.file(filename, source);
              &#125;

              zip.generateAsync(&#123;
                  type: &#39;nodebuffer&#39;
              &#125;).then((content) =&gt; &#123;
                  const outputPath = path.join(
                      compilation.options.output.path, 
                      this.options.filename + &#39;.zip&#39;
                  );

                  const outputRelativePath = path.relative(
                      compilation.options.output.path,
                      outputPath
                  );
                  compilation.assets[outputRelativePath] = new RawSource(content);

                  callback();
              &#125;);
          &#125;);
      &#125;
  &#125;
</code></pre>
<h5 id="src-index-js"><a href="#src-index-js" class="headerlink" title="src/index.js"></a>src/index.js</h5><pre><code>  const a = 1;
</code></pre>
<h5 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h5><pre><code>  npm run build
</code></pre>
<p><img src="/images/webpack/zip_plugin_result.png" alt="zip_plugin_result" loading="lazy"></p>
]]></content>
      <categories>
        <category>前端构建</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>打包</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器如何持久化缓存大量数据 - IndexDB</title>
    <url>/2021/03/01/browser/indexdb/</url>
    <content><![CDATA[<h4 id="背景概述"><a href="#背景概述" class="headerlink" title="背景概述"></a>背景概述</h4><p>  这里所说的数据持久化是针对浏览器而言，也可简称为浏览器缓存。<br>  浏览器缓存是指浏览器端在本地保存数据进行快速读取以避免重复资源请求。<br>  现代浏览器主要有9种缓存机制：Http文件缓存、LocalStorage、SessionStorage、indexDB、Web SQL、Cookie、CacheStorage、Application Cache、Flash缓存 - 《现代前端技术解析》</p>
<p>《现代前端技术解析》对应浏览器：<br><img src="/images/browser/browser_01.png" alt="browser_01" loading="lazy"><br>新浏览器：<br><img src="/images/browser/browser_02.png" alt="browser_02" loading="lazy"><br>最新版Chrome浏览器面板中 Application Cache 没有了，见下图解释，感兴趣的可自行查阅😊<br><img src="/images/browser/apply_discard.png" alt="apply_discard" loading="lazy"></p>
<h4 id="诉求-amp-哪种方式？"><a href="#诉求-amp-哪种方式？" class="headerlink" title="诉求&amp;哪种方式？"></a>诉求&amp;哪种方式？</h4><h5 id="诉求"><a href="#诉求" class="headerlink" title="诉求"></a>诉求</h5><p>  地图map api请求大量地理位置json，当然每次访问页面时请求也可，但这个不怎么变其实是没必要的，缓存在各个客户端本地即可，定期清除再获取新json存储。减少请求，减少费用，本地读取，这样不是大家都开心。</p>
<h5 id="哪种方式"><a href="#哪种方式" class="headerlink" title="哪种方式"></a>哪种方式</h5><p>  缓存资料上会建议用以下：</p>
<ul>
<li>For the network resources necessary to load your app and file-based content, use the <a href="https://web.dev/cache-api-quick-guide/">Cache Storage API</a><br>(part of service workers).</li>
<li>For other data, use <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB</a> (with a <a href="https://github.com/jakearchibald/idb">promises wrapper</a>).<br>那为啥不用LocalStorage、SessionStorage？可以参考 <a href="https://web.dev/storage-for-the-web/">storage-for-the-web</a> 或 阅读《现代前端技术解析》第1.2.3章节。</li>
</ul>
<h4 id="IndexDB"><a href="#IndexDB" class="headerlink" title="IndexDB"></a>IndexDB</h4><h5 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h5><p>  indexedDB是可以在浏览器端使用的本地数据库<br>  可以存储大量数据，提供接口来查询，还可以建立索引，这些都是其他存储方案 Cookie 或者 LocalStorage 无法提供的能力<br>  从数据库类型来看，IndexedDB 是一个非关系型数据库（不支持通过 SQL 语句操作）。</p>
<h5 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h5><p>  IndexedDB 是一个比较复杂的 API 组合，包括以下这些( IDB 指当前操作的数据库实例 )：</p>
<ol>
<li>数据库：IDBDatabase 对象</li>
</ol>
<ul>
<li>数据库是所有相关数据的基本容器。在同源策略（ 协议 + 域名 + 端口 ）的前提下，每个域名下可以新建任意多的数据库。IndexedDB 中有版本概念，这就规定了同一时刻下只有一个版本的数据库存在。</li>
</ul>
<ol start="2">
<li>仓库对象： IDBObjectStore 对象</li>
</ol>
<ul>
<li>对象仓库 ObjectStore 在 IndexedDB 中对应的是 MYSQL 中的表 Table。</li>
<li>对象仓库中记录的是若干条数据，数据只有主键和数据体两个部分，主键不能重复，可以为自增的整数编号或者数据中指定的一个属性。数据体可以是任意数据类型，不限于对象。</li>
</ul>
<ol start="3">
<li>索引：IDBIndex 对象</li>
</ol>
<ul>
<li>为不同的属性建立索引可以加快数据的检索。</li>
</ul>
<ol start="4">
<li>事务：IDBTransaction 对象</li>
</ol>
<ul>
<li>数据的 CURD (增删查改) 都要通过事务来完成。</li>
</ul>
<ol start="5">
<li>操作请求：IDBRequest 对象</li>
<li>指针：IDBCursor 对象</li>
<li>主键：IDBKeyRange 对象</li>
</ol>
<h5 id="对比mysql"><a href="#对比mysql" class="headerlink" title="对比mysql"></a>对比mysql</h5><p><img src="/images/browser/indexdb_database.png" alt="apply_discard" loading="lazy"></p>
<h5 id="实操特性总结"><a href="#实操特性总结" class="headerlink" title="实操特性总结"></a>实操特性总结</h5><ol>
<li>key-value 的储存形式，透过索引功能来高效率搜寻资料</li>
<li>同源政策 same-origin policy：只能取用同网域下的资料</li>
<li>Async API : 提供异步 api，单线程的应用下取用资源时就不会有 block the main thread 的情况造成使用者体验不佳</li>
<li>transaction : 能够确保大量写入资源时的完整性，如果有单一资源写入失败可全数 rollback<h5 id="设备兼容性"><a href="#设备兼容性" class="headerlink" title="设备兼容性"></a>设备兼容性</h5></li>
</ol>
<p>兼容性查询：<a href="https://caniuse.com/indexeddb">https://caniuse.com/indexeddb</a></p>
<h5 id="存储容量"><a href="#存储容量" class="headerlink" title="存储容量"></a>存储容量</h5><p>  单一资源库项目的容量/大小并没有任何限制，但是各个 IndexedDB资源库的容量就有限制，且根据各浏览器其限制会不同。</p>
<ul>
<li><code>Chrome</code> allows the browser to use up to 60% of total disk space. You can use the StorageManager API to determine the maximum quota available. Other Chromium-based browsers may allow the browser to use more storage.</li>
<li><code>Internet Explorer 10 and later</code> can store up to 250MB and will prompt the user when more than 10MB has been used.</li>
<li><code>Firefox </code>allows an origin to use up to 2GB. You can use the StorageManager API to determine how much space is still available.</li>
<li><code>Safari (both desktop and mobile)</code> appears to allow up to 1GB. When the limit is reached, Safari will prompt the user, increasing the limit in 200MB increments. I was unable to find any official documentation on this.<br>可参考 <a href="https://web.dev/storage-for-the-web/">storage-for-the-web</a><h5 id="存储资源键-Key"><a href="#存储资源键-Key" class="headerlink" title="存储资源键(Key)"></a>存储资源键(Key)</h5></li>
</ul>
<ol>
<li>data type: string, date, float和 array</li>
<li>必须是能排序的值(无法处理多国语言字串排序)</li>
<li>资源存储三种方式产生资源存储键: 键产生器 (key generator)、键路径 (key path) 以及指定值。</li>
</ol>
<ul>
<li>键产生器 (key generator)： 用产生器自动产生键</li>
<li>键路径 (key path)：空字串或是javascript identifier（包含用 “.” 分隔符号的名称）且路径不能有空白</li>
</ul>
<h5 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h5><p>参考<a href="https://wangdoc.com/javascript/bom/indexeddb.html#indexeddb-%E5%AF%B9%E8%B1%A1">IndexedDB API</a></p>
<h6 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h6><p>IndexedDB使用第一步：打开数据库。<br>方法：indexedDB.open()</p>
<pre><code>  var request = window.indexedDB.open(databaseName, version);
</code></pre>
<p>这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为1。</p>
<p>indexedDB.open()方法返回一个 IDBRequest 对象。这个对象通过三种事件error、success、upgradeneeded，处理打开数据库的操作结果。</p>
<p>（1）error 事件<br>error事件表示打开数据库失败。</p>
<pre><code>    request.onerror = function (event) &#123;
      console.log(&#39;数据库打开报错&#39;);
    &#125;;
</code></pre>
<p>（2）success 事件<br>success事件表示成功打开数据库。</p>
<pre><code>  var db;

  request.onsuccess = function (event) &#123;
    db = request.result;
    console.log(&#39;数据库打开成功&#39;);
  &#125;;
</code></pre>
<p>这时，通过request对象的result属性拿到数据库对象。</p>
<p>（3）upgradeneeded 事件<br>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件upgradeneeded。</p>
<pre><code>  var db;

  request.onupgradeneeded = function (event) &#123;
    db = event.target.result;
  &#125;
</code></pre>
<p>这时通过事件对象的target.result属性，拿到数据库实例。</p>
<h6 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h6><p>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在upgradeneeded事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。<br>通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</p>
<pre><code>  request.onupgradeneeded = function(event) &#123;
    db = event.target.result;
    var objectStore = db.createObjectStore(&#39;person&#39;, &#123; keyPath: &#39;id&#39; &#125;);
  &#125;
</code></pre>
<p>上面代码中，数据库新建成功以后，新增一张叫做person的表格，主键是id。<br>先判断一下，这张表格是否存在，如果不存在再新建。</p>
<pre><code>  request.onupgradeneeded = function (event) &#123;
    db = event.target.result;
    var objectStore;
    if (!db.objectStoreNames.contains(&#39;person&#39;)) &#123;
      objectStore = db.createObjectStore(&#39;person&#39;, &#123; keyPath: &#39;id&#39; &#125;);
    &#125;
  &#125;
</code></pre>
<p>主键（key）是默认建立索引的属性。比如，数据记录是{ id: 1, name: ‘张三’ }，那么id属性可以作为主键。主键也可以指定为下一层对象的属性，比如{ foo: { bar: ‘baz’ } }的foo.bar也可以指定为主键。<br>如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。</p>
<pre><code>  var objectStore = db.createObjectStore(
    &#39;person&#39;,
    &#123; autoIncrement: true &#125;
  );
</code></pre>
<p>上面代码中，指定主键为一个递增的整数。<br>新建对象仓库以后，下一步可以新建索引。</p>
<pre><code>  request.onupgradeneeded = function(event) &#123;
    db = event.target.result;
    var objectStore = db.createObjectStore(&#39;person&#39;, &#123; keyPath: &#39;id&#39; &#125;);
    objectStore.createIndex(&#39;name&#39;, &#39;name&#39;, &#123; unique: false &#125;);
    objectStore.createIndex(&#39;email&#39;, &#39;email&#39;, &#123; unique: true &#125;);
  &#125;
</code></pre>
<p>上面代码中，IDBObject.createIndex()的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。</p>
<h6 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h6><p>新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。</p>
<pre><code>  function add() &#123;
    var request = db.transaction([&#39;person&#39;], &#39;readwrite&#39;)
      .objectStore(&#39;person&#39;)
      .add(&#123; id: 1, name: &#39;张三&#39;, age: 24, email: &#39;zhangsan@example.com&#39; &#125;);

    request.onsuccess = function (event) &#123;
      console.log(&#39;数据写入成功&#39;);
    &#125;;

    request.onerror = function (event) &#123;
      console.log(&#39;数据写入失败&#39;);
    &#125;
  &#125;

  add();
</code></pre>
<p>上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（”只读”或”读写”）。新建事务以后，通过IDBTransaction.objectStore(name)方法，拿到 IDBObjectStore 对象，再通过表格对象的add()方法，向表格写入一条记录。</p>
<p>写入操作是一个异步操作，通过监听连接对象的success事件和error事件，了解是否写入成功。</p>
<h6 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h6><p>读取数据也是通过事务完成。</p>
<pre><code>  function read() &#123;
    var transaction = db.transaction([&#39;person&#39;]);
    var objectStore = transaction.objectStore(&#39;person&#39;);
    var request = objectStore.get(1);

    request.onerror = function(event) &#123;
      console.log(&#39;事务失败&#39;);
    &#125;;

    request.onsuccess = function( event) &#123;
        if (request.result) &#123;
          console.log(&#39;Name: &#39; + request.result.name);
          console.log(&#39;Age: &#39; + request.result.age);
          console.log(&#39;Email: &#39; + request.result.email);
        &#125; else &#123;
          console.log(&#39;未获得数据记录&#39;);
        &#125;
    &#125;;
  &#125;

  read();
</code></pre>
<p>上面代码中，objectStore.get()方法用于读取数据，参数是主键的值。</p>
<h6 id="遍历数据"><a href="#遍历数据" class="headerlink" title="遍历数据"></a>遍历数据</h6><p>遍历数据表格的所有记录，要使用指针对象 IDBCursor。</p>
<pre><code>function readAll() &#123;
  var objectStore = db.transaction(&#39;person&#39;).objectStore(&#39;person&#39;);

  objectStore.openCursor().onsuccess = function (event) &#123;
    var cursor = event.target.result;

    if (cursor) &#123;
      console.log(&#39;Id: &#39; + cursor.key);
      console.log(&#39;Name: &#39; + cursor.value.name);
      console.log(&#39;Age: &#39; + cursor.value.age);
      console.log(&#39;Email: &#39; + cursor.value.email);
      cursor.continue();
    &#125; else &#123;
      console.log(&#39;没有更多数据了！&#39;);
    &#125;
  &#125;;
&#125;

readAll();
</code></pre>
<p>上面代码中，新建指针对象的openCursor()方法是一个异步操作，所以要监听success事件。</p>
<h6 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h6><p>方法：IDBObject.put()</p>
<pre><code>function update() &#123;
  var request = db.transaction([&#39;person&#39;], &#39;readwrite&#39;)
    .objectStore(&#39;person&#39;)
    .put(&#123; id: 1, name: &#39;李四&#39;, age: 35, email: &#39;lisi@example.com&#39; &#125;);

  request.onsuccess = function (event) &#123;
    console.log(&#39;数据更新成功&#39;);
  &#125;;

  request.onerror = function (event) &#123;
    console.log(&#39;数据更新失败&#39;);
  &#125;
&#125;

update();
</code></pre>
<p>上面代码中，put()方法自动更新了主键为1的记录。</p>
<h6 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h6><p>方法：IDBObjectStore.delete()</p>
<pre><code>function remove() &#123;
  var request = db.transaction([&#39;person&#39;], &#39;readwrite&#39;)
    .objectStore(&#39;person&#39;)
    .delete(1);

  request.onsuccess = function (event) &#123;
    console.log(&#39;数据删除成功&#39;);
  &#125;;
&#125;

remove();
</code></pre>
<h6 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h6><p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。</p>
<p>假定新建表格的时候，对name字段建立了索引。</p>
<pre><code>objectStore.createIndex(&#39;name&#39;, &#39;name&#39;, &#123; unique: false &#125;);
</code></pre>
<p>现在，就可以从name找到对应的数据记录了。</p>
<pre><code>var transaction = db.transaction([&#39;person&#39;], &#39;readonly&#39;);
var store = transaction.objectStore(&#39;person&#39;);
var index = store.index(&#39;name&#39;);
var request = index.get(&#39;李四&#39;);

request.onsuccess = function (e) &#123;
  var result = e.target.result;
  if (result) &#123;
    // ...
  &#125; else &#123;
    // ...
  &#125;
&#125;
</code></pre>
<h5 id="idb"><a href="#idb" class="headerlink" title="idb"></a>idb</h5><p><a href="https://github.com/jakearchibald/idb#indexeddb-with-usability">idb</a><br>一个很小的（〜1.05k）库，主要反映了索引的DB API，对可用性有了很大的改进。<br><img src="/images/browser/idb_demo_.gif" alt="idb_demo_" loading="lazy"></p>
<h5 id="错误处理QuotaExceededError"><a href="#错误处理QuotaExceededError" class="headerlink" title="错误处理QuotaExceededError"></a>错误处理QuotaExceededError</h5><p>使用者浏览器的内存不足时会丢出 QuotaExceededError (DOMException) 的错误， 务必记得handle error避免使用者体验不好，并依照各自逻辑进行错误处理。<br>eg. 当transaction时出现错误会调用callback.onabort</p>
<pre><code>// 以上范例加上error handler
const transaction = db.transaction([&#39;person&#39;], &#39;readwrite&#39;);
transaction.onabort = function(event) &#123;
  const error = event.target.error; // DOMException
  if (error.name == &#39;QuotaExceededError&#39;) &#123;
    // Fallback code goes here
  &#125;
&#125;;
</code></pre>
<p><img src="/images/browser/quota_error.png" alt="idb_demo_" loading="lazy"></p>
<h5 id="浏览器清空indexDB"><a href="#浏览器清空indexDB" class="headerlink" title="浏览器清空indexDB"></a>浏览器清空indexDB</h5><blockquote>
<p>Web storage is categorized into two buckets, “Best Effort” and “Persistent”</p>
</blockquote>
<p>indexedDB 属于”Best Effort”(非常久性) 当浏览器空间不足时会开始清除非持久性资料 也就是eviction policy</p>
<ol>
<li>Chromium-based browsers: 当浏览器空间不足时，会开始从最少使用的data清除直到空间不再超出限制。</li>
<li>Internet Explorer 10+: 没有清除机制，但无法再写入新资料。</li>
<li>Firefox: 当硬盘空间不足时，会开始从最少使用的data清除直到空间不再超出限制。</li>
<li>Safari: 以前没有清除机制, 但现行有实施7日机制(当使用者七日没有使用safari时，将会清空资料)。</li>
</ol>
<p>如果是重要内容：<br>You can request <a href="https://web.dev/persistent-storage/">persistent storage</a> for your site to protect critical user or application data.</p>
<blockquote>
<p>persistent storage：除非是使用者自行清除，不然是能够避免浏览器的自动清除。</p>
</blockquote>
<p><a href="https://github.com/rt2zz/redux-persist">Redux Persist</a>：Persist and rehydrate a redux store.</p>
<p><img src="/images/browser/redux_persist.png" alt="idb_demo_" loading="lazy"></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>数据持久化</tag>
        <tag>IndexDB</tag>
      </tags>
  </entry>
  <entry>
    <title>webWorker简介及使用场景</title>
    <url>/2021/03/18/browser/webworker/</url>
    <content><![CDATA[<h4 id="背景简述"><a href="#背景简述" class="headerlink" title="背景简述"></a>背景简述</h4><p>JavaScript作为浏览器脚本语言，被定义为只有单线程的语言，也就是同一时间只能做同一事情。<br>当JS在页面中运行长耗时同步任务的时候就会导致页面假死影响用户体验，从而需要设置把任务放在任务队列中；执行任务队列中的任务也并非多线程进行的。<br>在HTML5中引入了webWorker的概念，为JavaScript引入了线程的概念，它允许开发人员编写能够长时间运行而不被用户所中断的后台程序，去执行事务或者逻辑，并同时保证页面对用户的响应。但是子线程完全受主线程控制，且不得修改DOM。所以一般情况下webWorker的主要用途是处理一些比较耗时的计算。</p>
<p><img src="/images/browser/webworker.png" alt="webworker" loading="lazy"></p>
<h4 id="webWorker注意点"><a href="#webWorker注意点" class="headerlink" title="webWorker注意点"></a>webWorker注意点</h4><ol>
<li>同源限制</li>
</ol>
<ul>
<li>worker线程执行的脚本文件必须和主线程的脚本文件同源，这是当然的了，总不能允许worker线程到别人电脑上到处读文件吧</li>
</ul>
<ol start="2">
<li>文件限制</li>
</ol>
<ul>
<li>为了安全，worker线程无法读取本地文件，它所加载的脚本必须来自网络，且需要与主线程的脚本同源</li>
</ul>
<ol start="3">
<li>DOM操作限制</li>
</ol>
<ul>
<li>worker线程在与主线程的window不同的另一个全局上下文中运行，其中无法读取主线程所在网页的DOM对象，也不能获取 document、window等对象，但是可以获取navigator、location(只读)、XMLHttpRequest、setTimeout族等浏览器API。</li>
</ul>
<ol start="4">
<li>通信限制</li>
</ol>
<ul>
<li>worker线程与主线程不在同一个上下文，不能直接通信，需要通过postMessage、onmessage方法来通信。</li>
</ul>
<ol start="5">
<li>脚本限制</li>
</ol>
<ul>
<li>worker线程不能执行alert、confirm，但可以使用 XMLHttpRequest 对象发出ajax请求。</li>
</ul>
<h5 id="Web-Workers-的可用功能"><a href="#Web-Workers-的可用功能" class="headerlink" title="Web Workers 的可用功能"></a>Web Workers 的可用功能</h5><p>由于 Web Workers 的多线程特性，它只能使用一部分 JavaScript 功能。以下是可使用的功能列表：</p>
<pre><code>1.navigator 对象
2.location 对象（只读）
3.XMLHttpRequest
4.setTimeout()/clearTimeout() 和 setInterval()/clearInterval()
5.Application Cache
6.使用 importScripts 来引用外部脚本
7.创建其它 web workers
</code></pre>
<h5 id="Web-Worker-的局限性"><a href="#Web-Worker-的局限性" class="headerlink" title="Web Worker 的局限性"></a>Web Worker 的局限性</h5><p>Web Workers 不能够访问一些非常关键的 JavaScript 功能：</p>
<pre><code>1.DOM（非线程安全的）
2.window 对象
3.document 对象
4.parent 对象
</code></pre>
<h4 id="常用api"><a href="#常用api" class="headerlink" title="常用api"></a>常用api</h4><p>详细的API参见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WorkerGlobalScope">MDN - WorkerGlobalScope</a></p>
<h5 id="postMessage-data"><a href="#postMessage-data" class="headerlink" title="postMessage(data)"></a>postMessage(data)</h5><p>子线程与主线程之间互相通信使用方法，传递的data为任意值。</p>
<pre><code>//worker = new Worker(&#39;url&#39;);
//worker.postMessage传递给子线程数据，对象
worker.postMessage(&#123;first:1,second:2&#125;);

//子线程中也可以使用postMessage，如传递字符串
postMessage(‘test’);
</code></pre>
<h5 id="terminate"><a href="#terminate" class="headerlink" title="terminate()"></a>terminate()</h5><p>主线程中终止worker，此后无法再利用其进行消息传递。注意：一旦terminate后，无法重新启用，只能另外创建。</p>
<pre><code>//worker = new Worker(&#39;url&#39;);
worker.terminate();
</code></pre>
<h5 id="message"><a href="#message" class="headerlink" title="message"></a>message</h5><p>当有消息发送时，触发该事件。且，消息发送是双向的，消息内容可通过data来获取。</p>
<pre><code>worker.onmessage = function(event)&#123;
    console.log(event.data);
&#125;;
</code></pre>
<h5 id="error"><a href="#error" class="headerlink" title="error"></a>error</h5><p>出错处理。且错误消息可以通过e.message来获取。</p>
<pre><code>//worker = new Worker(&#39;url&#39;);
worker.onerror = function(e)&#123;
    //打印出错消息
    console.log(e.message);
    //中断与子线程的联系
    worker.terminate();
&#125;

注：worker线程从上到下同步运行它的代码，然后进入异步阶段来对事件及计时器响应，如果worker注册了message事件处理程序，只要其有可能触发，worker就一直在内存中，不会退出，所以通信完毕后得手动在主线程中terminate或者子线程中close掉，但如果worker没有监听消息，那么当所有任务执行完毕（包括计数器）后，他就会退出。
</code></pre>
<h5 id="self"><a href="#self" class="headerlink" title="self"></a>self</h5><p>我们可以使用 WorkerGlobalScope 的 self 属性来或者这个对象本身的引用</p>
<h5 id="location"><a href="#location" class="headerlink" title="location"></a>location</h5><p>location 属性返回当线程被创建出来的时候与之关联的 WorkerLocation 对象，它表示用于初始化这个工作线程的脚步资源的绝对 URL，即使页面被多次重定向后，这个 URL 资源位置也不会改变。</p>
<h5 id="close"><a href="#close" class="headerlink" title="close"></a>close</h5><p>关闭当前线程，与terminate作用类似</p>
<h5 id="importScripts"><a href="#importScripts" class="headerlink" title="importScripts"></a>importScripts</h5><p>我们可以通过importScripts()方法通过url在worker中加载库函数</p>
<h5 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h5><p>发Ajax请求</p>
<h5 id="setTimeout-setInterval"><a href="#setTimeout-setInterval" class="headerlink" title="setTimeout/setInterval"></a>setTimeout/setInterval</h5><p>延时执行函数和定时执行函数，和window对象的方法相同。</p>
<h5 id="addEventListener-postMessage"><a href="#addEventListener-postMessage" class="headerlink" title="addEventListener/postMessage"></a>addEventListener/postMessage</h5><p>第一个为注册监听事件，和window对象的相同，不在赘述。postMessage上面也介绍过了，是主线程和子线程之间通信的方法。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><h6 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h6><p>浏览器原生提供Worker()构造函数，用来供主线程生成 Worker 线程。</p>
<pre><code>    var myWorker = new Worker(jsUrl, options);

    Worker()构造函数，可以接受两个参数。
    jsUrl：是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。
    options：是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。
</code></pre>
<p>Worker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker线程对象的属性和方法如下。</p>
<pre><code>    Worker.onerror：指定 error 事件的监听函数。
    Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在Event.data属性中。
    Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。
    Worker.postMessage()：向 Worker 线程发送消息。
    Worker.terminate()：立即终止 Worker 线程。
</code></pre>
<h6 id="Worker-线程"><a href="#Worker-线程" class="headerlink" title="Worker 线程"></a>Worker 线程</h6><p>Web Worker 有自己的全局对象，不是主线程的window，而是一个专门为 Worker 定制的全局对象。因此定义在window上面的对象和方法不是全部都可以使用。</p>
<pre><code>    self.name： Worker 的名字。该属性只读，由构造函数指定。
    self.onmessage：指定message事件的监听函数。
    self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。
    self.close()：关闭 Worker 线程。
    self.postMessage()：向产生这个 Worker 线程发送消息。
    self.importScripts()：加载 JS 脚本。
</code></pre>
<h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>index.html:</p>
<pre><code>    &lt;!DOCTYPE html&gt;
    &lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
        &lt;title&gt;test web worker&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;button onclick=&quot;startComputation()&quot;&gt;Start computation&lt;/button&gt;

    &lt;/body&gt;
    &lt;script&gt;
        function startComputation() &#123;
        var arr = new Array(20000000).fill(1)
        worker.postMessage(&#123;&#39;cmd&#39;: &#39;average&#39;, &#39;data&#39;: arr&#125;);
        &#125;
        var worker = new Worker(&#39;doWork.js&#39;);
        worker.addEventListener(&#39;message&#39;, function(e) &#123;
        console.log(e.data);
        &#125;, false);
    &lt;/script&gt;
    &lt;/html&gt;
</code></pre>
<p>doWork.js</p>
<pre><code>    self.addEventListener(&#39;message&#39;, async function(e) &#123;
        var data = e.data;
        switch (data.cmd) &#123;
        case &#39;average&#39;:
            var result = await calculateAverage(data.data); // 某个数值数组中计算平均值的函数
            self.postMessage(result);
            break;
        default:
            self.postMessage(&#39;Unknown command&#39;);
        &#125;
    &#125;, false)
    
    function calculateAverage(numbers) &#123;
        var len = numbers.length,
            sum = 0,
            i;

        if (len === 0) &#123;
            return 0;
        &#125; 
        
        for (i = 0; i &lt; len; i++) &#123;
            sum += numbers[i];
        &#125;
        return sum / len;
    &#125;
</code></pre>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p><a href="https://blog.sessionstack.com/how-javascript-works-the-building-blocks-of-web-workers-5-cases-when-you-should-use-them-a547c0757f6a">How JavaScript works: The building blocks of Web Workers + 5 cases when you should use them</a></p>
<blockquote>
<p>计算密集型或高延迟的任务可用web worker处理，避免主线程（UI）阻塞。</p>
</blockquote>
<h5 id="加密数据"><a href="#加密数据" class="headerlink" title="加密数据"></a>加密数据</h5><p>一些加解密的算法比较复杂，或者在加解密很多数据的时候，这会非常耗费计算资源，导致UI线程无响应，因此这是使用Web Worker的好时机，使用Worker线程可以让用户更加无缝的操作UI。</p>
<h5 id="预取数据"><a href="#预取数据" class="headerlink" title="预取数据"></a>预取数据</h5><p>有时候为了提升数据加载速度，可以提前使用Worker线程获取数据，因为Worker线程是可以是用 XMLHttpRequest 的。</p>
<h5 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h5><p>在某些渲染场景下，比如渲染复杂的canvas的时候需要计算的效果比如反射、折射、光影、材料等，这些计算的逻辑可以使用Worker线程来执行，也可以使用多个Worker线程。</p>
<h5 id="复杂数据处理场景"><a href="#复杂数据处理场景" class="headerlink" title="复杂数据处理场景"></a>复杂数据处理场景</h5><p>某些检索、排序、过滤、分析会非常耗费时间，这时可以使用Web Worker来进行，不占用主线程。</p>
<h5 id="预加载图片"><a href="#预加载图片" class="headerlink" title="预加载图片"></a>预加载图片</h5><p>有时候一个页面有很多图片，或者有几个很大的图片的时候，如果业务限制不考虑懒加载，也可以使用Web Worker来加载图片。</p>
<pre><code>注意：
虽然使用worker线程不会占用主线程，但是启动worker会比较耗费资源
主线程中使用XMLHttpRequest在请求过程中浏览器另开了一个异步http请求线程，但是交互过程中还是要消耗主线程资源
</code></pre>
<h5 id="实例：Worker-线程完成轮询"><a href="#实例：Worker-线程完成轮询" class="headerlink" title="实例：Worker 线程完成轮询"></a>实例：Worker 线程完成轮询</h5><p>浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。</p>
<pre><code>function createWorker(f) &#123;
var blob = new Blob([&#39;(&#39; + f.toString() +&#39;)()&#39;]);
var url = window.URL.createObjectURL(blob);
var worker = new Worker(url);
return worker;
&#125;

var pollingWorker = createWorker(function (e) &#123;
var cache;

function compare(new, old) &#123; ... &#125;;

setInterval(function () &#123;
    fetch(&#39;/my-api-endpoint&#39;).then(function (res) &#123;
    var data = res.json();

    if (!compare(data, cache)) &#123;
        cache = data;
        self.postMessage(data);
    &#125;
    &#125;)
&#125;, 1000)
&#125;);

pollingWorker.onmessage = function () &#123;
// render data
&#125;

pollingWorker.postMessage(&#39;init&#39;);
</code></pre>
<p>   好文推荐：<a href="https://blog.51cto.com/u_10887428/5148923">Web Worker</a></p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>数据持久化</tag>
        <tag>IndexDB</tag>
      </tags>
  </entry>
  <entry>
    <title>pm2部署</title>
    <url>/2021/03/15/devops/pm2/</url>
    <content><![CDATA[<h4 id="pm2简介"><a href="#pm2简介" class="headerlink" title="pm2简介"></a>pm2简介</h4><ul>
<li>pm2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等。</li>
<li>工作中遇到服务器重启后，需要一个个去重新启动每个服务，这样不仅繁琐、效率低，而且容易忘开启某些服务，那么使用pm2就可以解决这个问题。</li>
<li>通常说到PM2，都是在说如何部署nodejs程序，但是实际上PM2很强大，不仅可以用来管理Nodejs，它还可以用来管理Python、PHP、Ruby等</li>
</ul>
<h4 id="pm2安装和目录"><a href="#pm2安装和目录" class="headerlink" title="pm2安装和目录"></a>pm2安装和目录</h4><p>1、全局安装pm2</p>
<blockquote>
<p>npm install -g pm2</p>
</blockquote>
<p>2、安装完成之后，会自动创建以下目录</p>
 <div class="warning">

<pre><code>/.pm2/logs      // 包括所有应用的日志
/.pm2/pids      // 包括所有应用的 pids
/.pm2/dump.pm2  // 开机自启动配置
/.pm2/pm2.log   // pm2 日志
/.pm2/pm2.pid   // pm2 pid
</code></pre>
 </div>

<h4 id="启动Node（Express）"><a href="#启动Node（Express）" class="headerlink" title="启动Node（Express）"></a>启动Node（Express）</h4><blockquote>
<p>pm2 start ./bin/www –watch</p>
</blockquote>
<p> <img src="/images/devops/startnode.png" alt="dns查询" loading="lazy"></p>
<ul>
<li>–watch 参数，意味着当你的express应用代码发生变化时，pm2会帮你重启服务</li>
</ul>
<h4 id="启动Python"><a href="#启动Python" class="headerlink" title="启动Python"></a>启动Python</h4><ul>
<li>使用PM2启动应用非常简单，它将根据脚本扩展自动匹配解释器，用以运行指定的应用程序。<br>如下hello.py</li>
</ul>
 <div class="warning">

<pre><code>#!/usr/bin/python
import time

while 1:
    print(&quot;Start: %s&quot; % time.ctime())
    time.sleep(1)
</code></pre>
 </div>

<blockquote>
<p>pm2 start hello.py</p>
</blockquote>
<p>  <img src="/images/devops/startpy.png" alt="dns查询" loading="lazy"></p>
<div class="info">

<blockquote>
<p>到这一步，这个Python程序就将永远的运行下去，这意味着如果该进程退出或者抛出异常，它将被自动重启。<br>此处的mode为fork，当关闭当前的Terminal窗口，它依然可以检查到此应用的状态。<br>pm2 ls 命令可查看pm2运行管理</p>
</blockquote>
</div>

<h4 id="检查日志"><a href="#检查日志" class="headerlink" title="检查日志"></a>检查日志</h4><blockquote>
<p>pm2 logs</p>
</blockquote>
<ul>
<li><p>某个进程的log，可以使用</p>
<blockquote>
<p>pm2 logs <app_name></p>
</blockquote>
</li>
<li><p>自动化的日志轮换功能，需安装 pm2-logrotate</p>
<blockquote>
<p>pm2 install pm2-logrotate</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的使用</title>
    <url>/2019/06/02/redis/use/</url>
    <content><![CDATA[<h4 id="数据库应用的发展历程"><a href="#数据库应用的发展历程" class="headerlink" title="数据库应用的发展历程"></a>数据库应用的发展历程</h4><p>   单机数据库时代：一个应用，一个数据库实例<br>   缓存、水平切分时代：<br>   读写分离时代:<br>   分表分库时代(集群):</p>
<p>   关系型数据库：oracle、mysql、DB2、sqlserver、….[以表为单位存储]</p>
<p>   非关系型数据库(NoSql)： 彻底改变底层存储机制。不再采用关系数据模型[以表为单位存储]，而是采用聚合数据结构存储数据。<br>        redis、mongoDB、HBase、….</p>
<h5 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h5><p>Redis是一种数据库。能够存储数据、管理数据的一种软件。</p>
<h5 id="Nosql数据模型"><a href="#Nosql数据模型" class="headerlink" title="Nosql数据模型"></a>Nosql数据模型</h5><p>   关系型数据库：表<br>       tbl_student                            tbl_clazz<br>       id    name    age    clazz_id          id       name<br>       1001  zhangsan 20      111             111      clazz1<br>       1002  lisi     21      111             222      clazz2<br>   非关系型数据库：聚合模型—把一组相关联的数据作为一个整体进行存储和管理。<br>       BSON：数据保存到键值对中、数据和数据之间用逗号隔开，{}表示对象，[]表示数组。<br>       <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">    id:1001,</span><br><span class="line">    name:zhangsan,</span><br><span class="line">    age:20,</span><br><span class="line">    clazz:&#123;</span><br><span class="line">    id:111,</span><br><span class="line">    name:clazz1</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        id:1002,</span><br><span class="line">    name:lisi,</span><br><span class="line">    age:21,</span><br><span class="line">    clazz:&#123;</span><br><span class="line">    id:111,</span><br><span class="line">    name:clazz1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>     K-V键值对、列簇、图表模型等。
     Redis采用的是K-V模型存储数据的。
</code></pre>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><p>Redis是一个用C语言编写的、开源的、<font color="#f2711c">基于内存运行并支持持久化的</font>、高性能的NoSQL数据库.也是当前热门的NoSQL数据库之一。</p>
<blockquote>
<p>Redis中的数据大部分时间都是存储内存中的，适合存储频繁访问、数据量比较小的数据。缓存数据库</p>
</blockquote>
<h5 id="Redis的特点"><a href="#Redis的特点" class="headerlink" title="Redis的特点"></a>Redis的特点</h5><div>

<blockquote>
<p>1、支持数据持久化<br>    Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。<br>2、支持多种数据结构<br>    Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>3、支持数据备份<br>    Redis支持数据的备份，即master-slave模式的数据备份。</p>
</blockquote>
</div>

<h5 id="Linux上安装Redis"><a href="#Linux上安装Redis" class="headerlink" title="Linux上安装Redis"></a>Linux上安装Redis</h5><blockquote>
<p>step 1: 下载redis</p>
</blockquote>
<p>   wget <a href="https://download.redis.io/releases/redis-5.0.2.tar.gz">https://download.redis.io/releases/redis-5.0.2.tar.gz</a></p>
<blockquote>
<p>step 2: 解压redis-5.0.2tar.gz到/opt</p>
</blockquote>
<p>   tar -zxvf redis-5.0.2.gz -C /opt<br> <img src="/images/redis/redis_unzip.jpeg" alt="unzip" loading="lazy"></p>
<blockquote>
<p>step 3: 编译redis，进入解压目录，并且执行make命令：</p>
</blockquote>
<p> <img src="/images/redis/redis_make.jpeg" alt="make" loading="lazy"></p>
<p> 报错：gcc命令未找到</p>
<p> <img src="/images/redis/redis_gcc.jpeg" alt="gcc" loading="lazy"><br> 执行命令：yum -y install gcc。<br> 执行gcc –v查看Linux内核版本</p>
<blockquote>
<p>step 4: 安装make install</p>
</blockquote>
<p> <img src="/images/redis/redis_install.jpeg" alt="install" loading="lazy"></p>
<h5 id="启动redis服务"><a href="#启动redis服务" class="headerlink" title="启动redis服务"></a>启动redis服务</h5><p>   1、前台启动：在任何目录下执行 redis-server （命令行终端关闭则没用）<br>   2、后台启动：在任何目录下执行 redis-server &amp;<br>   3、启动redis服务时，指定配置文件：redis-server redis.conf &amp;</p>
<h5 id="关闭redis服务"><a href="#关闭redis服务" class="headerlink" title="关闭redis服务"></a>关闭redis服务</h5><p>   1、通过kill命令：<br>       ps -ef|grep redis查看pid<br>       kill -9 pid<br>   2、 redis-cli shutdown</p>
<h5 id="redis的客户端"><a href="#redis的客户端" class="headerlink" title="redis的客户端"></a>redis的客户端</h5><p>用来连接redis服务，向redis服务端发送命令，并且显示redis服务处理结果。<br>redis-cli：是redis自带客户端，使用命令redis-cli就可以启动redis的客户端程序。   </p>
<p>   redis-cli：默认连接127.0.0.1(本机)的6379端口上的redis服务。<br>   redis-cli -p 端口号：连接127.0.0.1(本机)的指定端口上的redis服务。<br>   redis-cli -h ip地址 -p 端口：连接指定ip主机上的指定端口的redis服务。</p>
<h5 id="退出客户端"><a href="#退出客户端" class="headerlink" title="退出客户端"></a>退出客户端</h5><p>在客户端执行命令：exit或者quit</p>
<h5 id="redis的基本知识"><a href="#redis的基本知识" class="headerlink" title="redis的基本知识"></a>redis的基本知识</h5><blockquote>
<p>测试redis服务的性能：</p>
</blockquote>
<p>redis-benchmark</p>
<blockquote>
<p>查看redis服务是否正常运行：</p>
</blockquote>
<p> ping  如果正常—pong</p>
<blockquote>
<p>查看redis服务器的统计信息：</p>
</blockquote>
<p>info  查看redis服务的所有统计信息<br>info [信息段] 查看redis服务器的指定的统计信息，如：info Replication</p>
<blockquote>
<p>redis的数据库实例</p>
</blockquote>
<p>作用类似于mysql的数据库实例，redis中的数据库实例只能由redis服务来创建和维护，开发人员不能修改和自行创建数据库实例；默认情况下，redis会自动创建16个数据库实例，并且给这些数据库实例进行编号，从0开始，一直到15，使用时通过编号来使用数据库；可以通过配置文件，指定redis自动创建的数据库个数；redis的每一个数据库实例本身占用的存储空间是很少的，所以也不造成存储空间的太多浪费。默认情况下，redis客户端连接的是编号是0的数据库实例；可以使用select index切换数据库实例。</p>
<blockquote>
<p>查看当前数据库实例中所有key的数量：</p>
</blockquote>
<p>dbsize</p>
<blockquote>
<p>查看当前数据库实例中所有的key：</p>
</blockquote>
<p>keys *   </p>
<blockquote>
<p>清空数据库实例</p>
</blockquote>
<p>flushdb</p>
<blockquote>
<p>清空所有的数据库实例</p>
</blockquote>
<p>flushall</p>
<blockquote>
<p>查看redis中所有的配置信息</p>
</blockquote>
<p>config get *</p>
<blockquote>
<p>查看redis中的指定的配置信息</p>
</blockquote>
<p>config get parameter</p>
<h5 id="Redis的五种数据结构"><a href="#Redis的五种数据结构" class="headerlink" title="Redis的五种数据结构"></a>Redis的五种数据结构</h5><p>程序是用来处理数据的，Redis是用来存储数据的；程序处理完的数据要存储到redis中，不同特点的数据要存储在Redis中不同类型的数据结构中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string 单key:单value: username:zhangsan age:20</span><br><span class="line">list   单key:多有序value: contacts:13900009999,xxx,xxxx</span><br><span class="line">set    单key:多无序value:city:bj sh cq tj</span><br><span class="line">hash   单key: 对象(属性:值):student:id:1001,name:zhangsan,age:20</span><br><span class="line">zset   单key:多有序vlaue:</span><br></pre></td></tr></table></figure>
<h6 id="字符串类型-string"><a href="#字符串类型-string" class="headerlink" title="字符串类型 string"></a>字符串类型 string</h6><p>字符串类型是Redis中最基本的数据结构，它能存储任何类型的数据，包括二进制数据，序列化后的数据，JSON化的对象甚至是一张图片，最大512M.</p>
<p> <img src="/images/redis/store_string.jpeg" alt="string" loading="lazy"></p>
<h6 id="列表类型-list"><a href="#列表类型-list" class="headerlink" title="列表类型 list"></a>列表类型 list</h6><p>Redis列表是简单的字符串列表，按照插入顺序排序，元素可以重复，你可以添加一个元素到列表的头部（左边）或者尾部（右边），底层是个链表结构。<br> <img src="/images/redis/store_list.jpeg" alt="list" loading="lazy"></p>
<h6 id="集合类型-set"><a href="#集合类型-set" class="headerlink" title="集合类型 set"></a>集合类型 set</h6><p>Redis的Set是string类型的无序无重复集合。<br> <img src="/images/redis/store_set.jpeg" alt="Set" loading="lazy"></p>
<h6 id="哈希类型-hash"><a href="#哈希类型-hash" class="headerlink" title="哈希类型 hash"></a>哈希类型 hash</h6><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br> <img src="/images/redis/store_hash.jpeg" alt="hash" loading="lazy"></p>
<h6 id="有序集合类型-zset-（sorted-set）"><a href="#有序集合类型-zset-（sorted-set）" class="headerlink" title="有序集合类型 zset （sorted set）"></a>有序集合类型 zset （sorted set）</h6><p>Redis 有序集合zset和集合set一样也是string类型元素的集合，且不允许重复的成员。<br>不同的是zset的每个元素都会关联一个分数（分数可以重复），redis通过分数来为集合中的成员进行从小到大的排序。<br> <img src="/images/redis/store_zset.jpeg" alt="zset" loading="lazy"></p>
<h4 id="常用操作命令"><a href="#常用操作命令" class="headerlink" title="常用操作命令"></a>常用操作命令</h4><h5 id="redis中有关key的操作命令"><a href="#redis中有关key的操作命令" class="headerlink" title="redis中有关key的操作命令"></a>redis中有关key的操作命令</h5><h6 id="查看数据库中的key：keys-pattern"><a href="#查看数据库中的key：keys-pattern" class="headerlink" title="查看数据库中的key：keys pattern"></a>查看数据库中的key：keys pattern</h6><blockquote>
<p>*：匹配0个或者多个字符<br>?: 匹配1个字符<br>[]:匹配[]里边的1个字符</p>
</blockquote>
<p>e.g:<br>keys h<em>o：查看数据库中所有以h开头、以o结尾的key<br>keys k</em>:查看数据库中所有以k开头的key<br>keys h*o：查看数据库中所有以h开头、以o结尾的key<br>keys h?o: 查看数据库中所有以h开头、以o结尾的、并且中间只有一个字符的key<br>keys h[abc]llo：查看数据库中所有以h开头以llo结尾，并且h后边只能取abc中的一个字符的key</p>
<h6 id="判断key在数据库中是否存在"><a href="#判断key在数据库中是否存在" class="headerlink" title="判断key在数据库中是否存在"></a>判断key在数据库中是否存在</h6><p>exists key 如果存在，则返回1；如果不存在，则返回0<br>exists key [key key ….] 返回值是存在的key的数量<br>exists k1<br>exists k1 k2 k3 hello</p>
<h6 id="移动指定key到指定的数据库实例"><a href="#移动指定key到指定的数据库实例" class="headerlink" title="移动指定key到指定的数据库实例"></a>移动指定key到指定的数据库实例</h6><p>move key index</p>
<h6 id="查看指定key的剩余生存时间"><a href="#查看指定key的剩余生存时间" class="headerlink" title="查看指定key的剩余生存时间"></a>查看指定key的剩余生存时间</h6><p>ttl key<br>如果key没有设置生存时间，返回-1<br>如果key不存在，返回-2</p>
<h6 id="设置key的最大生存时间"><a href="#设置key的最大生存时间" class="headerlink" title="设置key的最大生存时间"></a>设置key的最大生存时间</h6><p>expire key seconds<br>e.g: expire k2 20</p>
<h6 id="查看指定key的数据类型"><a href="#查看指定key的数据类型" class="headerlink" title="查看指定key的数据类型"></a>查看指定key的数据类型</h6><p>type key<br>e.g: type k1</p>
<h6 id="重命名key"><a href="#重命名key" class="headerlink" title="重命名key"></a>重命名key</h6><p>rename key newkey<br>e.g: rename hello k2</p>
<h6 id="删除指定的key"><a href="#删除指定的key" class="headerlink" title="删除指定的key"></a>删除指定的key</h6><p>del key [key key …..]<br>返回值是实际删除的key的数量<br>e.g: del k1 k2 k3 k4</p>
<h5 id="redis中有关string类型数据的操作命令"><a href="#redis中有关string类型数据的操作命令" class="headerlink" title="redis中有关string类型数据的操作命令"></a>redis中有关string类型数据的操作命令</h5><h6 id="将string类型的数据设置到redis中"><a href="#将string类型的数据设置到redis中" class="headerlink" title="将string类型的数据设置到redis中"></a>将string类型的数据设置到redis中</h6><blockquote>
<p>set 键 值</p>
</blockquote>
<p>set zsname zhangsan<br>set zsage 20<br>set totalRows 100<br>set zsage 30 如果key已经存在，则后来的value会把以前的value覆盖掉</p>
<h6 id="从redis中获取string类型的数据"><a href="#从redis中获取string类型的数据" class="headerlink" title="从redis中获取string类型的数据"></a>从redis中获取string类型的数据</h6><blockquote>
<p>get 键</p>
</blockquote>
<p>get zsname<br>get zsage<br>get totalRows</p>
<h6 id="追加字符串"><a href="#追加字符串" class="headerlink" title="追加字符串"></a>追加字符串</h6><blockquote>
<p>append key value</p>
</blockquote>
<p>返回追加之后的字符串长度<br>如果key不存在，则新创建一个key，并且把value值设置为value。<br>set phone 1389999<br>append phone 8888</p>
<h6 id="获取字符串数据的长度"><a href="#获取字符串数据的长度" class="headerlink" title="获取字符串数据的长度"></a>获取字符串数据的长度</h6><blockquote>
<p>strlen key</p>
</blockquote>
<h6 id="将字符串数值进行加1运算"><a href="#将字符串数值进行加1运算" class="headerlink" title="将字符串数值进行加1运算"></a>将字符串数值进行加1运算</h6><blockquote>
<p>incr key</p>
</blockquote>
<p>返回减1运算之后的数据<br>如果key不存在，首先设置一个key，值初始化为0，然后进行decr运算。<br>要求key所表示value必须是数值，否则，报错</p>
<h6 id="将字符串数值进行减1运算"><a href="#将字符串数值进行减1运算" class="headerlink" title="将字符串数值进行减1运算"></a>将字符串数值进行减1运算</h6><blockquote>
<p>decr key</p>
</blockquote>
<p>返回减1运算之后的数据<br>如果key不存在，首先设置一个key，值初始化为0，然后进行decr运算。<br>要求key所表示value必须是数值，否则，报错</p>
<h6 id="将字符串数值进行加offset运算"><a href="#将字符串数值进行加offset运算" class="headerlink" title="将字符串数值进行加offset运算"></a>将字符串数值进行加offset运算</h6><blockquote>
<p>incrby key offset</p>
</blockquote>
<p>返回加offset运算之后的数据<br>如果key不存在，首先设置一个key，值初始化为0，然后进行incrby运算。<br>要求key所表示value必须是数值，否则，报错</p>
<p>incrby zsage 10</p>
<h6 id="将字符串数值进行减offset运算"><a href="#将字符串数值进行减offset运算" class="headerlink" title="将字符串数值进行减offset运算"></a>将字符串数值进行减offset运算</h6><blockquote>
<p>decrby key offset</p>
</blockquote>
<p>返回减offset运算之后的数据<br>如果key不存在，首先设置一个key，值初始化为0，然后进行decrby运算。<br>要求key所表示value必须是数值，否则，报错</p>
<h6 id="闭区间获取字符串key中从startIndex到endIndex的字符组成的子字符串"><a href="#闭区间获取字符串key中从startIndex到endIndex的字符组成的子字符串" class="headerlink" title="闭区间获取字符串key中从startIndex到endIndex的字符组成的子字符串"></a>闭区间获取字符串key中从startIndex到endIndex的字符组成的子字符串</h6><blockquote>
<p>getrange key startIndex endIndex</p>
</blockquote>
<p>下标自左至右，从0开始，依次往后，最后一个字符的下标是字符串长多-1；<br>字符串中每一个下标也可以是负数，负下标表示自右至左，从-1开始，依次往前，最右边一个字符的下标是-1</p>
<p>zhangsan<br> getrange zsname 2 5  angs<br> getrange zsname 2 -3 angs<br> getrange zsname 0 -1 zhangsan</p>
<h6 id="用value覆盖从下标为startIndex开始的字符串，能覆盖几个字符就覆盖几个字符"><a href="#用value覆盖从下标为startIndex开始的字符串，能覆盖几个字符就覆盖几个字符" class="headerlink" title="用value覆盖从下标为startIndex开始的字符串，能覆盖几个字符就覆盖几个字符"></a>用value覆盖从下标为startIndex开始的字符串，能覆盖几个字符就覆盖几个字符</h6><blockquote>
<p>setrange key startIndex value</p>
</blockquote>
<p>setrange zsname 5 xiaosan<br>setrange zsname 5 lao </p>
<h6 id="设置字符串数据的同时，设置它最大生命周期"><a href="#设置字符串数据的同时，设置它最大生命周期" class="headerlink" title="设置字符串数据的同时，设置它最大生命周期"></a>设置字符串数据的同时，设置它最大生命周期</h6><blockquote>
<p>setex key seconds value</p>
</blockquote>
<p>setex k1 20 v1</p>
<h6 id="设置string类型的数据value到redis数据库中，当key不存在时设置成功，否则，则放弃设置"><a href="#设置string类型的数据value到redis数据库中，当key不存在时设置成功，否则，则放弃设置" class="headerlink" title="设置string类型的数据value到redis数据库中，当key不存在时设置成功，否则，则放弃设置"></a>设置string类型的数据value到redis数据库中，当key不存在时设置成功，否则，则放弃设置</h6><blockquote>
<p>setnx key value</p>
</blockquote>
<p>setex k1 20 v1</p>
<h6 id="批量将string类型的数据设置到redis中"><a href="#批量将string类型的数据设置到redis中" class="headerlink" title="批量将string类型的数据设置到redis中"></a>批量将string类型的数据设置到redis中</h6><blockquote>
<p>mset 键1 值1 键2 值2 …..</p>
</blockquote>
<p>mset k1 v1 k2 v2 k3 v3 k4 v4 k5 v5</p>
<h6 id="批量从redis中获取string类型的数据"><a href="#批量从redis中获取string类型的数据" class="headerlink" title="批量从redis中获取string类型的数据"></a>批量从redis中获取string类型的数据</h6><blockquote>
<p>mget 键1 键2 键3…..</p>
</blockquote>
<p>mget k1 k2 k3 k4 k5 k6 zsname zs age totalRows</p>
<h6 id="批量设置string类型的数据value到redis数据库中，当所有key都不存在时设置成功，否则-只要有一个已经存在-，则全部放弃设置"><a href="#批量设置string类型的数据value到redis数据库中，当所有key都不存在时设置成功，否则-只要有一个已经存在-，则全部放弃设置" class="headerlink" title="批量设置string类型的数据value到redis数据库中，当所有key都不存在时设置成功，否则(只要有一个已经存在)，则全部放弃设置"></a>批量设置string类型的数据value到redis数据库中，当所有key都不存在时设置成功，否则(只要有一个已经存在)，则全部放弃设置</h6><blockquote>
<p>msetnx 键1 值1 键2 值2 …..</p>
</blockquote>
<p> msetnx kk1 vv1 kk2 vv2 kk3 vv3 k1 v1</p>
<h5 id="redis中有关list类型数据的操作命令"><a href="#redis中有关list类型数据的操作命令" class="headerlink" title="redis中有关list类型数据的操作命令"></a>redis中有关list类型数据的操作命令</h5><ul>
<li>单Key - 多有序value</li>
<li>一个key对应多个value</li>
<li>多个value之间有顺序，最左侧是表头，最右侧是表尾；</li>
<li>每一个元素都有下标，表头元素的下标是0，依次往后排序，最后一个元素下标是列表长度-1；</li>
<li>每一个元素的下标又可以用负数表示，负下标表示从表尾计算，最后一个元素下标用-1表示；</li>
<li>元素在列表中的顺序或者下标由放入的顺序来决定。</li>
<li>通过key和下标来操作数据。 </li>
</ul>
<h6 id="将一个或者多个值依次插入到列表的表头-左侧"><a href="#将一个或者多个值依次插入到列表的表头-左侧" class="headerlink" title="将一个或者多个值依次插入到列表的表头(左侧)"></a>将一个或者多个值依次插入到列表的表头(左侧)</h6><blockquote>
<p>lpush key value [value value …..]</p>
</blockquote>
<p>lpush list01 1 2 3  结果：3 2 1<br>lpush list01 4 5     结果：5 4 3 2 1</p>
<h6 id="获取指定列表中指定下标区间的元素"><a href="#获取指定列表中指定下标区间的元素" class="headerlink" title="获取指定列表中指定下标区间的元素"></a>获取指定列表中指定下标区间的元素</h6><blockquote>
<p>lrange key startIndex endIndex</p>
</blockquote>
<p>lrange list01 1 3  结果：4 3 2<br>lrange list01 1 -2 结果: 4 3 2<br>lrange list01 0 -1 结果：5 4 3 2 1</p>
<h6 id="将一个或者多个值依次插入到列表的表尾-右侧"><a href="#将一个或者多个值依次插入到列表的表尾-右侧" class="headerlink" title="将一个或者多个值依次插入到列表的表尾(右侧)"></a>将一个或者多个值依次插入到列表的表尾(右侧)</h6><blockquote>
<p>rpush key value [value value …..]</p>
</blockquote>
<p>rpush list02 a b c 结果：a b c<br>rpush list02 d e   结果：a b c d e<br>lpush list02 m n   结果: n m a b c d e</p>
<h6 id="从指定列表中移除并且返回表头元素"><a href="#从指定列表中移除并且返回表头元素" class="headerlink" title="从指定列表中移除并且返回表头元素"></a>从指定列表中移除并且返回表头元素</h6><blockquote>
<p>lpop key</p>
</blockquote>
<p>lpop list02</p>
<h6 id="从指定列表中移除并且返回表尾元素"><a href="#从指定列表中移除并且返回表尾元素" class="headerlink" title="从指定列表中移除并且返回表尾元素"></a>从指定列表中移除并且返回表尾元素</h6><blockquote>
<p>rpop list02</p>
</blockquote>
<h6 id="获取指定列表中指定下标的元素"><a href="#获取指定列表中指定下标的元素" class="headerlink" title="获取指定列表中指定下标的元素"></a>获取指定列表中指定下标的元素</h6><blockquote>
<p>lindex key index<br> lindex list01 2 结果：3</p>
</blockquote>
<h6 id="获取指定列表的长度"><a href="#获取指定列表的长度" class="headerlink" title="获取指定列表的长度"></a>获取指定列表的长度</h6><blockquote>
<p>llen key</p>
</blockquote>
<h6 id="根据count值移除指定列表中跟value相等的数据"><a href="#根据count值移除指定列表中跟value相等的数据" class="headerlink" title="根据count值移除指定列表中跟value相等的数据"></a>根据count值移除指定列表中跟value相等的数据</h6><blockquote>
<p>lrem key count value</p>
</blockquote>
<p>|-&gt;count&gt;0：从列表的左侧移除count个跟value相等的数据；<br>|-&gt;count&lt;0：从列表的右侧移除count个跟vlaue相等的数据；<br>|-&gt;count=0：从列表中移除所有跟value相等的数据<br>lpush list03 a a b c a d e a b b  结果：b b a e d a c b a a<br>lrem list03 2 a  结果：b b e d c b a a<br>lrem list03 -1 a 结果：b b e d c b a<br>lrem list03 0 a  结果：b b e d c b</p>
<h6 id="截取指定列表中指定下标区间的元素组成新的列表，并且赋值给key"><a href="#截取指定列表中指定下标区间的元素组成新的列表，并且赋值给key" class="headerlink" title="截取指定列表中指定下标区间的元素组成新的列表，并且赋值给key"></a>截取指定列表中指定下标区间的元素组成新的列表，并且赋值给key</h6><blockquote>
<p>ltrim key startIndex endIndex</p>
</blockquote>
<p>lpush list04 1 2 3 4 5  结果：5 4 3 2 1<br>ltrim list04 1 3<br>lrange list04 0 -1      结果：4 3 2</p>
<h6 id="将指定列表中指定下标的元素设置为指定值"><a href="#将指定列表中指定下标的元素设置为指定值" class="headerlink" title="将指定列表中指定下标的元素设置为指定值"></a>将指定列表中指定下标的元素设置为指定值</h6><blockquote>
<p>lset key index value</p>
</blockquote>
<p>lset list04 1 10</p>
<h6 id="将value插入到指定列表中位于pivot元素之前-之后的位置"><a href="#将value插入到指定列表中位于pivot元素之前-之后的位置" class="headerlink" title="将value插入到指定列表中位于pivot元素之前/之后的位置"></a>将value插入到指定列表中位于pivot元素之前/之后的位置</h6><blockquote>
<p>linsert key before/after pivot vlaue</p>
</blockquote>
<p>linsert list04 before 10 50<br>linsert list04 after 10 60</p>
<h5 id="redis中有关set类型数据的操作命令"><a href="#redis中有关set类型数据的操作命令" class="headerlink" title="redis中有关set类型数据的操作命令"></a>redis中有关set类型数据的操作命令</h5><p>单key-多无序value<br>一个key对应多个vlaue；<br>value之间没有顺序，并且不能重复；<br>通过业务数据直接操作集合。</p>
<h6 id="将一个或者多个元素添加到指定的集合中"><a href="#将一个或者多个元素添加到指定的集合中" class="headerlink" title="将一个或者多个元素添加到指定的集合中"></a>将一个或者多个元素添加到指定的集合中</h6><blockquote>
<p>sadd key value [value value …]</p>
</blockquote>
<p>*如果元素已经存在，则会忽略。<br>*返回成功加入的元素的个数<br>sadd set01 a b c a  结果：a b c<br>sadd set01 b d e</p>
<h6 id="获取指定集合中所有的元素"><a href="#获取指定集合中所有的元素" class="headerlink" title="获取指定集合中所有的元素"></a>获取指定集合中所有的元素</h6><blockquote>
<p>smembers key</p>
</blockquote>
<p>smembers set01</p>
<h6 id="判断指定元素在指定集合中是否存在"><a href="#判断指定元素在指定集合中是否存在" class="headerlink" title="判断指定元素在指定集合中是否存在"></a>判断指定元素在指定集合中是否存在</h6><blockquote>
<p>sismember key member</p>
</blockquote>
<p>*存在，返回1<br>*不存在，返回0<br>sismember set01 f<br>sismember set01 a</p>
<h6 id="获取指定集合的长度"><a href="#获取指定集合的长度" class="headerlink" title="获取指定集合的长度"></a>获取指定集合的长度</h6><blockquote>
<p>scard key</p>
</blockquote>
<p>scard set01</p>
<h6 id="移除指定集合中一个或者多个元素"><a href="#移除指定集合中一个或者多个元素" class="headerlink" title="移除指定集合中一个或者多个元素"></a>移除指定集合中一个或者多个元素</h6><blockquote>
<p>srem key member [member …..]</p>
</blockquote>
<p>*不存在的元素会被忽略<br>*返回成功成功移除的个数<br>srem set01 b d m</p>
<h6 id="随机获取指定集合中的一个或者多个元素"><a href="#随机获取指定集合中的一个或者多个元素" class="headerlink" title="随机获取指定集合中的一个或者多个元素"></a>随机获取指定集合中的一个或者多个元素</h6><blockquote>
<p>srandmember key [count]</p>
</blockquote>
<p>count&gt;0：随机获取的多个元素之间不能重复<br>count&lt;0: 随机获取的多个元素之间可能重复<br>sadd set02 1 2 3 4 5 6 7 8<br>srandmember set02<br>srandmember set02 3<br>srandmember set02 -3</p>
<h6 id="从指定集合中随机移除一个或者多个元素"><a href="#从指定集合中随机移除一个或者多个元素" class="headerlink" title="从指定集合中随机移除一个或者多个元素"></a>从指定集合中随机移除一个或者多个元素</h6><blockquote>
<p>spop key [count]</p>
</blockquote>
<p>spop set02</p>
<h6 id="将指定集合中的指定元素移动到另一个元素"><a href="#将指定集合中的指定元素移动到另一个元素" class="headerlink" title="将指定集合中的指定元素移动到另一个元素"></a>将指定集合中的指定元素移动到另一个元素</h6><blockquote>
<p>smove source dest member</p>
</blockquote>
<h6 id="获取第一个集合中有、但是其它集合中都没有的元素组成的新集合"><a href="#获取第一个集合中有、但是其它集合中都没有的元素组成的新集合" class="headerlink" title="获取第一个集合中有、但是其它集合中都没有的元素组成的新集合"></a>获取第一个集合中有、但是其它集合中都没有的元素组成的新集合</h6><blockquote>
<p>sdiff key key [key key ….]</p>
</blockquote>
<p>sdiff set01 set02 set03</p>
<h6 id="获取所有指定集合中都有的元素组成的新集合"><a href="#获取所有指定集合中都有的元素组成的新集合" class="headerlink" title="获取所有指定集合中都有的元素组成的新集合"></a>获取所有指定集合中都有的元素组成的新集合</h6><blockquote>
<p>sinter set01 set02 set03</p>
</blockquote>
<h6 id="获取所有指定集合中所有元素组成的大集合"><a href="#获取所有指定集合中所有元素组成的大集合" class="headerlink" title="获取所有指定集合中所有元素组成的大集合"></a>获取所有指定集合中所有元素组成的大集合</h6><blockquote>
<p>sunion set01 set02 set03</p>
</blockquote>
<h5 id="redis中有关hash类型数据的操作命令"><a href="#redis中有关hash类型数据的操作命令" class="headerlink" title="redis中有关hash类型数据的操作命令"></a>redis中有关hash类型数据的操作命令</h5><p>单key:field-value<br>     field-value<br>…..</p>
<p>studentzs:id-1001<br>          name-zhangsan<br>          age-20</p>
<h6 id="将一个或者多个field-vlaue对设置到哈希表中"><a href="#将一个或者多个field-vlaue对设置到哈希表中" class="headerlink" title="将一个或者多个field-vlaue对设置到哈希表中"></a>将一个或者多个field-vlaue对设置到哈希表中</h6><blockquote>
<p>hset key filed1 value1 [field2 value2 ….] </p>
</blockquote>
<p>*如果key field已经存在，把value会把以前的值覆盖掉<br>hset stu1001 id 1001<br>hset stu1001 name zhangsan age 20</p>
<h6 id="获取指定哈希表中指定field的值"><a href="#获取指定哈希表中指定field的值" class="headerlink" title="获取指定哈希表中指定field的值"></a>获取指定哈希表中指定field的值</h6><blockquote>
<p>hget key filed</p>
</blockquote>
<p>hget stu1001 id<br>hget stu1001 name</p>
<h6 id="批量将多个field-value对设置到哈希表中"><a href="#批量将多个field-value对设置到哈希表中" class="headerlink" title="批量将多个field-value对设置到哈希表中"></a>批量将多个field-value对设置到哈希表中</h6><blockquote>
<p>hmset key filed1 value1 [field2 value2 ….] </p>
</blockquote>
<p>hmset stu1002 id 1002 name lisi age 20</p>
<h6 id="批量获取指定哈希表中的field的值"><a href="#批量获取指定哈希表中的field的值" class="headerlink" title="批量获取指定哈希表中的field的值"></a>批量获取指定哈希表中的field的值</h6><blockquote>
<p>hmget key field1 [field2 field3 ….]</p>
</blockquote>
<p>hmget stu1001 id name age</p>
<h6 id="获取指定哈希表中所有的field和value"><a href="#获取指定哈希表中所有的field和value" class="headerlink" title="获取指定哈希表中所有的field和value"></a>获取指定哈希表中所有的field和value</h6><blockquote>
<p>hgetall key</p>
</blockquote>
<h6 id="从指定哈希表中删除一个或者多个field"><a href="#从指定哈希表中删除一个或者多个field" class="headerlink" title="从指定哈希表中删除一个或者多个field"></a>从指定哈希表中删除一个或者多个field</h6><blockquote>
<p>hdel key field1 [field2 field3 ….]</p>
</blockquote>
<p>hdel stu1002 name age</p>
<h6 id="获取指定哈希表中所有的filed个数"><a href="#获取指定哈希表中所有的filed个数" class="headerlink" title="获取指定哈希表中所有的filed个数"></a>获取指定哈希表中所有的filed个数</h6><blockquote>
<p>hlen key</p>
</blockquote>
<p>hlen stu1001<br>hlen stu1002</p>
<h6 id="判断指定哈希表中是否存在某一个field"><a href="#判断指定哈希表中是否存在某一个field" class="headerlink" title="判断指定哈希表中是否存在某一个field"></a>判断指定哈希表中是否存在某一个field</h6><blockquote>
<p>hexists key filed</p>
</blockquote>
<p>hexists stu1001 name<br>hexists stu1002 name</p>
<h6 id="获取指定哈希表中所有的field列表"><a href="#获取指定哈希表中所有的field列表" class="headerlink" title="获取指定哈希表中所有的field列表"></a>获取指定哈希表中所有的field列表</h6><blockquote>
<p>hkeys key</p>
</blockquote>
<p>hkeys stu1001<br>hkeys stu1002</p>
<h6 id="获取指定哈希表中所有的value列表"><a href="#获取指定哈希表中所有的value列表" class="headerlink" title="获取指定哈希表中所有的value列表"></a>获取指定哈希表中所有的value列表</h6><blockquote>
<p>hvals key</p>
</blockquote>
<p>hvals stu1001<br>hvals stu1002</p>
<h6 id="对指定哈希表中指定field值进行整数加法运算"><a href="#对指定哈希表中指定field值进行整数加法运算" class="headerlink" title="对指定哈希表中指定field值进行整数加法运算"></a>对指定哈希表中指定field值进行整数加法运算</h6><blockquote>
<p>hincrby key field int</p>
</blockquote>
<p>hincrby stu1001 age 5</p>
<h6 id="对指定哈希表中指定field值进行浮点数加法运算"><a href="#对指定哈希表中指定field值进行浮点数加法运算" class="headerlink" title="对指定哈希表中指定field值进行浮点数加法运算"></a>对指定哈希表中指定field值进行浮点数加法运算</h6><blockquote>
<p>hincrbyfloat key field float</p>
</blockquote>
<p>hset stu1001 score 80.5<br>hincrbyfloat stu1001 score 5.5</p>
<h6 id="将一个field-vlaue对设置到哈希表中"><a href="#将一个field-vlaue对设置到哈希表中" class="headerlink" title="将一个field-vlaue对设置到哈希表中"></a>将一个field-vlaue对设置到哈希表中</h6><p>当key-field已经存在时，则放弃设置；否则，设置file-value：</p>
<blockquote>
<p>hsetnx key field value</p>
</blockquote>
<h5 id="redis中有关zset类型数据的操作命令"><a href="#redis中有关zset类型数据的操作命令" class="headerlink" title="redis中有关zset类型数据的操作命令"></a>redis中有关zset类型数据的操作命令</h5><p>有序集合<br>本质上是集合，所有元素不能重复；<br>每一个元素都关联一个分数，redis会根据分数对元素进行自动排序；<br>分数可以重复；<br>既然有序集合中每一个元素都有顺序，那么也都有下标<br>有序集合中元素的排序规则又列表中元素的排序规则不一样。</p>
<h6 id="将一个或者多个member及其score值加入有序集合"><a href="#将一个或者多个member及其score值加入有序集合" class="headerlink" title="将一个或者多个member及其score值加入有序集合"></a>将一个或者多个member及其score值加入有序集合</h6><blockquote>
<p>zadd key score member [score member ….]</p>
</blockquote>
<p>*如果元素已经存在，则把分数覆盖<br>zadd zset01 20 z1 30 z2 50 z3 40 z4<br>zadd zset01 60 z2</p>
<h6 id="获取指定有序集合中指定下标区间的元素"><a href="#获取指定有序集合中指定下标区间的元素" class="headerlink" title="获取指定有序集合中指定下标区间的元素"></a>获取指定有序集合中指定下标区间的元素</h6><blockquote>
<p>zrange key startIndex endIndex [withscores]</p>
</blockquote>
<p>zrange zset01 0 -1<br>zrange zset01 0 -1 withscores</p>
<h6 id="获取指定有序集合中指定分数区间-闭区间-的元素"><a href="#获取指定有序集合中指定分数区间-闭区间-的元素" class="headerlink" title="获取指定有序集合中指定分数区间(闭区间)的元素"></a>获取指定有序集合中指定分数区间(闭区间)的元素</h6><blockquote>
<p>zrangebyscore key min max [withscores]</p>
</blockquote>
<p>zrangebyscore zset01 30 50 withscores</p>
<h6 id="删除指定有序集合中一个或者多个元素"><a href="#删除指定有序集合中一个或者多个元素" class="headerlink" title="删除指定有序集合中一个或者多个元素"></a>删除指定有序集合中一个或者多个元素</h6><blockquote>
<p>zrem key member [member……]</p>
</blockquote>
<p>zrem zset01 z3 z4</p>
<h6 id="获取指定有序集合中所有元素的个数"><a href="#获取指定有序集合中所有元素的个数" class="headerlink" title="获取指定有序集合中所有元素的个数"></a>获取指定有序集合中所有元素的个数</h6><blockquote>
<p>zcard key</p>
</blockquote>
<p>zcard zset01</p>
<h6 id="获取指定有序集合中分数在指定区间内的元素的个数"><a href="#获取指定有序集合中分数在指定区间内的元素的个数" class="headerlink" title="获取指定有序集合中分数在指定区间内的元素的个数"></a>获取指定有序集合中分数在指定区间内的元素的个数</h6><blockquote>
<p>zcount key min max</p>
</blockquote>
<p>zcount zset01 20 50</p>
<h6 id="获取指定有序集合中指定元素的排名-排名从0开始"><a href="#获取指定有序集合中指定元素的排名-排名从0开始" class="headerlink" title="获取指定有序集合中指定元素的排名(排名从0开始)"></a>获取指定有序集合中指定元素的排名(排名从0开始)</h6><blockquote>
<p>zrank key member</p>
</blockquote>
<p>zrank zset01 z4</p>
<h6 id="获取指定有序集合中指定元素的分数"><a href="#获取指定有序集合中指定元素的分数" class="headerlink" title="获取指定有序集合中指定元素的分数"></a>获取指定有序集合中指定元素的分数</h6><blockquote>
<p>zscore key member</p>
</blockquote>
<p>zscore zset01 z4</p>
<h6 id="获取指定有序集合中指定元素的排名-按照分数从大到小的排名"><a href="#获取指定有序集合中指定元素的排名-按照分数从大到小的排名" class="headerlink" title="获取指定有序集合中指定元素的排名(按照分数从大到小的排名)"></a>获取指定有序集合中指定元素的排名(按照分数从大到小的排名)</h6><blockquote>
<p>zrevrank key member</p>
</blockquote>
<h4 id="redis的配置文件"><a href="#redis的配置文件" class="headerlink" title="redis的配置文件"></a>redis的配置文件</h4><h5 id="redis-conf存放位置"><a href="#redis-conf存放位置" class="headerlink" title="redis.conf存放位置"></a>redis.conf存放位置</h5><ul>
<li>redis安装完成之后，在redis的根目录会提供一个配置文件(redis.conf)；redis服务可以参考配置文件中的参数进行运行；只有启动redis服务器指定使用的配置文件，参数才会生效；否则，redis会采用默认的参数运行。</li>
</ul>
<h5 id="Redis-的网络相关配置"><a href="#Redis-的网络相关配置" class="headerlink" title="Redis 的网络相关配置"></a>Redis 的网络相关配置</h5><ul>
<li>redis配置信息：</li>
</ul>
<blockquote>
<p>1、port：配置redis服务运行的端口号；如果不配置port，则redis服务默认使用6379端口。</p>
</blockquote>
<blockquote>
<p>2、bind: redis服务被客户端连接时，客户端所能使用的ip地址。</p>
</blockquote>
<pre><code>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认情况下，不配置bind，客户端连接redis服务时，通过服务器上任何一个ip都能连接到redis服务；一旦配置了bind，客户端就只能通过bind指定的ip地址连接redis服务。</span><br><span class="line">一般情况下，bind都是配置服务器上某一个真实ip。</span><br><span class="line"></span><br><span class="line">redis-cli ：默认连接127.0.0.1本机上的6379端口服务</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6379：同上</span><br><span class="line">redis-cli -h 192.168.11.128 -p 6379：</span><br><span class="line"></span><br><span class="line">*强调：一旦redis服务配置了port和bind(如果port不是6379、bind也不是127.0.0.1)，客户端连接redis服务时，就要指定端口和ip：</span><br><span class="line">redis-cli：默认连接127.0.0.1上的6379服务</span><br><span class="line">redis-cli -h bind绑定的ip地址 -p port设置的端口：连接bind绑定的ip地址主机上的port设置的端口redis服务；</span><br><span class="line"></span><br><span class="line">关闭redis服务时：redis-cli -h bind绑定的ip地址 -p port设置的端口 shutdown</span><br></pre></td></tr></table></figure>
</code></pre>
<blockquote>
<p>3、tcp-keepalive：TCP连接保活策略，可以通过tcp-keepalive配置项来进行设置，单位为秒，假如设置为60秒，则server端会每60秒向连接空闲的客户端发起一次ACK请求，以检查客户端是否已经挂掉，对于无响应的客户端则会关闭其连接。如果设置为0，则不会进行保活检测。</p>
</blockquote>
<h5 id="Redis的常规配置"><a href="#Redis的常规配置" class="headerlink" title="Redis的常规配置"></a>Redis的常规配置</h5><blockquote>
<p>1、loglevel：日志级别，开发阶段可以设置成debug，生产阶段通常设置为notice或者warning.</p>
</blockquote>
<blockquote>
<p>2、logfile：指定日志文件名，如果不指定，Redis只进行标准输出。要保证日志文件所在的目录必须存在，文件可以不存在。还要在redis启动时指定所使用的配置文件，否则配置不起作用。</p>
</blockquote>
<blockquote>
<p>3、databases：配置Redis数据库的个数，默认是16个。</p>
</blockquote>
<h5 id="Redis的安全配置"><a href="#Redis的安全配置" class="headerlink" title="Redis的安全配置"></a>Redis的安全配置</h5><blockquote>
<p>requirepass：配置Redis的访问密码。默认不配置密码，即访问不需要密码验证。此配置项需要在protected-mode=yes时起作用。使用密码登录客户端：redis-cli -h ip -p 6379 -a pwd</p>
</blockquote>
<h4 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h4><p>redis提供持久化策略，在适当的时机采用适当手段把内存中的数据持久化到磁盘中，每次redis服务启动时，都可以把磁盘上的数据再次加载内存中使用。</p>
<h5 id="RDB策略"><a href="#RDB策略" class="headerlink" title="RDB策略"></a>RDB策略</h5><ul>
<li>在指定时间间隔内，redis服务执行指定次数的写操作，会自动触发一次持久化操作。<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RDB策略是redis默认的持久化策略，redis服务开启时这种持久化策略就已经默认开启了。</span><br><span class="line"></span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;：配置持久化策略</span><br><span class="line">dbfilename：配置redis RDB持久化数据存储的文件</span><br><span class="line">dir:    配置redis RDB持久化文件所在目录</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h5 id="AOF策略"><a href="#AOF策略" class="headerlink" title="AOF策略"></a>AOF策略</h5><ul>
<li><p>采用操作日志来记录进行每一次写操作，每次redis服务启动时，都会重新执行一遍操作日志中的指令。效率低下，redis默认不开启AOF功能。</p>
<pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly:配置是否开启AOF策略</span><br><span class="line">appendfilename：配置操作日志文件</span><br></pre></td></tr></table></figure>
</code></pre>
<blockquote>
<pre><code>小结：根据数据的特点决定开启哪种持久化策略；
   一般情况，开启RDB足够了。
</code></pre>
</blockquote>
</li>
</ul>
<h4 id="Redis的事物"><a href="#Redis的事物" class="headerlink" title="Redis的事物"></a>Redis的事物</h4><ul>
<li>事务：把一组数据库命令放在一起执行，保证操作原子性，要么同时成功，要么同时失败。</li>
<li>Redis的事务：允许把一组redis命令放在一起，把命令进行序列化，然后一起执行，保证部分原子性。</li>
</ul>
<h5 id="multi"><a href="#multi" class="headerlink" title="multi"></a>multi</h5><ul>
<li><p>用来标记一个事务的开始。</p>
<pre><code>multi
set k1 v1
set k2 v2
</code></pre>
</li>
</ul>
<h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h5><ul>
<li><p>用来执行事务队列中所有的命令。</p>
<pre><code>exec
</code></pre>
</li>
</ul>
<h5 id="redis的事务只能保证部分原子性"><a href="#redis的事务只能保证部分原子性" class="headerlink" title="redis的事务只能保证部分原子性"></a>redis的事务只能保证部分原子性</h5><ul>
<li><p>如果一组命令中，有在压入事务队列过程中发生错误的命令，则本事务中所有的命令都不执行，能够保证事务的原子性。</p>
<pre><code>multi
   set k3 v3
   seta kk vv
   set k4 v4
exec
</code></pre>
</li>
<li><p>如果一组命令中，在压入队列过程中正常，但是在执行事务队列命令时发生了错误，则只会影响发生错误的命令，不会影响其它命令的执行，不能够保证事务的原子性。</p>
<pre><code>multi
   set k3 v3
   incr k1
   set k4 v4
exec
</code></pre>
</li>
</ul>
<h5 id="discard"><a href="#discard" class="headerlink" title="discard"></a>discard</h5><ul>
<li><p>清除所有已经压入队列中的命令，并且结束整个事务。</p>
<pre><code> multi
   set k5 v5 
   set k6 v6
 discard
</code></pre>
</li>
</ul>
<h5 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h5><ul>
<li><p>监控某一个键，当事务在执行过程中，此键代码的值发生变化，则本事务放弃执行；否则，正常执行。</p>
<pre><code>id balance version

update table set balance=balance-dept,version=version+1
where id=xxxx and version=100

set balance 100
set balance2 1000
set version 1

watch version
multi
decrby balance 50
incrby balance2 50
exec
</code></pre>
</li>
</ul>
<h5 id="unwatch"><a href="#unwatch" class="headerlink" title="unwatch"></a>unwatch</h5><ul>
<li>放弃监控所有的键。<pre><code> watch version
 unwach
 multi
 decrby balance 50
 incrby balance2 50
 exec
</code></pre>
</li>
</ul>
<h5 id="Redis事务小结"><a href="#Redis事务小结" class="headerlink" title="Redis事务小结"></a>Redis事务小结</h5><ul>
<li>小结<pre><code>1、单独的隔离操作：事务中的所有命令都会序列化、顺序地执行。事务在执行过程中，不会被其它客户端发来的命令请求所打断，除非使用watch命令监控某些键。
2、不保证事务的原子性：redis同一个事务中如果一条命令执行失败，其后的命令仍然可能会被执行，redis的事务没有回滚。Redis已经在系统内部进行功能简化，这样可以确保更快的运行速度，因为Redis不需要事务回滚的能力。
</code></pre>
</li>
</ul>
<h4 id="redis消息的发布与订阅"><a href="#redis消息的发布与订阅" class="headerlink" title="redis消息的发布与订阅"></a>redis消息的发布与订阅</h4><h5 id="Redis发布订阅"><a href="#Redis发布订阅" class="headerlink" title="Redis发布订阅"></a>Redis发布订阅</h5><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。</p>
<h5 id="Redis发布订阅示意图"><a href="#Redis发布订阅示意图" class="headerlink" title="Redis发布订阅示意图"></a>Redis发布订阅示意图</h5><p>图一：消息订阅者(client2 、 client5 和 client1)订阅频道 channel1：<br><img src="/images/redis/subscribe.jpeg" alt="subscribe" loading="lazy"></p>
<p>图二：消息发布者发布消息到频道channel1，会被发送到三个订阅者：<br><img src="/images/redis/publish.jpeg" alt="subscribe" loading="lazy"></p>
<h5 id="Redis发布订阅的常用命令"><a href="#Redis发布订阅的常用命令" class="headerlink" title="Redis发布订阅的常用命令"></a>Redis发布订阅的常用命令</h5><h6 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe"></a>subscribe</h6><ul>
<li>语法：subscribe channel [channel…]<pre><code>功能：订阅一个或多个频道的信息
返回值：订阅的消息
</code></pre>
<img src="/images/redis/operate_s.jpeg" alt="operate_s" loading="lazy"></li>
</ul>
<h6 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h6><ul>
<li>语法：publish chanel message<pre><code>功能：将信息发送到指定的频道。
返回值：数字。接收到消息订阅者的数量。
</code></pre>
<img src="/images/redis/operate_p.jpeg" alt="operate_p" loading="lazy"></li>
</ul>
<h6 id="psubscribe"><a href="#psubscribe" class="headerlink" title="psubscribe"></a>psubscribe</h6><ul>
<li>语法：psubscribe pattern [pattern]<pre><code>功能：订阅一个或多个符合给定模式的频道。模式以 * 作为通配符，例如：news.* 匹配所有以 news. 开头的频道。
返回值：订阅的信息。
</code></pre>
<img src="/images/redis/operate_bp.jpeg" alt="operate_bp" loading="lazy"></li>
</ul>
<h4 id="redis的主从复制"><a href="#redis的主从复制" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h4><h5 id="redis的主从复制-1"><a href="#redis的主从复制-1" class="headerlink" title="redis的主从复制"></a>redis的主从复制</h5><h4 id="redis哨兵模式"><a href="#redis哨兵模式" class="headerlink" title="redis哨兵模式"></a>redis哨兵模式</h4><ul>
<li>主机宕机、从机上位的自动版<pre><code>1)搭建一主二从集群架构：(17节前五步)
2)提供哨兵配置文件：
   在redis安装目下创建配置文件：redis_sentinel.conf
   sentinel monitor dc-redis 127.0.0.1 6379 1
3)启动哨兵服务：
   redis-sentinel redis_sentinel.conf
4)主机宕机：
   关闭6379服务：redis-cli -h 127.0.0.1 -p 6379 shutdown
   哨兵程序自动选择从机上位。
5)之前主机恢复：自动从属于新的主机。
   重启6379服务：redis-server redis6379.conf &amp;
   客户端连接6379：redis-cli -h 127.0.0.1 -p 6379
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Rollup 打包发布</title>
    <url>/2020/06/02/webpack/rollup/</url>
    <content><![CDATA[<h4 id="Rollup用来干啥"><a href="#Rollup用来干啥" class="headerlink" title="Rollup用来干啥"></a>Rollup用来干啥</h4><p>Rollup是当前流行的库打包器，在Webpack、ESM（ES6模块）之后出现，Rollup支持开发者使用ESM模块语法开发。</p>
<h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><p>几乎只支持JS，其他类型的文件如CSS等均需要使用插件处理（后续会介绍 ）</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li><p>Rollup将代码转码成目标js（支持umd/commonjs/es）</p>
</li>
<li><p>Rollup推崇ESM模块标准开发（借助浏览器对ESM的支持）</p>
</li>
<li><p>Rollup打包产物对比Webpack较为精简，如下<br>webpack:<br><img src="/images/webpack/webpack_compare.png" alt="webpack_compare" loading="lazy"></p>
<pre><code> 1. 有大量的诸如 __webpack_require__之类的代码，这些都是 Webpack 自身 Polyfill 的在运行时的模块加载，
 就是为了让产物代码在所有浏览器都能运行（wepack出现的时候还没有ESM ，当时的模块标准还很混乱，Webpack抹平了差异。）
 2. 用 IIFE 实现模块之间的隔离，并且用__webpack_require__ __webpack_exports__ 等 Polyfill 实现在浏览器环境里模拟 CJS 模块加载
 3. 用 Webpack 打包后的代码实际上更像是跑在 Webpack 给我们实现的“虚拟 Runtime”上
</code></pre>
</li>
</ol>
<p>Rollup:<br><img src="/images/webpack/rollup_compare.png" alt="rollup_compare" loading="lazy"></p>
<pre><code>    Rollup 诞生在 ESM 模块标准出来之后，所以 Rollup 完全遵从 ESM 标准，不需要像 Webpack 那样做很多 Runtime Polyfill，
    完全把代码交给浏览器运行。对于一些项目里依赖的老旧的 CJS 的包，也可以通过插件来对这些依赖处理。
</code></pre>
<h4 id="快速0-gt-1"><a href="#快速0-gt-1" class="headerlink" title="快速0 -&gt; 1"></a>快速0 -&gt; 1</h4><h5 id="新建工程"><a href="#新建工程" class="headerlink" title="新建工程"></a>新建工程</h5><p>创建空文件夹，如 mkdir proton-utils</p>
<h5 id="安装rollup"><a href="#安装rollup" class="headerlink" title="安装rollup"></a>安装rollup</h5><p>cd proton-utils &amp; code .</p>
<p>npm init -y</p>
<p>npm install rollup –save-dev</p>
<p>touch .gitignore &amp; vim .gitignore</p>
<p>/node_modules</p>
<h5 id="生成tsconfig-json配置文件"><a href="#生成tsconfig-json配置文件" class="headerlink" title="生成tsconfig.json配置文件"></a>生成tsconfig.json配置文件</h5><p>tsc –init<br>默认的配置其实已经够用，后续可以根据需要删减配置。</p>
<pre><code>    &#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;target&quot;: &quot;es2016&quot;,                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
        /* Modules */
        &quot;module&quot;: &quot;commonjs&quot;,                                /* Specify what module code is generated. */
        /* Interop Constraints */
        &quot;esModuleInterop&quot;: true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables `allowSyntheticDefaultImports` for type compatibility. */
        &quot;forceConsistentCasingInFileNames&quot;: true,            /* Ensure that casing is correct in imports. */
        /* Type Checking */
        &quot;strict&quot;: true,                                      /* Enable all strict type-checking options. */
        &quot;skipLibCheck&quot;: true                                 /* Skip type checking all .d.ts files. */
    &#125;
    &#125;
</code></pre>
<h5 id="创建rollup-config-js"><a href="#创建rollup-config-js" class="headerlink" title="创建rollup.config.js"></a>创建rollup.config.js</h5><p>touch rollup.config.js</p>
<p><a href="https://rollupjs.org/guide/en/#big-list-of-options">Rollup文件配置项</a><br><a href="https://github.com/rollup/plugins">Rollup插件列表</a></p>
<pre><code>    import resolve from &#39;rollup-plugin-node-resolve&#39;;
    import commonjs from &#39;rollup-plugin-commonjs&#39;;
    import typescript from &#39;rollup-plugin-typescript&#39;;
    import pkg from &#39;./package.json&#39;;

    export default &#123;
    input: &#39;src/index.ts&#39;, // 打包入口
    output: &#123; // 打包出口
        file: pkg.browser, // 最终打包出来的文件路径和文件名，这里是在package.json的browser: &#39;dist/index.js&#39;字段中配置的
        format: &#39;umd&#39;, // umd是兼容amd/cjs/iife的通用打包格式，适合浏览器
        name:&#39;proton-utils&#39; // 包的全局变量名称
    &#125;,
    plugins: [ // 打包插件
        resolve(), // 查找和打包node_modules中的第三方模块
        commonjs(), // 将 CommonJS 转换成 ES2015 模块供 Rollup 处理
        typescript() // 解析TypeScript
    ]
    &#125;;
</code></pre>
<p>vim package.json</p>
<pre><code>     &quot;browser&quot;: &quot;dist/index.ts&quot;,
</code></pre>
<p>npm i -D rollup typescript tslib rollup-plugin-node-resolve rollup-plugin-commonjs rollup-plugin-typescript</p>
<ul>
<li>tslib在rollup.config.js没有引入，为啥安装？ -&gt; rollup-plugin-typescript插件依赖了该库。</li>
</ul>
<h5 id="编写需打包库源码"><a href="#编写需打包库源码" class="headerlink" title="编写需打包库源码"></a>编写需打包库源码</h5><p>0 -&gt; 1 小demo<br>跑通源码编写 -&gt; 打包构建 -&gt; 引入使用</p>
<h6 id="源码编写"><a href="#源码编写" class="headerlink" title="源码编写"></a>源码编写</h6><p>mkdir src &amp; touch src/index.ts</p>
<p>vim src/index.ts</p>
<pre><code>    console.log(&#39;baishu test rollup:&#39;)
</code></pre>
<p>:wq</p>
<h6 id="打包构建"><a href="#打包构建" class="headerlink" title="打包构建"></a>打包构建</h6><p>vim package.json</p>
<pre><code>    &quot;scripts&quot;: &#123;
        &quot;build&quot;:&quot;rollup -c&quot;
    &#125;,
</code></pre>
<p>:wq</p>
<p>npm run build<br><img src="/images/webpack/rollup_demo_dist.png" alt="rollup_demo_dist" loading="lazy"></p>
<p>手动发布： npm publish </p>
<ul>
<li><a href="mailto:&#x62;&#x61;&#105;&#115;&#x68;&#117;&#x2d;&#112;&#x72;&#x6f;&#x74;&#x6f;&#110;&#45;&#117;&#116;&#x69;&#x6c;&#115;&#64;&#49;&#x2e;&#48;&#46;&#x31;">&#x62;&#x61;&#105;&#115;&#x68;&#117;&#x2d;&#112;&#x72;&#x6f;&#x74;&#x6f;&#110;&#45;&#117;&#116;&#x69;&#x6c;&#115;&#64;&#49;&#x2e;&#48;&#46;&#x31;</a></li>
</ul>
<h6 id="引入使用"><a href="#引入使用" class="headerlink" title="引入使用"></a>引入使用</h6><p>mkdir web_app &amp; cd web_app &amp; yarn create @umijs/umi-app<br><img src="/images/webpack/umi_demo.png" alt="umi_demo" loading="lazy"></p>
<h5 id="构建发布脚本"><a href="#构建发布脚本" class="headerlink" title="构建发布脚本"></a>构建发布脚本</h5><p>在安装使用之前，需将打包构建好的文件发布至类似npm仓库（ verdaccio搭建私有npm仓库后续文章介绍），供项目安装。<br>由于上一章节只是一个demo，则手动publish至npm仓库（源码也被推上去了，显然不稳当，如下图）<br><img src="/images/webpack/publish_manual.png" alt="publish_manual" loading="lazy"></p>
<p>解决问题：</p>
<pre><code>    1. 只发布打包后文件
    2. 发布版本号自动+1
    3. 脚本发布
</code></pre>
<h6 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h6><p>vim package.json</p>
<pre><code>    &quot;scripts&quot;: &#123;
        ...,
        &quot;copy&quot;: &quot;cp package.json dist&quot;
    &#125;,
</code></pre>
<h6 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h6><p>mkdir scripts &amp; cd scripts &amp; touch scripts/publish.js</p>
<p>npm i -D shelljs commander</p>
<p>vim package.json</p>
<pre><code>    &quot;scripts&quot;: &#123;
        ...,
        &quot;copy&quot;: &quot;cp package.json dist&quot;,
        &quot;build&quot;: &quot;rollup -c &amp;&amp; npm run copy&quot;
    &#125;,
</code></pre>
<p>vim scripts/publish.js </p>
<pre><code>    const path = require(&#39;path&#39;);
    const shelljs = require(&#39;shelljs&#39;);
    const program = require(&#39;commander&#39;);

    const targetFile = path.resolve(__dirname, &#39;../dist/package.json&#39;);
    const packagejson = require(targetFile);
    const currentVersion = packagejson.version;
    const versionArr = currentVersion.split(&#39;.&#39;);
    const [mainVersion, subVersion, phaseVersion] = versionArr;

    // 默认版本号
    const defaultVersion = `$&#123;mainVersion&#125;.$&#123;subVersion&#125;.$&#123;+phaseVersion+1&#125;`;

    let newVersion = defaultVersion;

    // 从命令行参数中取版本号
    program
    .option(&#39;-v, --versions &lt;type&gt;&#39;, &#39;Add release version number&#39;, defaultVersion);

    program.parse(process.argv);

    if (program.versions) &#123;
    newVersion = program.versions;
    &#125;

    function publish() &#123;
    shelljs.sed(&#39;-i&#39;, &#39;&quot;name&quot;: &quot;proton-utils&quot;&#39;, &#39;&quot;name&quot;: &quot;baishu-proton-utils&quot;&#39;, targetFile); // 修改包名
    shelljs.sed(&#39;-i&#39;, `&quot;version&quot;: &quot;$&#123;currentVersion&#125;&quot;`, `&quot;version&quot;: &quot;$&#123;newVersion&#125;&quot;`, targetFile); // 修改版本号
    shelljs.cd(&#39;dist&#39;);
    shelljs.exec(&#39;npm publish&#39;); // 发布
    &#125;

    publish();
</code></pre>
<h6 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h6><p>vim package.json</p>
<pre><code>    &quot;scripts&quot;: &#123;
        &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
        &quot;copy&quot;: &quot;cp package.json dist&quot;,
        &quot;build&quot;: &quot;rollup -c &amp;&amp; npm run copy&quot;,
        &quot;publish&quot;: &quot;node scripts/publish.js&quot;
    &#125;,
</code></pre>
<p>npm run publish</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>至此，我们已经完成从0 -&gt; 1的过程</p>
<p>学会了：<br>1.如何配置Rollup和TypeScript<br>2.脚本自动化发布工具库到npm仓库</p>
<p>引入包内容（仅源码 归功于publish.js）<br><img src="/images/webpack/publish_script.png" alt="publish_script" loading="lazy"></p>
<p>接下来章节中，将会仔细介绍Rollup相关内容😄</p>
<p><img src="/images/tips/1.png" alt="tip_1" loading="lazy"></p>
<h4 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h4><p><a href="https://rollupjs.org/guide/en/#big-list-of-options">Rollup文件配置项</a></p>
<h5 id="input"><a href="#input" class="headerlink" title="input"></a>input</h5><p>入口文件地址</p>
<h5 id="output"><a href="#output" class="headerlink" title="output"></a>output</h5><pre><code>    output:&#123;
        file:&#39;bundle.js&#39;, // 输出文件
        format: &#39;cjs,  //  五种输出格式：amd /  es6 / iife / umd / cjs
        name:&#39;A&#39;,  //当format为iife和umd时必须提供，将作为全局变量挂在window(浏览器环境)下：window.A=...
        sourcemap:true  //生成bundle.map.js文件，方便调试
    &#125;
</code></pre>
<h5 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h5><p>各种插件使用的配置</p>
<h5 id="external"><a href="#external" class="headerlink" title="external"></a>external</h5><p>external:[‘lodash’] //告诉rollup不要将此lodash打包，而作为外部依赖</p>
<h5 id="global"><a href="#global" class="headerlink" title="global"></a>global</h5><pre><code>    global:&#123;
        &#39;jquery&#39;:&#39;$&#39; //告诉rollup 全局变量$即是jquery
    &#125;
</code></pre>
<p><a href="https://github.com/reduxjs/react-redux/blob/master/rollup.config.js">react-redux的rollup配置</a></p>
<pre><code>    import nodeResolve from &#39;rollup-plugin-node-resolve&#39; // 帮助寻找node_modules里的包
    import babel from &#39;rollup-plugin-babel&#39; // rollup 的 babel 插件，ES6转ES5
    import replace from &#39;rollup-plugin-replace&#39; // 替换待打包文件里的一些变量，如process在浏览器端是不存在的，需要被替换
    import commonjs from &#39;rollup-plugin-commonjs&#39; // 将非ES6语法的包转为ES6可用
    import uglify from &#39;rollup-plugin-uglify&#39; // 压缩包

    const env = process.env.NODE_ENV

    const config = &#123;
    input: &#39;src/index.js&#39;,
    external: [&#39;react&#39;, &#39;redux&#39;], // 告诉rollup，不打包react,redux;将其视为外部依赖
    output: &#123; 
        format: &#39;umd&#39;, // 输出 ＵＭＤ格式，各种模块规范通用
        name: &#39;ReactRedux&#39;, // 打包后的全局变量，如浏览器端 window.ReactRedux　
        globals: &#123;
        react: &#39;React&#39;, // 这跟external 是配套使用的，指明global.React即是外部依赖react
        redux: &#39;Redux&#39;
        &#125;
    &#125;,
    plugins: [
        nodeResolve(),
        babel(&#123;
        exclude: &#39;**/node_modules/**&#39;
        &#125;),
        replace(&#123;
        &#39;process.env.NODE_ENV&#39;: JSON.stringify(env)
        &#125;),
        commonjs()
    ]
    &#125;

    if (env === &#39;production&#39;) &#123;
    config.plugins.push(
        uglify(&#123;
        compress: &#123;
            pure_getters: true,
            unsafe: true,
            unsafe_comps: true,
            warnings: false
        &#125;
        &#125;)
    )
    &#125;

    export default config
</code></pre>
<h4 id="深入使用"><a href="#深入使用" class="headerlink" title="深入使用"></a>深入使用</h4><h5 id="使用Babel"><a href="#使用Babel" class="headerlink" title="使用Babel"></a>使用Babel</h5><blockquote>
<p>为了正确解析我们的模块并使其与旧版浏览器兼容，使用babel编译输出。以便可以使用未被浏览器和 Node.js 支持的将来版本的 JavaScript特性。</p>
</blockquote>
<ol>
<li><p>npm install rollup-plugin-babel –save-dev</p>
</li>
<li><p>vim rollup.config.js</p>
<pre><code> import babel from &#39;rollup-plugin-babel&#39;
 import resolve from &#39;rollup-plugin-node-resolve&#39;;
 import commonjs from &#39;rollup-plugin-commonjs&#39;;
 import typescript from &#39;rollup-plugin-typescript&#39;;
 import pkg from &#39;./package.json&#39;;

 const extensions = [&#39;.js&#39;, &#39;.ts&#39;, &#39;.tsx&#39;, &#39;.json&#39;]

 export default &#123;
     input: &#39;src/index.ts&#39;, // 打包入口
     output: &#123; // 打包出口
         file: pkg.browser, // 最终打包出来的文件路径和文件名，这里是在package.json的browser: &#39;dist/index.js&#39;字段中配置的
         format: &#39;umd&#39;, // umd是兼容amd/cjs/iife的通用打包格式，适合浏览器
         name:&#39;proton-utils&#39; // 包的全局变量名称
     &#125;,
     plugins: [ // 打包插件
         resolve(), // 查找和打包node_modules中的第三方模块
         commonjs(), // 将 CommonJS 转换成 ES2015 模块供 Rollup 处理
         typescript(), // 解析TypeScript
         babel(&#123;
             include: &#39;src/**/*&#39;,
             exclude: &#39;**/node_modules/**&#39;,
             extensions,
         &#125;),
     ]
 &#125;;
</code></pre>
</li>
<li><p>cd src &amp; touch .babelrc &amp; vim .babelrc </p>
<pre><code> &#123;
     &quot;presets&quot;: [
         [
             &quot;@babel/env&quot;,
             &#123;
                 &quot;modules&quot;:false
             &#125;
         ]
     ]
 &#125;

 1.首先，设置 &quot;modules&quot;: false ，否则 Babel 会在 Rollup 有机会做处理之前，将我们的模块转成 CommonJS ，导致 Rollup 的一些处理失败。
 2.将 .babelrc 文件放在 src 中，而不是根目录下。 这允许我们对于不同的任务有不同的 .babelrc 配置，比如像测试，如果我们以后需要的话 - 通常为单独的任务单独配置会更好。
</code></pre>
</li>
<li><p>npm install @babel/core @babel/preset-env –save-dev</p>
</li>
<li><p>npm run build<br>打包后出来的文件内容经过babel转换后有es6语法变成了es5语法：<br><img src="/images/webpack/babel_build.png" alt="babel_build" loading="lazy"></p>
</li>
</ol>
<h5 id="node模块的引用"><a href="#node模块的引用" class="headerlink" title="node模块的引用"></a>node模块的引用</h5><p>使用rollup打包的项目有时会引用三方包（node_modules文件夹中的软件包）</p>
<blockquote>
<p>rollup.js编译源码中的模块引用默认只支持 ES6+的模块方式import/export。然而大量的npm模块是基于CommonJS模块方式，这就导致了大量 npm 模块不能直接编译使用。所以辅助rollup.js编译支持 npm模块和CommonJS模块方式的插件就应运而生。</p>
</blockquote>
<p>rollup-plugin-node-resolve ：插件允许加载第三方模块<br>rollup-plugin-commonjs ：将 CommonJS 转换成 ES2015 模块供 Rollup 处理</p>
<pre><code>    npm i -D rollup typescript tslib rollup-plugin-node-resolve rollup-plugin-commonjs
</code></pre>
<h6 id="使用三方库lodash"><a href="#使用三方库lodash" class="headerlink" title="使用三方库lodash"></a>使用三方库lodash</h6><ol>
<li><p>npm install lodash –save-dev</p>
</li>
<li><p>vim src/index.ts</p>
<pre><code> import _ from &#39;lodash&#39;

 const flatArray = (arrs:any) =&gt; &#123;
     return _.flattenDeep(arrs);
 &#125;

 const isBaishu = (name:string) =&gt; &#123;
     return name === &#39;baishu&#39;
 &#125;
 export &#123;
     isBaishu,
     flatArray
 &#125;
</code></pre>
</li>
<li><p>npm run build<br>打包后的文件多了很多内容，即ladash的代码，被打包整合进来了。<br><img src="/images/webpack/loadsh_in.png" alt="loadsh_in" loading="lazy"></p>
</li>
</ol>
<p>vim rollup.config.js</p>
<pre><code>    export default &#123;
        input:&#39;&#39;,
        output:&#123;&#125;,
        plugins:[],
        external:[&#39;lodash&#39;]
    &#125;;
</code></pre>
<h5 id="使用typescript"><a href="#使用typescript" class="headerlink" title="使用typescript"></a>使用typescript</h5><ol>
<li><p>npm i rollup-plugin-typescript –save-dev</p>
</li>
<li><p>配置rollup.config.js</p>
<pre><code> plugins: [ // 打包插件
     ...
     typescript(), // 解析TypeScript
     ...
 ],
</code></pre>
</li>
<li><p>配置tsconfig.json</p>
</li>
</ol>
<h5 id="压缩代码"><a href="#压缩代码" class="headerlink" title="压缩代码"></a>压缩代码</h5><ol>
<li><p>npm i rollup-plugin-terser –save-dev</p>
</li>
<li><p>配置rollup.config.js</p>
<pre><code> import babel from &#39;rollup-plugin-babel&#39;
 import resolve from &#39;rollup-plugin-node-resolve&#39;;
 import commonjs from &#39;rollup-plugin-commonjs&#39;;
 import typescript from &#39;rollup-plugin-typescript&#39;;
 import pkg from &#39;./package.json&#39;;
 import &#123; terser &#125; from &quot;rollup-plugin-terser&quot;;

 const extensions = [&#39;.js&#39;, &#39;.ts&#39;, &#39;.tsx&#39;, &#39;.json&#39;]

 export default &#123;
     input: &#39;src/index.ts&#39;, // 打包入口
     output: &#123; // 打包出口
         file: pkg.browser, // 最终打包出来的文件路径和文件名，这里是在package.json的browser: &#39;dist/index.js&#39;字段中配置的
         format: &#39;umd&#39;, // umd是兼容amd/cjs/iife的通用打包格式，适合浏览器
         name:&#39;proton-utils&#39; // 包的全局变量名称
     &#125;,
     plugins: [ // 打包插件
         resolve(), // 查找和打包node_modules中的第三方模块
         commonjs(), // 将 CommonJS 转换成 ES2015 模块供 Rollup 处理
         typescript(), // 解析TypeScript
         babel(&#123;
             include: &#39;src/**/*&#39;,
             exclude: &#39;**/node_modules/**&#39;,
             extensions,
         &#125;),
         terser()
     ],
     external:[&#39;lodash&#39;]
 &#125;;
</code></pre>
</li>
<li><p>npm run build<br><img src="/images/webpack/terser.png" alt="terser" loading="lazy"></p>
</li>
</ol>
<h5 id="编译css"><a href="#编译css" class="headerlink" title="编译css"></a>编译css</h5><p>一般是具体业务项目需css编译，使用webpack<br>js类库若必须使用css的话，rollup也是有插件编译css的</p>
<ol>
<li><p>npm install rollup-plugin-postcss –save-dev</p>
</li>
<li><p>配置rollup.config.js</p>
<pre><code> import babel from &#39;rollup-plugin-babel&#39;
 import resolve from &#39;rollup-plugin-node-resolve&#39;;
 import commonjs from &#39;rollup-plugin-commonjs&#39;;
 import typescript from &#39;rollup-plugin-typescript&#39;;
 import pkg from &#39;./package.json&#39;;
 import &#123; terser &#125; from &quot;rollup-plugin-terser&quot;;
 import postcss from &quot;rollup-plugin-postcss&quot;;

 const extensions = [&#39;.js&#39;, &#39;.ts&#39;, &#39;.tsx&#39;, &#39;.json&#39;]

 export default &#123;
     input: &#39;src/index.ts&#39;, // 打包入口
     output: &#123; // 打包出口
         file: pkg.browser, // 最终打包出来的文件路径和文件名，这里是在package.json的browser: &#39;dist/index.js&#39;字段中配置的
         format: &#39;umd&#39;, // umd是兼容amd/cjs/iife的通用打包格式，适合浏览器
         name:&#39;proton-utils&#39; // 包的全局变量名称
     &#125;,
     plugins: [ // 打包插件
         resolve(), // 查找和打包node_modules中的第三方模块
         commonjs(), // 将 CommonJS 转换成 ES2015 模块供 Rollup 处理
         typescript(), // 解析TypeScript
         babel(&#123;
             include: &#39;src/**/*&#39;,
             exclude: &#39;**/node_modules/**&#39;,
             extensions,
         &#125;),
         terser(),
         postcss()
     ],
     external:[&#39;lodash&#39;]
 &#125;;
</code></pre>
</li>
</ol>
<h5 id="区分开发环境和生产环境"><a href="#区分开发环境和生产环境" class="headerlink" title="区分开发环境和生产环境"></a>区分开发环境和生产环境</h5><p>在开发环境我们需要sourcemap开启，配置热更新和本地服务，在生产环境我们需要sourcemap关闭，不需要热更新和本地服务，需要代码压缩等，所以需要区分。</p>
<ol>
<li><p>rollup.config.js拆分成两个rollup.config.dev.js和rollup.config.build.js</p>
</li>
<li><p>修改 package.json 中的打包命名</p>
<pre><code> &quot;scripts&quot;: &#123;
     &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
     &quot;build&quot;: &quot;rm -rf ./dist &amp;&amp; rollup --config rollup.config.build.js &amp;&amp; npm run copy&quot;,
     &quot;dev&quot;: &quot;rm -rf ./dist &amp;&amp; rollup --config rollup.config.dev.js -w&quot;,
     &quot;copy&quot;: &quot;cp package.json README.md dist&quot;,
     &quot;publish&quot;: &quot;node scripts/publish.js&quot;,
     &quot;webpack&quot;: &quot;webpack&quot;
 &#125;,
</code></pre>
</li>
</ol>
<h5 id="开启本地服务"><a href="#开启本地服务" class="headerlink" title="开启本地服务"></a>开启本地服务</h5><ol>
<li><p>npm install rollup-plugin0dev –save-dev</p>
</li>
<li><p>配置rollup.config.dev.js</p>
<pre><code> import babel from &#39;rollup-plugin-babel&#39;
 import resolve from &#39;rollup-plugin-node-resolve&#39;;
 import commonjs from &#39;rollup-plugin-commonjs&#39;;
 import typescript from &#39;rollup-plugin-typescript&#39;;
 import pkg from &#39;./package.json&#39;;
 // import &#123; terser &#125; from &quot;rollup-plugin-terser&quot;;
 // import postcss from &quot;rollup-plugin-postcss&quot;;
 import dev from &#39;rollup-plugin-dev&#39;;

 const extensions = [&#39;.js&#39;, &#39;.ts&#39;, &#39;.tsx&#39;, &#39;.json&#39;]

 export default &#123;
     input: &#39;src/index.ts&#39;, // 打包入口
     output: &#123; // 打包出口
         file: &#39;./dist/index.js&#39;, // 最终打包出来的文件路径和文件名，这里是在package.json的browser: &#39;dist/index.js&#39;字段中配置的
         format: &#39;umd&#39;, // umd是兼容amd/cjs/iife的通用打包格式，适合浏览器
         name:&#39;proton-utils&#39; // 包的全局变量名称
     &#125;,
     plugins: [ // 打包插件
         resolve(), // 查找和打包node_modules中的第三方模块
         commonjs(), // 将 CommonJS 转换成 ES2015 模块供 Rollup 处理
         typescript(), // 解析TypeScript
         babel(&#123;
             include: &#39;src/**/*&#39;,
             exclude: &#39;**/node_modules/**&#39;,
             extensions,
         &#125;),
         // terser(),
         // postcss(),
         dev(&#123;
             port:8010,
             dirs:[&quot;dist&quot;,&#39;./&#39;],
         &#125;)
     ],
     external:[&#39;lodash&#39;],
 &#125;;
</code></pre>
</li>
<li><p>根目录创建页面<br>touch index.html &amp; vim index.html</p>
<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta http-equiv="X-UA-Compatible" content="IE=edge">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>Rollup Example</title>
</head>
<body>
 <span>baishu test</span>
 <div id="container"></div>
</body>
<script src="https://cdn.bootcdn.net/ajax/libs/lodash.js/4.17.21/lodash.core.js"></script>
<script src="./dist/index.js"></script>
<script>
 console.log(window['proton-utils'].flatArray([1,2,[3,4,[5]]]))
</script>
</html></li>
<li><p>npm run dev 生成 dist/index.js，同时可访问 8010 端口：<br><img src="/images/webpack/run_dev.png" alt="run_dev" loading="lazy"></p>
</li>
</ol>
<h5 id="开启热更新"><a href="#开启热更新" class="headerlink" title="开启热更新"></a>开启热更新</h5><ol>
<li><p>npm install rollup-plugin-livereload –save-dev</p>
</li>
<li><p>配置rollup.config.dev.js</p>
<pre><code> import babel from &#39;rollup-plugin-babel&#39;
 import resolve from &#39;rollup-plugin-node-resolve&#39;;
 import commonjs from &#39;rollup-plugin-commonjs&#39;;
 import typescript from &#39;rollup-plugin-typescript&#39;;
 import pkg from &#39;./package.json&#39;;
 // import &#123; terser &#125; from &quot;rollup-plugin-terser&quot;;
 // import postcss from &quot;rollup-plugin-postcss&quot;;
 import dev from &#39;rollup-plugin-dev&#39;;
 import livereload from &quot;rollup-plugin-livereload&quot;;

 const extensions = [&#39;.js&#39;, &#39;.ts&#39;, &#39;.tsx&#39;, &#39;.json&#39;]

 export default &#123;
     input: &#39;src/index.ts&#39;, // 打包入口
     output: &#123; // 打包出口
         file: &#39;./dist/index.js&#39;, // 最终打包出来的文件路径和文件名，这里是在package.json的browser: &#39;dist/index.js&#39;字段中配置的
         format: &#39;umd&#39;, // umd是兼容amd/cjs/iife的通用打包格式，适合浏览器
         name:&#39;proton-utils&#39; // 包的全局变量名称
     &#125;,
     plugins: [ // 打包插件
         resolve(), // 查找和打包node_modules中的第三方模块
         commonjs(), // 将 CommonJS 转换成 ES2015 模块供 Rollup 处理
         typescript(), // 解析TypeScript
         babel(&#123;
             include: &#39;src/**/*&#39;,
             exclude: &#39;**/node_modules/**&#39;,
             extensions,
         &#125;),
         // terser(),
         // postcss(),
         dev(&#123;
             port:8010,
             dirs:[&quot;dist&quot;,&#39;./&#39;],
         &#125;),
         livereload(),
     ],
     external:[&#39;lodash&#39;],
 &#125;;
</code></pre>
</li>
</ol>
<h5 id="多个输入输出文件"><a href="#多个输入输出文件" class="headerlink" title="多个输入输出文件"></a>多个输入输出文件</h5><ol>
<li>配置rollup.config.dev.js<br>import babel from ‘rollup-plugin-babel’<br>import resolve from ‘rollup-plugin-node-resolve’;<br>import commonjs from ‘rollup-plugin-commonjs’;<br>import typescript from ‘rollup-plugin-typescript’;<br>import pkg from ‘./package.json’;<br>import { terser } from “rollup-plugin-terser”;<br>// import postcss from “rollup-plugin-postcss”;</li>
</ol>
<p>const extensions = [‘.js’, ‘.ts’, ‘.tsx’, ‘.json’]</p>
<p>export default [<br>    // UMD for browser-friendly build<br>    {<br>        input: ‘src/index.ts’, // 打包入口<br>        output: { // 打包出口<br>            file: pkg.browser, // 最终打包出来的文件路径和文件名，这里是在package.json的browser: ‘dist/index.js’字段中配置的<br>            format: ‘umd’, // umd是兼容amd/cjs/iife的通用打包格式，适合浏览器<br>            name:’proton-utils’ // 包的全局变量名称<br>        },<br>        plugins: [ // 打包插件<br>            resolve(), // 查找和打包node_modules中的第三方模块<br>            commonjs(), // 将 CommonJS 转换成 ES2015 模块供 Rollup 处理<br>            typescript(), // 解析TypeScript<br>            babel({<br>                include: ‘src/<strong>/*’,<br>                exclude: ‘</strong>/node_modules/**’,<br>                extensions,<br>            }),<br>            terser()<br>            // postcss()<br>        ],<br>        external:[‘lodash’]<br>    },<br>    // CommonJS for Node and ES module for bundlers build<br>    {<br>        input: ‘src/index.ts’,<br>        plugins: [<br>            typescript()<br>        ],<br>        output: [<br>            {  file: pkg.main, format: ‘cjs’, exports: ‘auto’ },<br>            {  file: pkg.module, format: ‘es’, exports: ‘auto’ }<br>        ],<br>        external:[‘lodash’]<br>    }<br>];<br>2. npm run build<br>打包后dist目录：<br><img src="/images/webpack/paths.png" alt="paths" loading="lazy"></p>
<p>这种模式并不常见，更常见的模式是前面的一个入口文件，多个输出文件，其中输出文件的不同在于使用了不同的模块定义，比如同时输出 ES6 模块和 CommonJS 模块。</p>
<h5 id="更多插件"><a href="#更多插件" class="headerlink" title="更多插件"></a>更多插件</h5><p>参考：<a href="https://github.com/rollup/plugins">https://github.com/rollup/plugins</a></p>
]]></content>
      <categories>
        <category>Rollup</category>
      </categories>
      <tags>
        <tag>打包</tag>
        <tag>Rollup</tag>
      </tags>
  </entry>
  <entry>
    <title>手写Promise</title>
    <url>/2020/05/08/js/promise/</url>
    <content><![CDATA[<p>promise可谓是面试必问题。一个事物的出现比定有其出现的道理，换句话说，是为了解决某个问题，而诞生的。那么我们就得聊一下，promise的出现究竟解决了什么问题 - 异步编码风格。</p>
<h4 id="常见的Promise面试题"><a href="#常见的Promise面试题" class="headerlink" title="常见的Promise面试题"></a>常见的Promise面试题</h4><pre><code>1. Promise解决了什么问题
2. Promise的业界实现都有哪些
3. Promise常用的API有哪些
4. 能不能手写一个符合Promise/A+规范的Promise?
5. Promise在事件循环中的执行过程是怎样的？
6. Promise有什么缺陷，可以如何解决 - Promise 没有中断方法
7. Promise 中为什么要引入微任务？
8. Promise 中是如何实现回调函数返回值穿透的？
9. Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？
</code></pre>
<h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h4><p> Web 页面的单线程架构模型，决定了编码形式 - 异步编程。基于异步编程模型的代码会打乱关键逻辑点，不符合人的线性思维方式，代码不易读。</p>
<h5 id="异步编程的问题：代码逻辑不连续"><a href="#异步编程的问题：代码逻辑不连续" class="headerlink" title="异步编程的问题：代码逻辑不连续"></a>异步编程的问题：代码逻辑不连续</h5><pre><code>JavaScript 的异步编程模型：
  页面中任务都是执行在主线程之上的，
  相对于页面来说，主线程就是它整个的世界，
  所以在执行一项耗时的任务时（比如下载网络文件任务、获取摄像头等设备信息任务），这些任务都会放到页面主线程之外的进程或者线程中去执行，
  这样就避免了耗时任务“霸占”页面主线程的情况。
</code></pre>
<p><img src="/images/js/model.png" alt="model" loading="lazy"><br>上图展示的是一个标准的异步编程模型，页面主线程发起了一个耗时的任务，并将任务交给另外一个进程去处理，这时页面主线程会继续执行消息队列中的任务。等该进程处理完这个任务后，会将该任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。排队结束之后，循环系统会取出消息队列中的任务进行处理，并触发相关的<code>回调</code>操作。</p>
<blockquote>
<p>页面编程特点：异步回调</p>
</blockquote>
<p>Web 页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式，到底是如何影响的呢？<br>假设有一个下载的需求，使用 XMLHttpRequest 来实现，具体的实现方式你可以参考下面这段代码：</p>
<pre><code>//执行状态
function onResolve(response)&#123;console.log(response) &#125;
function onReject(error)&#123;console.log(error) &#125;

let xhr = new XMLHttpRequest()
xhr.ontimeout = function(e) &#123; onReject(e)&#125;
xhr.onerror = function(e) &#123; onReject(e) &#125;
xhr.onreadystatechange = function () &#123; onResolve(xhr.response) &#125;

//设置请求类型，请求URL，是否同步信息
let URL = &#39;https://time.geekbang.com&#39;
xhr.open(&#39;Get&#39;, URL, true);

//设置参数
xhr.timeout = 3000 //设置xhr请求的超时时间
xhr.responseType = &quot;text&quot; //设置响应返回的数据格式
xhr.setRequestHeader(&quot;X_TEST&quot;,&quot;time.geekbang&quot;)

//发出请求
xhr.send();
</code></pre>
<p>我们执行上面这段代码，可以正常输出结果的。但是，这短短的一段代码里面竟然出现了五次回调，这么多的回调会导致代码的逻辑不连贯、不线性，非常不符合人的直觉，这就是异步回调影响到我们的编码方式。那有什么方法可以解决这个问题吗？当然有，我们可以封装这堆凌乱的代码，降低处理异步回调的次数。</p>
<h5 id="封装异步代码，让处理流程变得线性"><a href="#封装异步代码，让处理流程变得线性" class="headerlink" title="封装异步代码，让处理流程变得线性"></a>封装异步代码，让处理流程变得线性</h5><p>由于我们重点关注的是输入内容（请求信息）和输出内容（回复信息），至于中间的异步请求过程，我们不想在代码里面体现太多，因为这会干扰核心的代码逻辑。整体思路如下图所示：<br><img src="/images/js/package.png" alt="package" loading="lazy"><br>从图中你可以看到，我们将 XMLHttpRequest 请求过程的代码封装起来了，重点关注输入数据和输出结果。<br>那我们就按照这个思路来改造代码。首先，我们把输入的 HTTP 请求信息全部保存到一个 request 的结构中，包括请求地址、请求头、请求方式、引用地址、同步请求还是异步请求、安全设置等信息。request 结构如下所示：</p>
<pre><code>//makeRequest用来构造request对象
function makeRequest(request_url) &#123;
    let request = &#123;
        method: &#39;Get&#39;,
        url: request_url,
        headers: &#39;&#39;,
        body: &#39;&#39;,
        credentials: false,
        sync: true,
        responseType: &#39;text&#39;,
        referrer: &#39;&#39;
    &#125;
    return request
&#125;
</code></pre>
<p>然后就可以封装请求过程了，这里我们将所有的请求细节封装进 XFetch 函数，XFetch 代码如下所示：</p>
<pre><code>//[in] request，请求信息，请求头，延时值，返回类型等
//[out] resolve, 执行成功，回调该函数
//[out] reject  执行失败，回调该函数
function XFetch(request, resolve, reject) &#123;
    let xhr = new XMLHttpRequest()
    xhr.ontimeout = function (e) &#123; reject(e) &#125;
    xhr.onerror = function (e) &#123; reject(e) &#125;
    xhr.onreadystatechange = function () &#123;
        if (xhr.status = 200)
            resolve(xhr.response)
    &#125;
    xhr.open(request.method, URL, request.sync);
    xhr.timeout = request.timeout;
    xhr.responseType = request.responseType;
    //补充其他请求信息
    //...
    xhr.send();
&#125;
</code></pre>
<p>这个 XFetch 函数需要一个 request 作为输入，然后还需要两个回调函数 <code>resolve</code> 和 <code>reject</code>，当请求成功时回调 resolve 函数，当请求出现问题时回调 reject 函数。<br>具体的实现方式如下所示：</p>
<pre><code>XFetch(makeRequest(url1),
    function resolve(data) &#123;
        console.log(data)
    &#125;, function reject(e) &#123;
        console.log(e)
    &#125;)
</code></pre>
<h5 id="新的问题：回调地狱"><a href="#新的问题：回调地狱" class="headerlink" title="新的问题：回调地狱"></a>新的问题：回调地狱</h5><p>上面的示例代码已经比较符合人的线性思维了，在一些简单的场景下运行效果也是非常好的，不过一旦接触到稍微复杂点的项目时，你就会发现，如果嵌套了太多的回调函数就很容易使得自己陷入了回调地狱，不能自拔。你可以参考下面这段让人凌乱的代码：</p>
<pre><code>XFetch(makeRequest(url1),
      function resolve(response) &#123;
          console.log(response)
          XFetch(makeRequest(url2),
              function resolve(response) &#123;
                  console.log(response)
                  XFetch(makeRequest(url3)
                      function resolve(response) &#123;
                          console.log(response)
                      &#125;, function reject(e) &#123;
                          console.log(e)
                      &#125;)
              &#125;, function reject(e) &#123;
                  console.log(e)
              &#125;)
      &#125;, function reject(e) &#123;
          console.log(e)
      &#125;)
</code></pre>
<p>这段代码之所以看上去很乱，归结其原因有两点：</p>
<pre><code> 第一是嵌套调用，下面的任务依赖上个任务的请求结果，并在上个任务的回调函数内部执行新的业务逻辑，这样当嵌套层次多了之后，代码的可读性就变得非常差了。
 第二是任务的不确定性，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。
</code></pre>
<p>解决思路</p>
<pre><code>  第一是消灭嵌套调用；
  第二是合并多个任务的错误处理。
</code></pre>
<blockquote>
<p>Promise 已经帮助我们解决了这两个问题。那么接下来我们就来看看 Promise 是怎么消灭嵌套调用和合并多个任务的错误处理的。</p>
</blockquote>
<h4 id="Promise：消灭嵌套调用和多次错误处理"><a href="#Promise：消灭嵌套调用和多次错误处理" class="headerlink" title="Promise：消灭嵌套调用和多次错误处理"></a>Promise：消灭嵌套调用和多次错误处理</h4><h5 id="Promise-来重构-XFetch-的代码"><a href="#Promise-来重构-XFetch-的代码" class="headerlink" title="Promise 来重构 XFetch 的代码"></a>Promise 来重构 XFetch 的代码</h5><pre><code>function XFetch(request) &#123;
  function executor(resolve, reject) &#123;
      let xhr = new XMLHttpRequest()
      xhr.open(&#39;GET&#39;, request.url, true)
      xhr.ontimeout = function (e) &#123; reject(e) &#125;
      xhr.onerror = function (e) &#123; reject(e) &#125;
      xhr.onreadystatechange = function () &#123;
          if (this.readyState === 4) &#123;
              if (this.status === 200) &#123;
                  resolve(this.responseText, this)
              &#125; else &#123;
                  let error = &#123;
                      code: this.status,
                      response: this.response
                  &#125;
                  reject(error, this)
              &#125;
          &#125;
      &#125;
      xhr.send()
  &#125;
  return new Promise(executor)
&#125;
</code></pre>
<h5 id="利用-XFetch-来构造请求流程"><a href="#利用-XFetch-来构造请求流程" class="headerlink" title="利用 XFetch 来构造请求流程"></a>利用 XFetch 来构造请求流程</h5><pre><code>var x1 = XFetch(makeRequest(url1))
var x2 = x1.then(value =&gt; &#123;
    console.log(value)
    return XFetch(makeRequest(url2))
&#125;)
var x3 = x2.then(value =&gt; &#123;
    console.log(value)
    return XFetch(makeRequest(url3))
&#125;)
x3.catch(error =&gt; &#123;
    console.log(error)
&#125;)

  1.首先我们引入了 Promise，在调用 XFetch 时，会返回一个 Promise 对象。
  2.构建 Promise 对象时，需要传入一个 executor 函数，XFetch 的主要业务流程都在 executor 函数中执行。
  3.如果运行在 excutor 函数中的业务执行成功了，会调用 resolve 函数；如果执行失败了，则调用 reject 函数。
  4.在 excutor 函数中调用 resolve 函数时，会触发 promise.then 设置的回调函数；而调用 reject 函数时，会触发 promise.catch 设置的回调函数。
</code></pre>
<p>以上简单介绍了 Promise 一些主要的使用方法，通过引入 Promise，上面这段代码看起来就非常线性了，也非常符合人的直觉，是不是很酷？基于这段代码，我们就可以来分析 Promise 是如何消灭嵌套回调和合并多个错误处理了。</p>
<h5 id="Promise-两步解决嵌套回调问题"><a href="#Promise-两步解决嵌套回调问题" class="headerlink" title="Promise 两步解决嵌套回调问题"></a>Promise 两步解决嵌套回调问题</h5><blockquote>
<ol>
<li>Promise 实现了回调函数的延时绑定。</li>
</ol>
</blockquote>
<p>回调函数的延时绑定在代码上体现就是先创建 Promise 对象 x1，通过 Promise 的构造函数 executor 来执行业务逻辑；创建好 Promise 对象 x1 之后，再使用 x1.then 来设置回调函数。示范代码如下：</p>
<pre><code>//创建Promise对象x1，并在executor函数中执行业务逻辑
function executor(resolve, reject)&#123;
    resolve(100)
&#125;
let x1 = new Promise(executor)


//x1延迟绑定回调函数onResolve
function onResolve(value)&#123;
    console.log(value)
&#125;
x1.then(onResolve)
</code></pre>
<blockquote>
<ol start="2">
<li>需要将回调函数 onResolve 的返回值穿透到最外层。</li>
</ol>
</blockquote>
<p>因为我们会根据 onResolve 函数的传入值来决定创建什么类型的 Promise 任务，创建好的 Promise 对象需要返回到最外层，这样就可以摆脱嵌套循环了。你可以先看下面的代码：<br><img src="/images/js/resolve.png" alt="resolve" loading="lazy"></p>
<h5 id="Promise-是怎么处理异常"><a href="#Promise-是怎么处理异常" class="headerlink" title="Promise 是怎么处理异常"></a>Promise 是怎么处理异常</h5><pre><code>function executor(resolve, reject) &#123;
    let rand = Math.random();
    console.log(1)
    console.log(rand)
    if (rand &gt; 0.5)
        resolve()
    else
        reject()
&#125;
var p0 = new Promise(executor);

var p1 = p0.then((value) =&gt; &#123;
    console.log(&quot;succeed-1&quot;)
    return new Promise(executor)
&#125;)

var p3 = p1.then((value) =&gt; &#123;
    console.log(&quot;succeed-2&quot;)
    return new Promise(executor)
&#125;)

var p4 = p3.then((value) =&gt; &#123;
    console.log(&quot;succeed-3&quot;)
    return new Promise(executor)
&#125;)

p4.catch((error) =&gt; &#123;
    console.log(&quot;error&quot;)
&#125;)
console.log(2)
</code></pre>
<p>这段代码有四个 Promise 对象：p0～p4。无论哪个对象里面抛出异常，都可以通过最后一个对象 p4.catch 来捕获异常，通过这种方式可以将所有 Promise 对象的错误合并到一个函数来处理，这样就解决了每个任务都需要单独处理异常的问题。</p>
<p>之所以可以使用最后一个对象来捕获所有异常，是因为 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了。</p>
<pre><code>Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获

promise内部有resolved_和rejected_变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断rejected参数是否为函数，若是函数，错误时使用rejected处理错误；若不是，则错误时直接throw错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听unhandledrejection事件捕获未处理的promise错误
</code></pre>
<p>通过这种方式，我们就消灭了嵌套调用和频繁的错误处理，这样使得我们写出来的代码更加优雅，更加符合人的线性思维。</p>
<h4 id="Promise-与微任务"><a href="#Promise-与微任务" class="headerlink" title="Promise 与微任务"></a>Promise 与微任务</h4><p>讲了这么多，我们似乎还没有将微任务和 Promise 关联起来，那么 Promise 和微任务的关系到底体现哪里呢？我们可以结合下面这个简单的 Promise 代码来回答这个问题：</p>
<pre><code>function executor(resolve, reject) &#123;
    resolve(100)
&#125;
let demo = new Promise(executor)

function onResolve(value)&#123;
    console.log(value)
&#125;
demo.then(onResolve)
</code></pre>
<p>对于上面这段代码，我们需要重点关注下它的执行顺序。首先执行 new Promise 时，Promise 的构造函数会被执行，不过由于 Promise 是 V8 引擎提供的，所以暂时看不到 Promise 构造函数的细节。接下来，Promise 的构造函数会调用 Promise 的参数 executor 函数。然后在 executor 中执行了 resolve，resolve 函数也是在 V8 内部实现的，那么 resolve 函数到底做了什么呢？我们知道，执行 resolve 函数，会触发 demo.then 设置的回调函数 onResolve，所以可以推测，resolve 函数内部调用了通过 demo.then 设置的 onResolve 函数。不过这里需要注意一下，由于 Promise 采用了回调函数延迟绑定技术，所以在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行。这样按顺序陈述可能把你绕晕了，下面来模拟实现一个 Promise，我们会实现它的构造函数、resolve 方法以及 then 方法，以方便你能看清楚 Promise 的背后都发生了什么。这里我们就把这个对象称为 Bromise，下面就是 Bromise 的实现代码：</p>
<pre><code>function Bromise(executor) &#123;
    var onResolve_ = null
    var onReject_ = null
    //模拟实现resolve和then，暂不支持rejcet
    this.then = function (onResolve, onReject) &#123;
        onResolve_ = onResolve
    &#125;;
    function resolve(value) &#123;
          //setTimeout(()=&gt;&#123;
            onResolve_(value)
          // &#125;,0)
    &#125;
    executor(resolve, null);
&#125;
</code></pre>
<p>观察上面这段代码，我们实现了自己的构造函数、resolve、then 方法。接下来我们使用 Bromise 来实现我们的业务代码，实现后的代码如下所示：</p>
<pre><code>function executor(resolve, reject) &#123;
    resolve(100)
&#125;
//将Promise改成我们自己的Bromsie
let demo = new Bromise(executor)

function onResolve(value)&#123;
    console.log(value)
&#125;
demo.then(onResolve)
</code></pre>
<p>执行这段代码，我们发现执行出错，输出的内容是：</p>
<pre><code>Uncaught TypeError: onResolve_ is not a function
    at resolve (&lt;anonymous&gt;:10:13)
    at executor (&lt;anonymous&gt;:17:5)
    at new Bromise (&lt;anonymous&gt;:13:5)
    at &lt;anonymous&gt;:19:12
</code></pre>
<p>之所以出现这个错误，是由于 Bromise 的延迟绑定导致的，在调用到 onResolve_ 函数的时候，Bromise.then 还没有执行，所以执行上述代码的时候，当然会报“onResolve_ is not a function“的错误了。也正是因为此，我们要改造 Bromise 中的 resolve 方法，让 resolve 延迟调用 onResolve_。要让 resolve 中的 onResolve_ 函数延后执行，可以在 resolve 函数里面加上一个定时器，让其延时执行 onResolve_ 函数，你可以参考下面改造后的代码：</p>
<pre><code>function resolve(value) &#123;
          setTimeout(()=&gt;&#123;
              onResolve_(value)
            &#125;,0)
    &#125; 
</code></pre>
<p>上面采用了定时器来推迟 onResolve 的执行，不过使用定时器的效率并不是太高，好在我们有微任务，所以 Promise 又把这个定时器改造成了微任务了，这样既可以让 onResolve_ 延时被调用，又提升了代码的执行效率。这就是 Promise 中使用微任务的原由了。</p>
<h5 id="为啥使用setTimeout-实现-promise-异步"><a href="#为啥使用setTimeout-实现-promise-异步" class="headerlink" title="为啥使用setTimeout 实现 promise 异步"></a>为啥使用setTimeout 实现 promise 异步</h5><p>由于原生的 Promise 是V8引擎提供的微任务，我们无法还原V8引擎的实现，所以这里使用 setTimeout 模拟异步，所以原生的是微任务，这里是宏任务。</p>
<p>Promise A+ 规范3.1 中也提到了：<br>    Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.<br>    这可以通过“宏任务”机制（例如setTimeout或setImmediate）或“微任务”机制（例如MutatonObserver或）来实现process.nextTick。</p>
<blockquote>
<p>如果你想实现 promise 的微任务</p>
</blockquote>
<ul>
<li>可以 mutationObserver 替代 seiTimeout 来实现微任务。</li>
<li>queueMicrotask 实现微任务（queueMicrotask 兼容性不是很好，IE 下完全不支持。queueMicrotask 的 polyfill 是基于 promise 实现的，如果不支持 promise 会转成 setTimeout。）</li>
</ul>
<p>看了以上内容，让我们来回答下：</p>
<pre><code>1、Promise 中为什么要引入微任务？

由于promise采用.then延时绑定回调机制，而new Promise时又需要直接执行promise中的方法，即发生了先执行方法后添加回调的过程，此时需等待then方法绑定两个回调后才能继续执行方法回调，便可将回调添加到当前js调用栈中执行结束后的任务队列中，由于宏任务较多容易堵塞，则采用了微任务

2、Promise 中是如何实现回调函数返回值穿透的？
首先Promise的执行结果保存在promise的data变量中，然后是.then方法返回值为使用resolved或rejected回调方法新建的一个promise对象，即例如成功则返回new Promise（resolved），将前一个promise的data值赋给新建的promise

3、Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获
promise内部有resolved_和rejected_变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断rejected参数是否为函数，若是函数，错误时使用rejected处理错误；若不是，则错误时直接throw错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听unhandledrejection事件捕获未处理的promise错误
</code></pre>
<h4 id="从0-1手写promise"><a href="#从0-1手写promise" class="headerlink" title="从0-1手写promise"></a>从0-1手写promise</h4><h5 id="Promise-A"><a href="#Promise-A" class="headerlink" title="Promise/A+"></a>Promise/A+</h5><p>  手写一个 Promise，就要遵循<a href="https://promisesaplus.com/">Promise/A+</a> 规范，业界所有 Promise 的类库都遵循这个规范。</p>
<h5 id="基础版-Promise"><a href="#基础版-Promise" class="headerlink" title="基础版 Promise"></a>基础版 Promise</h5><pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;
  console.log(&#39;create a promise&#39;);
  resolve(&#39;成功了&#39;);
&#125;)

console.log(&quot;after new promise&quot;);

const p2 = p1.then(data =&gt; &#123;
  console.log(data)
  throw new Error(&#39;失败了&#39;)
&#125;)

const p3 = p2.then(data =&gt; &#123;
  console.log(&#39;success&#39;, data)
&#125;, err =&gt; &#123;
  console.log(&#39;faild&#39;, err)
&#125;)

&quot;create a promise&quot;
&quot;after new promise&quot;
&quot;成功了&quot;
&quot;faild Error: 失败了&quot;
</code></pre>
<p>结合 Promise/A+ 规范，我们可以分析出 Promise 的基本特征：</p>
<pre><code>1.promise 有三个状态：pending，fulfilled，or rejected；「规范 Promise/A+ 2.1」
2.new promise时， 需要传递一个executor()执行器，执行器立即执行；
3.executor接受两个参数，分别是resolve和reject；
4.promise  的默认状态是 pending；
5.promise 有一个value保存成功状态的值，可以是undefined/thenable/promise；「规范 Promise/A+ 1.3」
6.promise 有一个reason保存失败状态的值；「规范 Promise/A+ 1.5」
7.promise 只能从pending到rejected, 或者从pending到fulfilled，状态一旦确认，就不会再改变；
8.promise 必须有一个then方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected；「规范 Promise/A+ 2.2」
9.如果调用 then 时，promise 已经成功，则执行onFulfilled，参数是promise的value；
10.如果调用 then 时，promise 已经失败，那么执行onRejected, 参数是promise的reason；
11.如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调onRejected；
</code></pre>
<p>按照上面的特征，我们试着勾勒下 Promise 的形状：</p>
<pre><code>// 三个状态：PENDING、FULFILLED、REJECTED
const PENDING = &#39;PENDING&#39;;
const FULFILLED = &#39;FULFILLED&#39;;
const REJECTED = &#39;REJECTED&#39;;

class Promise &#123;
  constructor(executor) &#123;
    // 默认状态为 PENDING
    this.status = PENDING;
    // 存放成功状态的值，默认为 undefined
    this.value = undefined;
    // 存放失败状态的值，默认为 undefined
    this.reason = undefined;

    // 调用此方法就是成功
    let resolve = (value) =&gt; &#123;
      // 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法
      if(this.status ===  PENDING) &#123;
        this.status = FULFILLED;
        this.value = value;
      &#125;
    &#125; 

    // 调用此方法就是失败
    let reject = (reason) =&gt; &#123;
      // 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法
      if(this.status ===  PENDING) &#123;
        this.status = REJECTED;
        this.reason = reason;
      &#125;
    &#125;

    try &#123;
      // 立即执行，将 resolve 和 reject 函数传给使用者  
      executor(resolve,reject)
    &#125; catch (error) &#123;
      // 发生异常时执行失败逻辑
      reject(error)
    &#125;
  &#125;

  // 包含一个 then 方法，并接收两个参数 onFulfilled、onRejected
  then(onFulfilled, onRejected) &#123;
    if (this.status === FULFILLED) &#123;
      onFulfilled(this.value)
    &#125;

    if (this.status === REJECTED) &#123;
      onRejected(this.reason)
    &#125;
  &#125;
&#125;
</code></pre>
<p>写完代码我们可以测试一下：<br>    同步：<br>    const promise = new Promise((resolve, reject) =&gt; {<br>      resolve(‘成功’);<br>    }).then(<br>      (data) =&gt; {<br>        console.log(‘success’, data)<br>      },<br>      (err) =&gt; {<br>        console.log(‘faild’, err)<br>      }<br>    )</p>
<pre><code>&quot;success 成功&quot;

异步：
const promise = new Promise((resolve, reject) =&gt; &#123;
  // 传入一个异步操作
  setTimeout(() =&gt; &#123;
    resolve(&#39;成功&#39;);
  &#125;,1000);
&#125;).then(
  (data) =&gt; &#123;
    console.log(&#39;success&#39;, data)
  &#125;,
  (err) =&gt; &#123;
    console.log(&#39;faild&#39;, err)
  &#125;
)

promise 没有任何返回。
</code></pre>
<ul>
<li>因为 promise 调用 then 方法时，当前的 promise 并没有成功，一直处于 pending 状态。所以如果当调用 then 方法时，当前状态是 pending，我们需要先将成功和失败的回调分别存放起来，在executor()的异步任务被执行时，触发 resolve 或 reject，依次调用成功或失败的回调。</li>
</ul>
<p>结合这个思路，我们优化一下代码：<br>    const PENDING = ‘PENDING’;<br>    const FULFILLED = ‘FULFILLED’;<br>    const REJECTED = ‘REJECTED’;</p>
<pre><code>class Promise &#123;
  constructor(executor) &#123;
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    // 存放成功的回调
    this.onResolvedCallbacks = [];
    // 存放失败的回调
    this.onRejectedCallbacks= [];

    let resolve = (value) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = FULFILLED;
        this.value = value;
        // 依次将对应的函数执行
        this.onResolvedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125; 

    let reject = (reason) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = REJECTED;
        this.reason = reason;
        // 依次将对应的函数执行
        this.onRejectedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125;

    try &#123;
      executor(resolve,reject)
    &#125; catch (error) &#123;
      reject(error)
    &#125;
  &#125;

  then(onFulfilled, onRejected) &#123;
    if (this.status === FULFILLED) &#123;
      onFulfilled(this.value)
    &#125;

    if (this.status === REJECTED) &#123;
      onRejected(this.reason)
    &#125;

    if (this.status === PENDING) &#123;
      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onResolvedCallbacks.push(() =&gt; &#123;
        onFulfilled(this.value)
      &#125;);

      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onRejectedCallbacks.push(()=&gt; &#123;
        onRejected(this.reason);
      &#125;)
    &#125;
  &#125;
&#125;
</code></pre>
<p>测试一下：</p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&#39;成功&#39;);
  &#125;,1000);
&#125;).then(
  (data) =&gt; &#123;
    console.log(&#39;success&#39;, data)
  &#125;,
  (err) =&gt; &#123;
    console.log(&#39;faild&#39;, err)
  &#125;
)

1s后输出：&quot;success 成功&quot;
</code></pre>
<p>这其实是一个发布订阅模式，这种收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行的方式，被广泛运用于发布订阅模式的实现。</p>
<h5 id="then-的链式调用-amp-值穿透特性"><a href="#then-的链式调用-amp-值穿透特性" class="headerlink" title="then 的链式调用&amp;值穿透特性"></a>then 的链式调用&amp;值穿透特性</h5><p>依据<a href="https://promisesaplus.com/">Promise/A+</a>  规范梳理一下思路</p>
<pre><code>1.then 的参数 onFulfilled 和 onRejected 可以缺省，如果 onFulfilled 或者 onRejected不是函数，将其忽略，且依旧可以在下面的 then 中获取到之前返回的值；「规范 Promise/A+ 2.2.1、2.2.1.1、2.2.1.2」
2.promise 可以 then 多次，每次执行完 promise.then 方法后返回的都是一个“新的promise&quot;；「规范 Promise/A+ 2.2.7」
3.如果 then 的返回值 x 是一个普通值，那么就会把这个结果作为参数，传递给下一个 then 的成功的回调中；
4.如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调中；「规范 Promise/A+ 2.2.7.2」
5.如果 then 的返回值 x 是一个 promise，那么会等这个 promise 执行完，promise 如果成功，就走下一个 then 的成功；如果失败，就走下一个 then 的失败；如果抛出异常，就走下一个 then 的失败；「规范 Promise/A+ 2.2.7.3、2.2.7.4」
6.如果 then 的返回值 x 和 promise 是同一个引用对象，造成循环引用，则抛出异常，把异常传递给下一个 then 的失败的回调中；「规范 Promise/A+ 2.3.1」
7.如果 then 的返回值 x 是一个 promise，且 x 同时调用 resolve 函数和 reject 函数，则第一次调用优先，其他所有调用被忽略；「规范 Promise/A+ 2.3.3.3.3」
</code></pre>
<p>我们将代码补充完整：</p>
<pre><code>const PENDING = &#39;PENDING&#39;;
const FULFILLED = &#39;FULFILLED&#39;;
const REJECTED = &#39;REJECTED&#39;;

const resolvePromise = (promise2, x, resolve, reject) =&gt; &#123;
  // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1
  if (promise2 === x) &#123; 
    return reject(new TypeError(&#39;Chaining cycle detected for promise #&lt;Promise&gt;&#39;))
  &#125;
  // Promise/A+ 2.3.3.3.3 只能调用一次
  let called;
  // 后续的条件要严格判断 保证代码能和别的库一起使用
  if ((typeof x === &#39;object&#39; &amp;&amp; x != null) || typeof x === &#39;function&#39;) &#123; 
    try &#123;
      // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1
      let then = x.then;
      if (typeof then === &#39;function&#39;) &#123; 
        // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3
        then.call(x, y =&gt; &#123; // 根据 promise 的状态决定是成功还是失败
          if (called) return;
          called = true;
          // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1
          resolvePromise(promise2, y, resolve, reject); 
        &#125;, r =&gt; &#123;
          // 只要失败就失败 Promise/A+ 2.3.3.3.2
          if (called) return;
          called = true;
          reject(r);
        &#125;);
      &#125; else &#123;
        // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4
        resolve(x);
      &#125;
    &#125; catch (e) &#123;
      // Promise/A+ 2.3.3.2
      if (called) return;
      called = true;
      reject(e)
    &#125;
  &#125; else &#123;
    // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4  
    resolve(x)
  &#125;
&#125;

class Promise &#123;
  constructor(executor) &#123;
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks= [];

    let resolve = (value) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125; 

    let reject = (reason) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125;

    try &#123;
      executor(resolve,reject)
    &#125; catch (error) &#123;
      reject(error)
    &#125;
  &#125;

  then(onFulfilled, onRejected) &#123;
    //解决 onFufilled，onRejected 没有传值的问题
    //Promise/A+ 2.2.1 / Promise/A+ 2.2.5 / Promise/A+ 2.2.7.3 / Promise/A+ 2.2.7.4
    onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : v =&gt; v;
    //因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获
    onRejected = typeof onRejected === &#39;function&#39; ? onRejected : err =&gt; &#123; throw err &#125;;
    // 每次调用 then 都返回一个新的 promise  Promise/A+ 2.2.7
    let promise2 = new Promise((resolve, reject) =&gt; &#123;
      if (this.status === FULFILLED) &#123;
        //Promise/A+ 2.2.2
        //Promise/A+ 2.2.4 --- setTimeout
        setTimeout(() =&gt; &#123;
          try &#123;
            //Promise/A+ 2.2.7.1
            let x = onFulfilled(this.value);
            // x可能是一个proimise
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            //Promise/A+ 2.2.7.2
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === REJECTED) &#123;
        //Promise/A+ 2.2.3
        setTimeout(() =&gt; &#123;
          try &#123;
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === PENDING) &#123;
        this.onResolvedCallbacks.push(() =&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);

        this.onRejectedCallbacks.push(()=&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject)
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);
      &#125;
    &#125;);
  
    return promise2;
  &#125;
&#125;
</code></pre>
<p>测试一下：</p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  reject(&#39;失败&#39;);
&#125;).then().then().then(data=&gt;&#123;
  console.log(data);
&#125;,err=&gt;&#123;
  console.log(&#39;err&#39;,err);
&#125;)

输出：&quot;失败 err&quot;
</code></pre>
<h4 id="Promise-的-API"><a href="#Promise-的-API" class="headerlink" title="Promise 的 API"></a>Promise 的 API</h4><p>虽然上述的 promise 源码已经符合 Promise/A+ 的规范，但是原生的 Promise 还提供了一些其他方法，如:</p>
<pre><code>Promise.resolve()
Promise.reject()
Promise.prototype.catch()
Promise.prototype.finally()
Promise.all()
Promise.race(）
</code></pre>
<h5 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h5><pre><code>static resolve(data)&#123;
  return new Promise((resolve,reject)=&gt;&#123;
    resolve(data);
  &#125;)
&#125;
</code></pre>
<h5 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h5><p>默认产生一个失败的 promise，Promise.reject 是直接将值变成错误结果。</p>
<pre><code>static reject(reason)&#123;
  return new Promise((resolve,reject)=&gt;&#123;
    reject(reason);
  &#125;)
&#125;
</code></pre>
<h5 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h5><p>Promise.prototype.catch 用来捕获 promise 的异常，就相当于一个没有成功的 then。</p>
<pre><code>Promise.prototype.catch = function(errCallback)&#123;
  return this.then(null,errCallback)
&#125;
</code></pre>
<h5 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h5><p>finally 表示不是最终的意思，而是无论如何都会执行的意思。<br>如果返回一个 promise 会等待这个 promise 也执行完毕。如果返回的是成功的 promise，会采用上一次的结果；如果返回的是失败的 promise，会用这个失败的结果，传到 catch 中。</p>
<pre><code>Promise.prototype.finally = function(callback) &#123;
  return this.then((value)=&gt;&#123;
    return Promise.resolve(callback()).then(()=&gt;value)
  &#125;,(reason)=&gt;&#123;
    return Promise.resolve(callback()).then(()=&gt;&#123;throw reason&#125;)
  &#125;)  
&#125;
</code></pre>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h5><p>promise.all 是解决并发问题的，多个异步并发获取最终的结果（如果有一个失败则失败）。</p>
<pre><code>Promise.all = function(values) &#123;
  if (!Array.isArray(values)) &#123;
    const type = typeof values;
    return new TypeError(`TypeError: $&#123;type&#125; $&#123;values&#125; is not iterable`)
  &#125;
  
  return new Promise((resolve, reject) =&gt; &#123;
    let resultArr = [];
    let orderIndex = 0;
    const processResultByKey = (value, index) =&gt; &#123;
      resultArr[index] = value;
      if (++orderIndex === values.length) &#123;
          resolve(resultArr)
      &#125;
    &#125;
    for (let i = 0; i &lt; values.length; i++) &#123;
      let value = values[i];
      if (value &amp;&amp; typeof value.then === &#39;function&#39;) &#123;
        value.then((value) =&gt; &#123;
          processResultByKey(value, i);
        &#125;, reject);
      &#125; else &#123;
        processResultByKey(value, i);
      &#125;
    &#125;
  &#125;);
&#125;
</code></pre>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h5><p>Promise.race 用来处理多个请求，采用最快的（谁先完成用谁的）。</p>
<pre><code>Promise.race = function(promises) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    // 一起执行就是for循环
    for (let i = 0; i &lt; promises.length; i++) &#123;
      let val = promises[i];
      if (val &amp;&amp; typeof val.then === &#39;function&#39;) &#123;
        val.then(resolve, reject);
      &#125; else &#123; // 普通值
        resolve(val)
      &#125;
    &#125;
  &#125;);
&#125;
</code></pre>
<blockquote>
<p>特别需要注意的是：因为Promise 是没有中断方法的，xhr.abort()、ajax 有自己的中断方法，axios 是基于 ajax 实现的；fetch 基于 promise，所以他的请求是无法中断的。</p>
</blockquote>
<p>这也是 promise 存在的缺陷，我们可以使用 race 来自己封装中断方法：</p>
<pre><code>function wrap(promise) &#123;
  // 在这里包装一个 promise，可以控制原来的promise是成功还是失败
  let abort;
  let newPromise = new Promise((resolve, reject) =&gt; &#123; // defer 方法
      abort = reject;
  &#125;);
  let p = Promise.race([promise, newPromise]); // 任何一个先成功或者失败 就可以获取到结果
  p.abort = abort;
  return p;
&#125;

const promise = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123; // 模拟的接口调用 ajax 肯定有超时设置
      resolve(&#39;成功&#39;);
  &#125;, 1000);
&#125;);

let newPromise = wrap(promise);

setTimeout(() =&gt; &#123;
  // 超过3秒 就算超时 应该让 proimise 走到失败态
  newPromise.abort(&#39;超时了&#39;);
&#125;, 3000);

newPromise.then((data =&gt; &#123;
    console.log(&#39;成功的结果&#39; + data)
&#125;)).catch(e =&gt; &#123;
    console.log(&#39;失败的结果&#39; + e)
&#125;)

1s后输出：&quot;成功的结果成功&quot;
</code></pre>
<h4 id="1-Promise"><a href="#1-Promise" class="headerlink" title="1 - Promise"></a>1 - Promise</h4><pre><code>const PENDING = &#39;PENDING&#39;;
const FULFILLED = &#39;FULFILLED&#39;;
const REJECTED = &#39;REJECTED&#39;;

const resolvePromise = (promise2, x, resolve, reject) =&gt; &#123;
  if (promise2 === x) &#123; 
    return reject(new TypeError(&#39;Chaining cycle detected for promise #&lt;Promise&gt;&#39;))
  &#125;
  let called;
  if ((typeof x === &#39;object&#39; &amp;&amp; x != null) || typeof x === &#39;function&#39;) &#123; 
    try &#123;
      let then = x.then;
      if (typeof then === &#39;function&#39;) &#123; 
        then.call(x, y =&gt; &#123; 
          if (called) return;
          called = true;
          resolvePromise(promise2, y, resolve, reject); 
        &#125;, r =&gt; &#123;
          if (called) return;
          called = true;
          reject(r);
        &#125;);
      &#125; else &#123;
        resolve(x);
      &#125;
    &#125; catch (e) &#123;
      if (called) return;
      called = true;
      reject(e)
    &#125;
  &#125; else &#123;
    resolve(x)
  &#125;
&#125;

class Promise &#123;
  constructor(executor) &#123;
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks= [];

    let resolve = (value) =&gt; &#123;
      if(value instanceof Promise)&#123;
        return value.then(resolve,reject)
      &#125;

      if(this.status ===  PENDING) &#123;
        this.status = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125; 

    let reject = (reason) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125;

    try &#123;
      executor(resolve,reject)
    &#125; catch (error) &#123;
      reject(error)
    &#125;
  &#125;

  then(onFulfilled, onRejected) &#123;
    onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : v =&gt; v;
    onRejected = typeof onRejected === &#39;function&#39; ? onRejected : err =&gt; &#123; throw err &#125;;
    let promise2 = new Promise((resolve, reject) =&gt; &#123;
      if (this.status === FULFILLED) &#123;
        setTimeout(() =&gt; &#123;
          try &#123;
            let x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === REJECTED) &#123;
        setTimeout(() =&gt; &#123;
          try &#123;
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === PENDING) &#123;
        this.onResolvedCallbacks.push(() =&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);

        this.onRejectedCallbacks.push(()=&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject)
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);
      &#125;
    &#125;);
  
    return promise2;
  &#125;

  catch(errCallback) &#123;
    return this.then(null,errCallback)
  &#125;

  finally(callback) &#123;
    return this.then((value)=&gt;&#123;
      return Promise.resolve(callback()).then(()=&gt;value)
    &#125;,(reason)=&gt;&#123;
      return Promise.resolve(callback()).then(()=&gt;&#123;throw reason&#125;)
    &#125;)  
  &#125;

  static resolve(data)&#123;
    return new Promise((resolve,reject)=&gt;&#123;
      resolve(data);
    &#125;)
  &#125;

  static reject(reason)&#123;
    return new Promise((resolve,reject)=&gt;&#123;
      reject(reason);
    &#125;)
  &#125; 

  static all(values) &#123;
    if (!Array.isArray(values)) &#123;
      const type = typeof values;
      return new TypeError(`TypeError: $&#123;type&#125; $&#123;values&#125; is not iterable`)
    &#125;

    return new Promise((resolve, reject) =&gt; &#123;
      let resultArr = [];
      let orderIndex = 0;
      const processResultByKey = (value, index) =&gt; &#123;
        resultArr[index] = value;
        if (++orderIndex === values.length) &#123;
            resolve(resultArr)
        &#125;
      &#125;
      for (let i = 0; i &lt; values.length; i++) &#123;
        let value = values[i];
        if (value &amp;&amp; typeof value.then === &#39;function&#39;) &#123;
          value.then((value) =&gt; &#123;
            processResultByKey(value, i);
          &#125;, reject);
        &#125; else &#123;
          processResultByKey(value, i);
        &#125;
      &#125;
    &#125;);
  &#125;

  static race(promises) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
      for (let i = 0; i &lt; promises.length; i++) &#123;
        let val = promises[i];
        if (val &amp;&amp; typeof val.then === &#39;function&#39;) &#123;
          val.then(resolve, reject);
        &#125; else &#123;
          resolve(val)
        &#125;
      &#125;
    &#125;);
  &#125;
&#125;



Promise.defer = Promise.deferred = function () &#123;
  let dtd = &#123;&#125;
  dtd.promise = new Promise((resolve, reject) =&gt; &#123;
    dtd.resolve = resolve;
    dtd.reject = reject;
  &#125;)
  return dtd;
&#125;

module.exports = Promise
</code></pre>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql的使用</title>
    <url>/2019/04/06/mysql/use/</url>
    <content><![CDATA[<h4 id="数据库概述"><a href="#数据库概述" class="headerlink" title="数据库概述"></a>数据库概述</h4><h5 id="sql、DB、DBMS分别是什么，他们之间的关系"><a href="#sql、DB、DBMS分别是什么，他们之间的关系" class="headerlink" title="sql、DB、DBMS分别是什么，他们之间的关系"></a><font color="#f2711c">sql、DB、DBMS分别是什么，他们之间的关系</font></h5><ul>
<li>DB：DataBase（数据库，数据库实际上在硬盘上以文件的形式存在）</li>
<li>DBMS：DataBase Management System（数据库管理系统，常见的有：Oracle、SQL Server、MySql、Sybase、informix、DB2、interbase、PostgreSql）</li>
<li>SQL：结构化查询语言，是一门标准通用的语言。标准的sql适合于所有的数据库产品。SQL属于高级语言。SQL语句在执行的时候，实际上内部也会先进行编译，然后再执行sql。（sql语句的编译由DBMS完成）<br>DBMS负责执行sql语句，通过执行sql语句来操作DB当中的数据。 </li>
</ul>
<h5 id="什么是表"><a href="#什么是表" class="headerlink" title="什么是表"></a><font color="#f2711c">什么是表</font></h5><ul>
<li>表： table</li>
<li>表：table是数据库的基本组成单元，所有的数据都以表格的形式组织，目的是可读性强。</li>
<li>一个表包括行和列：</li>
<li>行：被称为数据/记录（data）</li>
<li>列：被称为字段（column）</li>
</ul>
<table>
<thead>
<tr>
<th>学号（int）</th>
<th>姓名（varchar）</th>
<th>年龄</th>
</tr>
</thead>
<tbody><tr>
<td>110</td>
<td>张三</td>
<td>20</td>
</tr>
<tr>
<td>120</td>
<td>李四</td>
<td>21</td>
</tr>
</tbody></table>
<p> 每一个字段应该包括哪些属性？<br> 字段名、数据类型、字段约束/字段长度<br> 字段约束/字段长度</p>
<h5 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a><font color="#f2711c">SQL分类</font></h5><ul>
<li>数据查询语言(DQL-Data Query Language)<br>代表关键字:select </li>
<li>数据操纵语言(DML-Data Manipulation Language)<br>代表关键字:insert,delete,update </li>
<li>数据定义语言(DDL-Data Definition Language)<br>代表关键字:create ,drop,alter,</li>
<li>事务控制语言(TCL-Transactional Control Language)<br>代表关键字:commit ,rollback;</li>
<li>数据控制语言(DCL-Data Control Language)<br>代表关键字:grant,revoke.</li>
</ul>
<h5 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a><font color="#f2711c">导入数据</font></h5><ul>
<li><p>第一步：登录mysql数据库管理系统<br>命令窗口：</p>
<blockquote>
<p>mysql -uroot -p</p>
</blockquote>
</li>
<li><p>第二步：查看有哪些数据库</p>
<blockquote>
<p>show databases;<br>(这个不是SQL语句，属于Mysql的命令)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| algorithm_box      |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>第三步：创建数据库</p>
<blockquote>
<p>create database baishu_demo;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database baishu_demo;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| algorithm_box      |</span><br><span class="line">| baishu_demo        |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>第四步：使用baishu_demo数据</p>
<blockquote>
<p>use baishu_demo;</p>
</blockquote>
</li>
<li><p>第五步：查看当前使用的数据中有哪些表？</p>
<blockquote>
<p>show tables;</p>
</blockquote>
</li>
<li><p>第六步：初始化数据</p>
<blockquote>
<p>source ~/sql/baishu_demo.sql;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+-----------------------+</span><br><span class="line">| Tables_in_baishu_demo |</span><br><span class="line">+-----------------------+</span><br><span class="line">| DEPT                  |</span><br><span class="line">| EMP                   |</span><br><span class="line">| SALGRADE              |</span><br><span class="line">+-----------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="什么是sql脚本？"><a href="#什么是sql脚本？" class="headerlink" title="什么是sql脚本？"></a><font color="#f2711c">什么是sql脚本？</font></h5><ul>
<li>当一个文件的扩展名是.sql，并且该文件中编写了大量的sql语句，我们称这样的文件为sql脚本。<br>sql脚本中的数据量太大的时候，无法打开，请使用source命令完成初始化。</li>
</ul>
<h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a><font color="#f2711c">删除数据库</font></h5><blockquote>
<p>drop database baishu_demo;</p>
</blockquote>
<h5 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a><font color="#f2711c">查看表结构</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">| Tables_in_baishu_demo |</span><br><span class="line">+-----------------------+</span><br><span class="line">| DEPT                  | （部门表）</span><br><span class="line">| EMP                   | （员工表）</span><br><span class="line">| SALGRADE              | （工资等级表）</span><br><span class="line">+-----------------------+</span><br><span class="line"></span><br><span class="line">mysql&gt; desc DEPT;</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">| DEPTNO | int(2)      | NO   | PRI | NULL    |       | 部门编号</span><br><span class="line">| DNAME  | varchar(14) | YES  |     | NULL    |       | 部门名称</span><br><span class="line">| LOC    | varchar(13) | YES  |     | NULL    |       | 部门位置</span><br><span class="line">+--------+-------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc EMP;</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field    | Type        | Null | Key | Default | Extra |</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">| EMPNO    | int(4)      | NO   | PRI | NULL    |       | 员工编号</span><br><span class="line">| ENAME    | varchar(10) | YES  |     | NULL    |       | 员工姓名</span><br><span class="line">| JOB      | varchar(9)  | YES  |     | NULL    |       | 工作岗位</span><br><span class="line">| MGR      | int(4)      | YES  |     | NULL    |       | 上级领导编号</span><br><span class="line">| HIREDATE | date        | YES  |     | NULL    |       | 入职时间</span><br><span class="line">| SAL      | double(7,2) | YES  |     | NULL    |       | 月薪</span><br><span class="line">| COMM     | double(7,2) | YES  |     | NULL    |       | 补助/津贴</span><br><span class="line">| DEPTNO   | int(2)      | YES  |     | NULL    |       | 部门编号</span><br><span class="line">+----------+-------------+------+-----+---------+-------+</span><br><span class="line">8 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc SALGRADE;</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| Field | Type    | Null | Key | Default | Extra |</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">| GRADE | int(11) | YES  |     | NULL    |       | 等级</span><br><span class="line">| LOSAL | int(11) | YES  |     | NULL    |       | 最低薪资</span><br><span class="line">| HISAL | int(11) | YES  |     | NULL    |       | 最高薪资</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from EMP;</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><h5 id="查看mysql版本"><a href="#查看mysql版本" class="headerlink" title="查看mysql版本"></a><font color="#f2711c">查看mysql版本</font></h5><blockquote>
<p>mysql -V<br>mysql –version</p>
</blockquote>
<h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a><font color="#f2711c">创建数据库</font></h5><blockquote>
<p>1.create database 数据库名称;<br>create database baishu_demo;<br>2.use 数据库名称<br>use baishu_demo;<br>在数据库中建立表，因此创建表的时候必须要先选择数据库。</p>
</blockquote>
<h5 id="查询当前使用的数据库"><a href="#查询当前使用的数据库" class="headerlink" title="查询当前使用的数据库"></a><font color="#f2711c">查询当前使用的数据库</font></h5><blockquote>
<p>select  database();<br>查询数据库版本也可以使用<br>select  version();</p>
</blockquote>
<h5 id="终止一条语句"><a href="#终止一条语句" class="headerlink" title="终止一条语句"></a><font color="#f2711c">终止一条语句</font></h5><p>如果想要终止一条正在编写的语句，可键入\c。</p>
<h5 id="退出mysql"><a href="#退出mysql" class="headerlink" title="退出mysql"></a><font color="#f2711c">退出mysql</font></h5><p>可使用\q、QUIT或EXIT</p>
<h5 id="查看建表语句"><a href="#查看建表语句" class="headerlink" title="查看建表语句"></a><font color="#f2711c">查看建表语句</font></h5><blockquote>
<p>show create table table name;</p>
</blockquote>
<h4 id="简单的查询"><a href="#简单的查询" class="headerlink" title="简单的查询"></a>简单的查询</h4><p>语法格式:select 字段名1,字段名2,字段名3,…from 表名;</p>
<blockquote>
<p>提示：<br>1.任何一条sql语句以“；”结尾。<br>2.sql语句不区分大小写。</p>
</blockquote>
<h5 id="查询一个字段"><a href="#查询一个字段" class="headerlink" title="查询一个字段"></a><font color="#f2711c">查询一个字段</font></h5><blockquote>
<p>select ename from EMP;</p>
</blockquote>
<p>Select语句后面跟的是字段名称，select是关键字，select和字段名称之间采用空格隔开，from表示将要查询的表，它和字段之间采用空格隔开</p>
<h5 id="查询多个字段"><a href="#查询多个字段" class="headerlink" title="查询多个字段"></a><font color="#f2711c">查询多个字段</font></h5><blockquote>
<p>select empnp, ename from EMP;</p>
</blockquote>
<p>查询多个字段，select中的字段采用逗号间隔即可，最后一个字段，也就是在from前面的字段不能使用逗号了。</p>
<h5 id="查询全部字段"><a href="#查询全部字段" class="headerlink" title="查询全部字段"></a><font color="#f2711c">查询全部字段</font></h5><blockquote>
<p>select * from EMP;</p>
</blockquote>
<p>采用select * from emp，虽然简单，但是*号不是很明确，建议查询全部字段将相关字段写到select语句的后面,在以后java连接数据库的时候,是需要在java程序中编写SQL语句的,这个时候编写的SQL语句不建议使用select *  这种形式,建议写明字段,这样可读性强.</p>
<h5 id="计算员工的年薪"><a href="#计算员工的年薪" class="headerlink" title="计算员工的年薪"></a><font color="#f2711c">计算员工的年薪</font></h5><p>列出员工的编号，姓名和年薪</p>
<blockquote>
<p>select empno, ename, sal*12 from EMP;</p>
</blockquote>
<h5 id="将查询出来的字段显示为中文"><a href="#将查询出来的字段显示为中文" class="headerlink" title="将查询出来的字段显示为中文"></a><font color="#f2711c">将查询出来的字段显示为中文</font></h5><blockquote>
<p>select empno as ‘员工编号’, ename as ‘员工姓名’, sal*12 as ‘年薪’ from EMP;</p>
</blockquote>
<p>注意:字符串必须添加单引号 | 双引号</p>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><p>语法格式：</p>
<blockquote>
<p>select<br>  字段，字段…<br>from<br>  表名<br>where<br>  条件<br>执行顺序：先from，然后where，最后select</p>
</blockquote>
<ol>
<li><p>找出工资高于3000的员工<br>select ename,sal from EMP where sal &gt;= 3000;</p>
</li>
<li><p>查询SMITH的工资<br>select sal from EMP where ename = ‘SMITH’</p>
</li>
<li><p>找出工资在1100和3000之间的员工<br>select ename from EMP where sal between 1100 and 3000 (between and 是闭区间)</p>
</li>
</ol>
<p>支持如下运算符：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于</td>
</tr>
<tr>
<td>&lt;&gt; 或 !=</td>
<td>不等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>between…and…</td>
<td>大于等于，等同&gt;= and &lt;=</td>
</tr>
<tr>
<td>is null</td>
<td>为null(is not null 不为空)</td>
</tr>
<tr>
<td>and</td>
<td>并且</td>
</tr>
<tr>
<td>or</td>
<td>或者</td>
</tr>
<tr>
<td>in</td>
<td>包含，相当于多个or(not in 不在这个范围中)</td>
</tr>
<tr>
<td>not</td>
<td>not 可以取非，主要用在is 或 in 中</td>
</tr>
<tr>
<td>like</td>
<td>like称为模糊查询，支持%或下划线匹配；%匹配任意个字符，下划线，一个下滑下只匹配一个字符</td>
</tr>
</tbody></table>
<h5 id="等号操作符"><a href="#等号操作符" class="headerlink" title="等号操作符"></a><font color="#f2711c">等号操作符</font></h5><ul>
<li>查询job为MANAGER的员工<blockquote>
<p>select empno,ename,job from EMP where job = ‘manager’</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select empno,ename,job from EMP where job = &#x27;manager&#x27;;</span><br><span class="line">+-------+-------+---------+</span><br><span class="line">| empno | ename | job     |</span><br><span class="line">+-------+-------+---------+</span><br><span class="line">|  7566 | JONES | MANAGER |</span><br><span class="line">|  7698 | BLAKE | MANAGER |</span><br><span class="line">|  7782 | CLARK | MANAGER |</span><br><span class="line">+-------+-------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h5 id="lt-gt-操作符"><a href="#lt-gt-操作符" class="headerlink" title="&lt;&gt;操作符"></a><font color="#f2711c">&lt;&gt;操作符</font></h5></li>
<li>查询薪水不等于5000的员工<blockquote>
<p>select empno,ename,sal from EMP where sal&lt;&gt;5000;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. mysql&gt; select empno,ename,sal from EMP where sal&lt;&gt;5000;</span><br><span class="line">+-------+--------+---------+</span><br><span class="line">| empno | ename  | sal     |</span><br><span class="line">+-------+--------+---------+</span><br><span class="line">|  7369 | SMITH  |  800.00 |</span><br><span class="line">|  7499 | ALLEN  | 1600.00 |</span><br><span class="line">|  7521 | WARD   | 1250.00 |</span><br><span class="line">|  7566 | JONES  | 2975.00 |</span><br><span class="line">|  7654 | MARTIN | 1250.00 |</span><br><span class="line">|  7698 | BLAKE  | 2850.00 |</span><br><span class="line">|  7782 | CLARK  | 2450.00 |</span><br><span class="line">|  7788 | SCOTT  | 3000.00 |</span><br><span class="line">|  7844 | TURNER | 1500.00 |</span><br><span class="line">|  7876 | ADAMS  | 1100.00 |</span><br><span class="line">|  7900 | JAMES  |  950.00 |</span><br><span class="line">|  7902 | FORD   | 3000.00 |</span><br><span class="line">|  7934 | MILLER | 1300.00 |</span><br><span class="line">+-------+--------+---------+</span><br><span class="line">13 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2. mysql&gt; select empno, ename, sal from EMP where sal != 5000;</span><br><span class="line">+-------+--------+---------+</span><br><span class="line">| empno | ename  | sal     |</span><br><span class="line">+-------+--------+---------+</span><br><span class="line">|  7369 | SMITH  |  800.00 |</span><br><span class="line">|  7499 | ALLEN  | 1600.00 |</span><br><span class="line">|  7521 | WARD   | 1250.00 |</span><br><span class="line">|  7566 | JONES  | 2975.00 |</span><br><span class="line">|  7654 | MARTIN | 1250.00 |</span><br><span class="line">|  7698 | BLAKE  | 2850.00 |</span><br><span class="line">|  7782 | CLARK  | 2450.00 |</span><br><span class="line">|  7788 | SCOTT  | 3000.00 |</span><br><span class="line">|  7844 | TURNER | 1500.00 |</span><br><span class="line">|  7876 | ADAMS  | 1100.00 |</span><br><span class="line">|  7900 | JAMES  |  950.00 |</span><br><span class="line">|  7902 | FORD   | 3000.00 |</span><br><span class="line">|  7934 | MILLER | 1300.00 |</span><br><span class="line">+-------+--------+---------+</span><br><span class="line">13 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="between-…-and-…操作符"><a href="#between-…-and-…操作符" class="headerlink" title="between … and …操作符"></a><font color="#f2711c">between … and …操作符</font></h5><ul>
<li>查询薪水为1600到3000的员工(第一种方式，采用&gt;=和&lt;=)<blockquote>
<p>select empno, ename, sal from EMP where sal between 1600 and 3000;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select empno, ename, sal from EMP where sal between 1600 and 3000;</span><br><span class="line">+-------+-------+---------+</span><br><span class="line">| empno | ename | sal     |</span><br><span class="line">+-------+-------+---------+</span><br><span class="line">|  7499 | ALLEN | 1600.00 |</span><br><span class="line">|  7566 | JONES | 2975.00 |</span><br><span class="line">|  7698 | BLAKE | 2850.00 |</span><br><span class="line">|  7782 | CLARK | 2450.00 |</span><br><span class="line">|  7788 | SCOTT | 3000.00 |</span><br><span class="line">|  7902 | FORD  | 3000.00 |</span><br><span class="line">+-------+-------+---------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="is-null"><a href="#is-null" class="headerlink" title="is null"></a><font color="#f2711c">is null</font></h5><p>Null为空，但不是空串，为null可以设置这个字段不填值，如果查询为null的字段，采用 is null</p>
<ul>
<li>查询津贴为空的员工<blockquote>
<p>select * from EMP where comm=null;<br>mysql&gt; select * from EMP where COMM is null;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP where comm=null;</span><br><span class="line">Empty set (0.00 sec)</span><br><span class="line">mysql&gt; select * from EMP where COMM is null;</span><br><span class="line">+-------+--------+-----------+------+------------+---------+------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 | NULL |     20 |</span><br><span class="line">|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 | NULL |     20 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 | NULL |     10 |</span><br><span class="line">|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 | NULL |     20 |</span><br><span class="line">|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL |     10 |</span><br><span class="line">|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 | NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 | NULL |     30 |</span><br><span class="line">|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 | NULL |     20 |</span><br><span class="line">|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 | NULL |     10 |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+------+--------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="and"><a href="#and" class="headerlink" title="and"></a><font color="#f2711c">and</font></h5><p>and表示并且的含义，表示所有的条件必须满足</p>
<ul>
<li>工作岗位为MANAGER,薪水大于2500的员工<blockquote>
<p>select ename from EMP where job = ‘manager’ and sal &gt; 2500</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select ename from EMP where job = &#x27;manager&#x27; and sal &gt; 2500;</span><br><span class="line">+-------+</span><br><span class="line">| ename |</span><br><span class="line">+-------+</span><br><span class="line">| JONES |</span><br><span class="line">| BLAKE |</span><br><span class="line">+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="or"><a href="#or" class="headerlink" title="or"></a><font color="#f2711c">or</font></h5><p>or，只要满足条件即可,相当于包含</p>
<ul>
<li>查询出job为manager或者job为salesman的员工<blockquote>
<p>select * from EMP where job = ‘manager’ or job = ‘salesman’;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP where job = &#x27;manager&#x27; or job = &#x27;salesman&#x27;;</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER  | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER  | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">7 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="表达式的优先级"><a href="#表达式的优先级" class="headerlink" title="表达式的优先级"></a><font color="#f2711c">表达式的优先级</font></h5><p>关于运算符的问题：不用记，没有把握尽量采用括号</p>
<ul>
<li>查询薪水大于1800，并且部门代码为20或30的员工<blockquote>
<p>select * from EMP where sal &gt; 1800 and (DEPTNO = 20 or DEPTNO = 30);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP where sal &gt; 1800 and (DEPTNO = 20 or DEPTNO = 30);</span><br><span class="line">+-------+-------+---------+------+------------+---------+------+--------+</span><br><span class="line">| EMPNO | ENAME | JOB     | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |</span><br><span class="line">+-------+-------+---------+------+------------+---------+------+--------+</span><br><span class="line">|  7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL |     20 |</span><br><span class="line">|  7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |</span><br><span class="line">|  7788 | SCOTT | ANALYST | 7566 | 1987-04-19 | 3000.00 | NULL |     20 |</span><br><span class="line">|  7902 | FORD  | ANALYST | 7566 | 1981-12-03 | 3000.00 | NULL |     20 |</span><br><span class="line">+-------+-------+---------+------+------------+---------+------+--------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="in"><a href="#in" class="headerlink" title="in"></a><font color="#f2711c">in</font></h5><p>in表示包含的意思，完全可以采用or来表示，采用in会更简洁一些</p>
<ul>
<li><p>查询出job为manager或者job为salesman或者job为clerk的员工</p>
<blockquote>
<p>select * from EMP where job in (‘manager’,’salesman’,’clerk’);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP where job in (&#x27;manager&#x27;,&#x27;salesman&#x27;,&#x27;clerk&#x27;);</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK    | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER  | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER  | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | CLERK    | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK    | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7934 | MILLER | CLERK    | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>查询出薪水包含1600和薪水包含3000的员工</p>
<blockquote>
<p>select * from EMP where sal in (1600,3000);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP where sal in (1600,3000);</span><br><span class="line">+-------+-------+----------+------+------------+---------+--------+--------+</span><br><span class="line">| EMPNO | ENAME | JOB      | MGR  | HIREDATE   | SAL     | COMM   | DEPTNO |</span><br><span class="line">+-------+-------+----------+------+------------+---------+--------+--------+</span><br><span class="line">|  7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 |     30 |</span><br><span class="line">|  7788 | SCOTT | ANALYST  | 7566 | 1987-04-19 | 3000.00 |   NULL |     20 |</span><br><span class="line">|  7902 | FORD  | ANALYST  | 7566 | 1981-12-03 | 3000.00 |   NULL |     20 |</span><br><span class="line">+-------+-------+----------+------+------------+---------+--------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>in 子句中是变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d.matCodes: 为数组</span><br><span class="line">var _matCodes = d.matCodes.toString();</span><br><span class="line">var _orderId = d.orderId</span><br><span class="line">var sqlCapacity = `select * from MATDB where Matcode in (?) AND ORDERID = &#x27;$&#123;_orderId&#125;&#x27;`</span><br><span class="line">connection.query(sqlCapacity,[d.matCodes], function(err, results) &#123;</span><br><span class="line">  if(err) &#123;</span><br><span class="line">    return res.json(&#123;</span><br><span class="line">        code: -2,</span><br><span class="line">        message: &#x27;查询失败&#x27;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  res.json(&#123;</span><br><span class="line">      code: 200,</span><br><span class="line">      message: &#x27;查询成功&#x27;,</span><br><span class="line">      data: results,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="not"><a href="#not" class="headerlink" title="not"></a><font color="#f2711c">not</font></h5><ul>
<li><p>查询出薪水不包含1600和薪水不包含3000的员工</p>
<blockquote>
<p>select * from EMP where sal &lt;&gt; 1600 and sal &lt;&gt; 3000;<br>select * from EMP where not (sal = 1600 or sal = 3000);<br>select * from EMP where sal not in (1600, 3000);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP where sal not in (1600, 3000);</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>查询出津贴不为null的所有员工</p>
<blockquote>
<p>select * from EMP where comm is not null;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP where comm is not null;</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="like"><a href="#like" class="headerlink" title="like"></a><font color="#f2711c">like</font></h5><p>Like可以实现模糊查询，like支持%和下划线匹配</p>
<ul>
<li><p>查询姓名以M开头所有的员工<br>select * from EMP where ename like ‘M%’;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP where ename like &#x27;M%&#x27;;</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7934 | MILLER | CLERK    | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>查询姓名以N结尾的所有的员工</p>
<blockquote>
<p>select * from EMP where ename like ‘%N’;</p>
</blockquote>
</li>
<li><p>查询姓名中包含O的所有的员工</p>
<blockquote>
<p>select * from EMP where ename like ‘%O%’;</p>
</blockquote>
</li>
<li><p>查询姓名中第二个字符为A的所有员工</p>
<blockquote>
<p>select * from EMP where ename like ‘_A%’;</p>
</blockquote>
</li>
</ul>
<p><font color="red">Like中%和下划线的差别？<br>%匹配任意字符出现的个数，下划线只匹配一个字符，Like 中的表达式必须放到单引号中|双引号中</font></p>
<h4 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h4><h5 id="单一字段排序"><a href="#单一字段排序" class="headerlink" title="单一字段排序"></a><font color="#f2711c">单一字段排序</font></h5><p>排序采用order by子句，order by后面跟上排序字段，排序字段可以放多个，多个采用逗号间隔，order by默认采用升序，如果存在where子句那么order by必须放到where语句的后面</p>
<ul>
<li><p>按照薪水由小到大排序(系统默认由小到大)</p>
<blockquote>
<p>select * from EMP order by sal;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP order by sal;</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>取得job为MANAGER的员工，按照薪水由小到大排序(系统默认由小到大)</p>
<blockquote>
<p>select * from EMP where job = ‘manager’ order by sal;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP where job = &#x27;manager&#x27; order by sal;</span><br><span class="line">+-------+-------+---------+------+------------+---------+------+--------+</span><br><span class="line">| EMPNO | ENAME | JOB     | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |</span><br><span class="line">+-------+-------+---------+------+------------+---------+------+--------+</span><br><span class="line">|  7782 | CLARK | MANAGER | 7839 | 1981-06-09 | 2450.00 | NULL |     10 |</span><br><span class="line">|  7698 | BLAKE | MANAGER | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |</span><br><span class="line">|  7566 | JONES | MANAGER | 7839 | 1981-04-02 | 2975.00 | NULL |     20 |</span><br><span class="line">+-------+-------+---------+------+------------+---------+------+--------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>如果包含where语句order by必须放到where后面，如果没有where语句order by放到表的后面</p>
</li>
<li><p>按照多个字段排序，如：首先按照job排序，再按照sal排序</p>
<blockquote>
<p>select * from EMP order by job,sal;</p>
</blockquote>
</li>
</ul>
<h5 id="手动指定排序顺序"><a href="#手动指定排序顺序" class="headerlink" title="手动指定排序顺序"></a><font color="#f2711c">手动指定排序顺序</font></h5><ul>
<li>按照薪水由小到大排序,从大到小<blockquote>
<p>select * from EMP order by sal asc;<br>select * from EMP order by sal desc;<br>mysql&gt; select * from EMP order by sal asc;</p>
</blockquote>
</li>
</ul>
<p>+——-+——–+———–+——+————+———+———+——–+<br>| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |<br>+——-+——–+———–+——+————+———+———+——–+<br>|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |<br>|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |<br>|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |<br>|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |<br>|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |<br>|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |<br>|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |<br>|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |<br>|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |<br>|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |<br>|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |<br>|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |<br>|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |<br>|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |<br>+——-+——–+———–+——+————+———+———+——–+<br>14 rows in set (0.00 sec)</p>
<h5 id="多个字段排序顺序"><a href="#多个字段排序顺序" class="headerlink" title="多个字段排序顺序"></a><font color="#f2711c">多个字段排序顺序</font></h5><ul>
<li>按照job和薪水倒序<blockquote>
<p>select * from EMP order by job desc, sal desc;<br>如果采用多个字段排序，如果根据第一个字段排序重复了，会根据第二个字段排序</p>
</blockquote>
</li>
</ul>
<h5 id="使用字段的位置来排序"><a href="#使用字段的位置来排序" class="headerlink" title="使用字段的位置来排序"></a><font color="#f2711c">使用字段的位置来排序</font></h5><ul>
<li>按照薪水升序<blockquote>
<p>select * from EMP order by 6;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP order by 6;</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
不建议使用此种方式，采用数字含义不明确，程序不健壮</li>
</ul>
<h4 id="分组函数-聚合函数-多行处理函数"><a href="#分组函数-聚合函数-多行处理函数" class="headerlink" title="分组函数/聚合函数/多行处理函数"></a>分组函数/聚合函数/多行处理函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>count</td>
<td>取得记录数</td>
</tr>
<tr>
<td>sum</td>
<td>求和</td>
</tr>
<tr>
<td>avg</td>
<td>取平均</td>
</tr>
<tr>
<td>max</td>
<td>取最大的数</td>
</tr>
<tr>
<td>min</td>
<td>取最小的数</td>
</tr>
<tr>
<td>注意：</td>
<td></td>
</tr>
</tbody></table>
<ol>
<li>分组函数自动忽略空值，不需要手动的加where条件排除空值；</li>
<li>分组函数不能直接使用在where关键字后面。<h5 id="count"><a href="#count" class="headerlink" title="count"></a><font color="#f2711c">count</font></h5></li>
</ol>
<ul>
<li><p>取得所有的员工数</p>
<blockquote>
<p>select count(*) from EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(*) from EMP;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|       14 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>Count(*)表示取得所有记录，忽略null，为null的值也会取得</p>
</li>
<li><p>取得津贴不为null员工数</p>
<blockquote>
<p>select count(comm) from EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(comm) from EMP;</span><br><span class="line">+-------------+</span><br><span class="line">| count(comm) |</span><br><span class="line">+-------------+</span><br><span class="line">|           4 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>采用count(字段名称)，不会取得为null的记录</p>
</li>
<li><p>取得工作岗位的个数</p>
<blockquote>
<p>select count(distinct job) from EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(distinct job) from EMP;</span><br><span class="line">+---------------------+</span><br><span class="line">| count(distinct job) |</span><br><span class="line">+---------------------+</span><br><span class="line">|                   5 |</span><br><span class="line">+---------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h5 id="sum"><a href="#sum" class="headerlink" title="sum"></a><font color="#f2711c">sum</font></h5><p>Sum可以取得某一个列的和，null会被忽略</p>
</li>
<li><p>取得薪水的合计</p>
<blockquote>
<p>select sum(sal) from EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select sum(sal) from EMP;</span><br><span class="line">+----------+</span><br><span class="line">| sum(sal) |</span><br><span class="line">+----------+</span><br><span class="line">| 29025.00 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>取得津贴的合计</p>
<blockquote>
<p>select sum(comm) from EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select sum(comm) from EMP;</span><br><span class="line">+-----------+</span><br><span class="line">| sum(comm) |</span><br><span class="line">+-----------+</span><br><span class="line">|   2200.00 |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>null会被忽略</p>
</li>
<li><p>取得薪水的合计</p>
</li>
<li><p>select sum(sal+comm) from EMP;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select sum(sal+comm) from EMP;</span><br><span class="line">+---------------+</span><br><span class="line">| sum(sal+comm) |</span><br><span class="line">+---------------+</span><br><span class="line">|       7800.00 |</span><br><span class="line">+---------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>从以上结果来看，不正确，原因在于comm字段有null值，所以无法计算，sum会忽略掉，正确的做法是将comm字段转换成0</p>
<blockquote>
<p>select sum(sal+IFNULL(comm, 0)) from EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select sum(sal+IFNULL(comm, 0)) from EMP;</span><br><span class="line">+--------------------------+</span><br><span class="line">| sum(sal+IFNULL(comm, 0)) |</span><br><span class="line">+--------------------------+</span><br><span class="line">|                 31225.00 |</span><br><span class="line">+--------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="avg"><a href="#avg" class="headerlink" title="avg"></a><font color="#f2711c">avg</font></h5><p>取得某一列的平均值</p>
<ul>
<li>取得平均薪水<blockquote>
<p>select avg(sal) feom EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select avg(sal) from EMP;</span><br><span class="line">+-------------+</span><br><span class="line">| avg(sal)    |</span><br><span class="line">+-------------+</span><br><span class="line">| 2073.214286 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h5 id="max"><a href="#max" class="headerlink" title="max"></a><font color="#f2711c">max</font></h5>取得某个一列的最大值</li>
<li>取得最高薪水<blockquote>
<p>mysql&gt; select max(sal) from EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select max(sal) from EMP;</span><br><span class="line">+----------+</span><br><span class="line">| max(sal) |</span><br><span class="line">+----------+</span><br><span class="line">|  5000.00 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li>取得最晚入职得员工<blockquote>
<p>select max(str_to_date (hiredate, ‘%Y-%m-%d’)) from EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select max(str_to_date (hiredate, &#x27;%Y-%m-%d&#x27;)) from EMP;</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">| max(str_to_date (hiredate, &#x27;%Y-%m-%d&#x27;)) |</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">| 1987-05-23                              |</span><br><span class="line">+-----------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="min"><a href="#min" class="headerlink" title="min"></a><font color="#f2711c">min</font></h5><p>取得某个一列的最小值</p>
<ul>
<li><p>取得最低薪水</p>
<blockquote>
<p>select min(sal) from EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select min(sal) from EMP;</span><br><span class="line">+----------+</span><br><span class="line">| min(sal) |</span><br><span class="line">+----------+</span><br><span class="line">|   800.00 |</span><br><span class="line">+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>取得最早入职的员工（可以不使用str_to_date转换）</p>
<blockquote>
<p>select min(str_to_date(hiredate, ‘%Y-%m-%d’)) from EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select min(str_to_date(hiredate, &#x27;%Y-%m-%d&#x27;)) from EMP;</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| min(str_to_date(hiredate, &#x27;%Y-%m-%d&#x27;)) |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">| 1980-12-17                             |</span><br><span class="line">+----------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="组合聚合函数"><a href="#组合聚合函数" class="headerlink" title="组合聚合函数"></a><font color="#f2711c">组合聚合函数</font></h5><p>可以将这些聚合函数都放到select中一起使用</p>
<blockquote>
<p>select count(*),sum(sal),avg(sal),max(sal),min(sal) from EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select count(*),sum(sal),avg(sal),max(sal),min(sal) from EMP;</span><br><span class="line">+----------+----------+-------------+----------+----------+</span><br><span class="line">| count(*) | sum(sal) | avg(sal)    | max(sal) | min(sal) |</span><br><span class="line">+----------+----------+-------------+----------+----------+</span><br><span class="line">|       14 | 29025.00 | 2073.214286 |  5000.00 |   800.00 |</span><br><span class="line">+----------+----------+-------------+----------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><p>分组查询主要涉及到两个子句，分别是：group by和having</p>
<h5 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a><font color="#f2711c">group by</font></h5><ul>
<li>取得每个工作岗位的工资合计，要求显示岗位名称和工资合计<blockquote>
<p>select job,sum(sal) from EMP group by job;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select job,sum(sal) from EMP group by job;</span><br><span class="line">+-----------+----------+</span><br><span class="line">| job       | sum(sal) |</span><br><span class="line">+-----------+----------+</span><br><span class="line">| ANALYST   |  6000.00 |</span><br><span class="line">| CLERK     |  4150.00 |</span><br><span class="line">| MANAGER   |  8275.00 |</span><br><span class="line">| PRESIDENT |  5000.00 |</span><br><span class="line">| SALESMAN  |  5600.00 |</span><br><span class="line">+-----------+----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
如果使用了order by，order by必须放到group by后面</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select job,sum(sal) from EMP order by job group by job;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;group by job&#x27; at line 1</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select job,sum(sal) from EMP group by job order by job;</span><br><span class="line">+-----------+----------+</span><br><span class="line">| job       | sum(sal) |</span><br><span class="line">+-----------+----------+</span><br><span class="line">| ANALYST   |  6000.00 |</span><br><span class="line">| CLERK     |  4150.00 |</span><br><span class="line">| MANAGER   |  8275.00 |</span><br><span class="line">| PRESIDENT |  5000.00 |</span><br><span class="line">| SALESMAN  |  5600.00 |</span><br><span class="line">+-----------+----------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>按照工作岗位和码分组，取得的工资合计<blockquote>
<p>select job,deptno,sum(sal) from EMP group by job,deptno;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP;</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">14 rows in set (0.00 sec)</span><br><span class="line">以上SQL语句在Oracle数据库中无法执行，执行报错。</span><br><span class="line">以上SQL语句在Mysql数据库中可以执行，但是执行结果矛盾。</span><br><span class="line">在SQL语句中若有group by 语句，那么在select语句后面只能跟分组函数+参与分组的字段。</span><br><span class="line"></span><br><span class="line">mysql&gt; select job,deptno,sum(sal) from EMP group by job,deptno;</span><br><span class="line">+-----------+--------+----------+</span><br><span class="line">| job       | deptno | sum(sal) |</span><br><span class="line">+-----------+--------+----------+</span><br><span class="line">| ANALYST   |     20 |  6000.00 |</span><br><span class="line">| CLERK     |     10 |  1300.00 |</span><br><span class="line">| CLERK     |     20 |  1900.00 |</span><br><span class="line">| CLERK     |     30 |   950.00 |</span><br><span class="line">| MANAGER   |     10 |  2450.00 |</span><br><span class="line">| MANAGER   |     20 |  2975.00 |</span><br><span class="line">| MANAGER   |     30 |  2850.00 |</span><br><span class="line">| PRESIDENT |     10 |  5000.00 |</span><br><span class="line">| SALESMAN  |     30 |  5600.00 |</span><br><span class="line">+-----------+--------+----------+</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h5 id="having"><a href="#having" class="headerlink" title="having"></a><font color="#f2711c">having</font></h5>如果想对分组数据再进行过滤需要使用having子句</li>
<li>取得每个岗位的平均工资大于2000<blockquote>
<p>select job,avg(sal) from EMP group by job having avg(sal) &gt; 2000;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select job,avg(sal) from EMP group by job where avg(sal) &gt; 2000;</span><br><span class="line">ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;where avg(sal) &gt; 2000&#x27; at line 1</span><br><span class="line">mysql&gt; select job,avg(sal) from EMP group by job having avg(sal) &gt; 2000;</span><br><span class="line">+-----------+-------------+</span><br><span class="line">| job       | avg(sal)    |</span><br><span class="line">+-----------+-------------+</span><br><span class="line">| ANALYST   | 3000.000000 |</span><br><span class="line">| MANAGER   | 2758.333333 |</span><br><span class="line">| PRESIDENT | 5000.000000 |</span><br><span class="line">+-----------+-------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
分组函数的执行顺序：<br>根据条件查询数据<br>分组<br>采用having过滤，取得正确的数据</li>
</ul>
<h5 id="select语句总结"><a href="#select语句总结" class="headerlink" title="select语句总结"></a><font color="#f2711c">select语句总结</font></h5><p>一个完整的select语句格式如下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段</span><br><span class="line">from 表名</span><br><span class="line">where …….</span><br><span class="line">group by ……..</span><br><span class="line">having …….(就是为了过滤分组后的数据而存在的—不可以单独的出现)</span><br><span class="line">order by ……..</span><br></pre></td></tr></table></figure>
<p>以上语句的执行顺序<br>1.首先执行where语句过滤原始数据<br>2.执行group by进行分组<br>3.执行having对分组数据进行操作<br>4.执行select选出数据<br>5.执行order by排序</p>
<p>原则：能在where中过滤的数据，尽量在where中过滤，效率较高。having的过滤是专门对分组之后的数据进行过滤的。</p>
<h4 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h4><h5 id="什么是连接查询"><a href="#什么是连接查询" class="headerlink" title="什么是连接查询"></a><font color="#f2711c">什么是连接查询</font></h5><p>在实际开发中，大部分的情况下都不是从单表中查询数据，一般都是多张表联合查询取出最终的结果。<br>在实际开发中，一般一个业务都会对应多张表，比如：学生和班级，起码两张表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stuno		stuname			classno		classname</span><br><span class="line">	-----------------------------------------------------------------------------------</span><br><span class="line">	1			zs					1				北京大兴区亦庄经济技术开发区第二中学高三1班</span><br><span class="line">	2			ls					1				北京大兴区亦庄经济技术开发区第二中学高三1班</span><br><span class="line">	...</span><br><span class="line">	学生和班级信息存储到一张表中，结果就像上面一样，数据会存在大量的重复，导致数据的冗余。</span><br></pre></td></tr></table></figure>

<h5 id="连接查询的分类"><a href="#连接查询的分类" class="headerlink" title="连接查询的分类"></a><font color="#f2711c">连接查询的分类</font></h5><ul>
<li><p>根据语法出现的年代来划分的话，包括：</p>
<blockquote>
<p>SQL92（一些老的DBA可能还在使用这种语法。DBA：DataBase Administrator，数据库管理员）<br>SQL99（比较新的语法）</p>
</blockquote>
</li>
<li><p>根据表的连接方式来划分，包括：</p>
<blockquote>
<p>内连接：</p>
<pre><code>等值连接
非等值连接
自连接
</code></pre>
<p>外连接：</p>
<pre><code>左外连接（左连接）
右外连接（右连接）
</code></pre>
<p>全连接（这个不讲，很少用！）</p>
</blockquote>
</li>
</ul>
<h5 id="在表的连接查询方面有一种现象被称为：笛卡尔积现象。（笛卡尔乘积现象）"><a href="#在表的连接查询方面有一种现象被称为：笛卡尔积现象。（笛卡尔乘积现象）" class="headerlink" title="在表的连接查询方面有一种现象被称为：笛卡尔积现象。（笛卡尔乘积现象）"></a><font color="#f2711c">在表的连接查询方面有一种现象被称为：笛卡尔积现象。（笛卡尔乘积现象）</font></h5><p>案例：找出每一个员工的部门名称，要求显示员工名和部门名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EMP表</span><br><span class="line">+--------+--------+</span><br><span class="line">| ename  | deptno |</span><br><span class="line">+--------+--------+</span><br><span class="line">| SMITH  |     20 |</span><br><span class="line">| ALLEN  |     30 |</span><br><span class="line">| WARD   |     30 |</span><br><span class="line">| JONES  |     20 |</span><br><span class="line">| MARTIN |     30 |</span><br><span class="line">| BLAKE  |     30 |</span><br><span class="line">| CLARK  |     10 |</span><br><span class="line">| SCOTT  |     20 |</span><br><span class="line">| KING   |     10 |</span><br><span class="line">| TURNER |     30 |</span><br><span class="line">| ADAMS  |     20 |</span><br><span class="line">| JAMES  |     30 |</span><br><span class="line">| FORD   |     20 |</span><br><span class="line">| MILLER |     10 |</span><br><span class="line">+--------+--------+</span><br><span class="line"></span><br><span class="line">DEPT表</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line"></span><br><span class="line">select ename,dname from emp,dept;</span><br><span class="line">+--------+------------+</span><br><span class="line">| ename  | dname      |</span><br><span class="line">+--------+------------+</span><br><span class="line">| SMITH  | ACCOUNTING |</span><br><span class="line">| SMITH  | RESEARCH   |</span><br><span class="line">| SMITH  | SALES      |</span><br><span class="line">| SMITH  | OPERATIONS |</span><br><span class="line">| ALLEN  | ACCOUNTING |</span><br><span class="line">| ALLEN  | RESEARCH   |</span><br><span class="line">| ALLEN  | SALES      |</span><br><span class="line">| ALLEN  | OPERATIONS |</span><br><span class="line">............</span><br><span class="line">56 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p> 笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件进行限制，最终的查询结果条数是两张表记录条数的乘积。</p>
</blockquote>
<div class="danger">

<ul>
<li>关于表的别名：<blockquote>
<p> select e.ename,d.dname from emp e,dept d;<br>  表的别名有什么好处？</p>
<pre><code>  第一：执行效率高。
  第二：可读性好。
</code></pre>
</blockquote>
</li>
</ul>
</div>

<h5 id="怎么避免笛卡尔积现象？当然是加条件进行过滤。"><a href="#怎么避免笛卡尔积现象？当然是加条件进行过滤。" class="headerlink" title="怎么避免笛卡尔积现象？当然是加条件进行过滤。"></a><font color="#f2711c">怎么避免笛卡尔积现象？当然是加条件进行过滤。</font></h5><p>思考：避免了笛卡尔积现象，会减少记录的匹配次数吗？</p>
<ul>
<li>不会，次数还是56次。只不过显示的是有效记录。</li>
</ul>
<p>案例：找出每一个员工的部门名称，要求显示员工名和部门名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select	</span><br><span class="line">	e.ename,d.dname</span><br><span class="line">from</span><br><span class="line">	emp e , dept d</span><br><span class="line">where</span><br><span class="line">	e.deptno = d.deptno; //SQL92，以后不用。</span><br><span class="line"></span><br><span class="line">+--------+------------+</span><br><span class="line">| ename  | dname      |</span><br><span class="line">+--------+------------+</span><br><span class="line">| CLARK  | ACCOUNTING |</span><br><span class="line">| KING   | ACCOUNTING |</span><br><span class="line">| MILLER | ACCOUNTING |</span><br><span class="line">| SMITH  | RESEARCH   |</span><br><span class="line">| JONES  | RESEARCH   |</span><br><span class="line">| SCOTT  | RESEARCH   |</span><br><span class="line">| ADAMS  | RESEARCH   |</span><br><span class="line">| FORD   | RESEARCH   |</span><br><span class="line">| ALLEN  | SALES      |</span><br><span class="line">| WARD   | SALES      |</span><br><span class="line">| MARTIN | SALES      |</span><br><span class="line">| BLAKE  | SALES      |</span><br><span class="line">| TURNER | SALES      |</span><br><span class="line">| JAMES  | SALES      |</span><br></pre></td></tr></table></figure>

<h5 id="内连接之等值连接"><a href="#内连接之等值连接" class="headerlink" title="内连接之等值连接"></a><font color="#f2711c">内连接之等值连接</font></h5><blockquote>
<p>最大特点是：条件是等量关系。<br>案例：查询每个员工的部门名称，要求显示员工名和部门名。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SQL92:（太老，不用了）</span><br><span class="line">	select </span><br><span class="line">		e.ename,d.dname</span><br><span class="line">	from</span><br><span class="line">		emp e, dept d</span><br><span class="line">	where</span><br><span class="line">		e.deptno = d.deptno;</span><br><span class="line"></span><br><span class="line">SQL99：（常用的）</span><br><span class="line">	select </span><br><span class="line">		e.ename,d.dname</span><br><span class="line">	from</span><br><span class="line">		emp e</span><br><span class="line">	join</span><br><span class="line">		dept d</span><br><span class="line">	on</span><br><span class="line">		e.deptno = d.deptno;</span><br><span class="line"></span><br><span class="line">	// inner可以省略的，带着inner目的是可读性好一些。</span><br><span class="line">	select </span><br><span class="line">		e.ename,d.dname</span><br><span class="line">	from</span><br><span class="line">		emp e</span><br><span class="line">	inner join</span><br><span class="line">		dept d</span><br><span class="line">	on</span><br><span class="line">		e.deptno = d.deptno;</span><br><span class="line">	</span><br><span class="line">	语法：</span><br><span class="line">		...</span><br><span class="line">			A</span><br><span class="line">		join</span><br><span class="line">			B</span><br><span class="line">		on</span><br><span class="line">			连接条件</span><br><span class="line">		where</span><br><span class="line">			...</span><br><span class="line">	</span><br><span class="line">	SQL99语法结构更清晰一些：表的连接条件和后来的where条件分离了。</span><br><span class="line"></span><br><span class="line">	+--------+------------+</span><br><span class="line">	| ename  | dname      |</span><br><span class="line">	+--------+------------+</span><br><span class="line">	| CLARK  | ACCOUNTING |</span><br><span class="line">	| KING   | ACCOUNTING |</span><br><span class="line">	| MILLER | ACCOUNTING |</span><br><span class="line">	| SMITH  | RESEARCH   |</span><br><span class="line">	| JONES  | RESEARCH   |</span><br><span class="line">	| SCOTT  | RESEARCH   |</span><br><span class="line">	| ADAMS  | RESEARCH   |</span><br><span class="line">	| FORD   | RESEARCH   |</span><br><span class="line">	| ALLEN  | SALES      |</span><br><span class="line">	| WARD   | SALES      |</span><br><span class="line">	| MARTIN | SALES      |</span><br><span class="line">	| BLAKE  | SALES      |</span><br><span class="line">	| TURNER | SALES      |</span><br><span class="line">	| JAMES  | SALES      |</span><br><span class="line">	+--------+------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="内连接之非等值连接"><a href="#内连接之非等值连接" class="headerlink" title="内连接之非等值连接"></a><font color="#f2711c">内连接之非等值连接</font></h5><blockquote>
<p>最大的特点是：连接条件中的关系是非等量关系。<br>案例：找出每个员工的工资等级，要求显示员工名、工资、工资等级。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select ename,sal from emp; e</span><br><span class="line">+--------+---------+</span><br><span class="line">| ename  | sal     |</span><br><span class="line">+--------+---------+</span><br><span class="line">| SMITH  |  800.00 |</span><br><span class="line">| ALLEN  | 1600.00 |</span><br><span class="line">| WARD   | 1250.00 |</span><br><span class="line">| JONES  | 2975.00 |</span><br><span class="line">| MARTIN | 1250.00 |</span><br><span class="line">| BLAKE  | 2850.00 |</span><br><span class="line">| CLARK  | 2450.00 |</span><br><span class="line">| SCOTT  | 3000.00 |</span><br><span class="line">| KING   | 5000.00 |</span><br><span class="line">| TURNER | 1500.00 |</span><br><span class="line">| ADAMS  | 1100.00 |</span><br><span class="line">| JAMES  |  950.00 |</span><br><span class="line">| FORD   | 3000.00 |</span><br><span class="line">| MILLER | 1300.00 |</span><br><span class="line">+--------+---------+</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from salgrade; s</span><br><span class="line">+-------+-------+-------+ </span><br><span class="line">| GRADE | LOSAL | HISAL |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">|     1 |   700 |  1200 |</span><br><span class="line">|     2 |  1201 |  1400 |</span><br><span class="line">|     3 |  1401 |  2000 |</span><br><span class="line">|     4 |  2001 |  3000 |</span><br><span class="line">|     5 |  3001 |  9999 |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">	e.ename,e.sal,s.grade</span><br><span class="line">from</span><br><span class="line">	emp e</span><br><span class="line">join</span><br><span class="line">	salgrade s</span><br><span class="line">on</span><br><span class="line">	e.sal between s.losal and s.hisal;</span><br><span class="line"></span><br><span class="line">// inner可以省略</span><br><span class="line">select </span><br><span class="line">	e.ename,e.sal,s.grade</span><br><span class="line">from</span><br><span class="line">	emp e</span><br><span class="line">inner join</span><br><span class="line">	salgrade s</span><br><span class="line">on</span><br><span class="line">	e.sal between s.losal and s.hisal;</span><br><span class="line"></span><br><span class="line">+--------+---------+-------+</span><br><span class="line">| ename  | sal     | grade |</span><br><span class="line">+--------+---------+-------+</span><br><span class="line">| SMITH  |  800.00 |     1 |</span><br><span class="line">| ALLEN  | 1600.00 |     3 |</span><br><span class="line">| WARD   | 1250.00 |     2 |</span><br><span class="line">| JONES  | 2975.00 |     4 |</span><br><span class="line">| MARTIN | 1250.00 |     2 |</span><br><span class="line">| BLAKE  | 2850.00 |     4 |</span><br><span class="line">| CLARK  | 2450.00 |     4 |</span><br><span class="line">| SCOTT  | 3000.00 |     4 |</span><br><span class="line">| KING   | 5000.00 |     5 |</span><br><span class="line">| TURNER | 1500.00 |     3 |</span><br><span class="line">| ADAMS  | 1100.00 |     1 |</span><br><span class="line">| JAMES  |  950.00 |     1 |</span><br><span class="line">| FORD   | 3000.00 |     4 |</span><br><span class="line">| MILLER | 1300.00 |     2 |</span><br><span class="line">+--------+---------+-------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a><font color="#f2711c">自连接</font></h5><blockquote>
<p>最大的特点是：一张表看做两张表。自己连接自己。<br>案例：找出每个员工的上级领导，要求显示员工名和对应的领导名。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select empno,ename,mgr from emp;</span><br><span class="line">emp a 员工表</span><br><span class="line">+-------+--------+------+</span><br><span class="line">| empno | ename  | mgr  |</span><br><span class="line">+-------+--------+------+</span><br><span class="line">|  7369 | SMITH  | 7902 |</span><br><span class="line">|  7499 | ALLEN  | 7698 |</span><br><span class="line">|  7521 | WARD   | 7698 |</span><br><span class="line">|  7566 | JONES  | 7839 |</span><br><span class="line">|  7654 | MARTIN | 7698 |</span><br><span class="line">|  7698 | BLAKE  | 7839 |</span><br><span class="line">|  7782 | CLARK  | 7839 |</span><br><span class="line">|  7788 | SCOTT  | 7566 |</span><br><span class="line">|  7839 | KING   | NULL |</span><br><span class="line">|  7844 | TURNER | 7698 |</span><br><span class="line">|  7876 | ADAMS  | 7788 |</span><br><span class="line">|  7900 | JAMES  | 7698 |</span><br><span class="line">|  7902 | FORD   | 7566 |</span><br><span class="line">|  7934 | MILLER | 7782 |</span><br><span class="line">+-------+--------+------+</span><br><span class="line">emp b 领导表</span><br><span class="line">+-------+--------+</span><br><span class="line">| empno | ename  |</span><br><span class="line">+-------+--------+</span><br><span class="line">|  7566 | JONES  |</span><br><span class="line">|  7698 | BLAKE  |</span><br><span class="line">|  7782 | CLARK  |</span><br><span class="line">|  7788 | SCOTT  |</span><br><span class="line">|  7839 | KING   |</span><br><span class="line">|  7902 | FORD   |</span><br><span class="line">+-------+--------+</span><br><span class="line"></span><br><span class="line">员工的领导编号 = 领导的员工编号</span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">	a.ename as &#x27;员工名&#x27;,b.ename as &#x27;领导名&#x27;</span><br><span class="line">from</span><br><span class="line">	emp a</span><br><span class="line">inner join</span><br><span class="line">	emp b</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno;</span><br></pre></td></tr></table></figure>

<p>案例：找出每个员工的上级领导，要求显示员工名和对应的领导名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------+--------+</span><br><span class="line">| 员工名 | 领导名 |</span><br><span class="line">+--------+--------+</span><br><span class="line">| SMITH  | FORD   |</span><br><span class="line">| ALLEN  | BLAKE  |</span><br><span class="line">| WARD   | BLAKE  |</span><br><span class="line">| JONES  | KING   |</span><br><span class="line">| MARTIN | BLAKE  |</span><br><span class="line">| BLAKE  | KING   |</span><br><span class="line">| CLARK  | KING   |</span><br><span class="line">| SCOTT  | JONES  |</span><br><span class="line">| TURNER | BLAKE  |</span><br><span class="line">| ADAMS  | SCOTT  |</span><br><span class="line">| JAMES  | BLAKE  |</span><br><span class="line">| FORD   | JONES  |</span><br><span class="line">| MILLER | CLARK  |</span><br><span class="line">+--------+--------+</span><br></pre></td></tr></table></figure>
<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a><font color="#f2711c">外连接</font></h5><p>什么是外连接，和内连接有什么区别？</p>
<div class="danger">

<pre><code>  内连接:
  假设A和B表进行连接，使用内连接的话，凡是A表和B表能够匹配上的记录查询出来，这就是内连接。
  AB两张表没有主副之分，两张表是平等的。  
外连接: 
    假设A和B表进行连接，使用外连接的话，AB两张表中有一张表是主表，一张表是副表，主要查询主表中
    的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。
外连接的分类？
    左外连接（左连接）：表示左边的这张表是主表。
    右外连接（右连接）：表示右边的这张表是主表。
左连接有右连接的写法，右连接也会有对应的左连接的写法。
</code></pre>
</div>
案例：找出每个员工的上级领导？（所有员工必须全部查询出来。）
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">emp a 员工表</span><br><span class="line">+-------+--------+------+</span><br><span class="line">| empno | ename  | mgr  |</span><br><span class="line">+-------+--------+------+</span><br><span class="line">|  7369 | SMITH  | 7902 |</span><br><span class="line">|  7499 | ALLEN  | 7698 |</span><br><span class="line">|  7521 | WARD   | 7698 |</span><br><span class="line">|  7566 | JONES  | 7839 |</span><br><span class="line">|  7654 | MARTIN | 7698 |</span><br><span class="line">|  7698 | BLAKE  | 7839 |</span><br><span class="line">|  7782 | CLARK  | 7839 |</span><br><span class="line">|  7788 | SCOTT  | 7566 |</span><br><span class="line">|  7839 | KING   | NULL |</span><br><span class="line">|  7844 | TURNER | 7698 |</span><br><span class="line">|  7876 | ADAMS  | 7788 |</span><br><span class="line">|  7900 | JAMES  | 7698 |</span><br><span class="line">|  7902 | FORD   | 7566 |</span><br><span class="line">|  7934 | MILLER | 7782 |</span><br><span class="line">+-------+--------+------+</span><br><span class="line">emp b 领导表</span><br><span class="line">+-------+--------+</span><br><span class="line">| empno | ename  |</span><br><span class="line">+-------+--------+</span><br><span class="line">|  7566 | JONES  |</span><br><span class="line">|  7698 | BLAKE  |</span><br><span class="line">|  7782 | CLARK  |</span><br><span class="line">|  7788 | SCOTT  |</span><br><span class="line">|  7839 | KING   |</span><br><span class="line">|  7902 | FORD   |</span><br><span class="line">+-------+--------+</span><br><span class="line"></span><br><span class="line">内连接：</span><br><span class="line">select </span><br><span class="line">	a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">	emp a</span><br><span class="line">join</span><br><span class="line">	emp b</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno;</span><br><span class="line"></span><br><span class="line">外连接：（左外连接/左连接）</span><br><span class="line">select </span><br><span class="line">	a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">	emp a</span><br><span class="line">left join</span><br><span class="line">	emp b</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno;</span><br><span class="line"></span><br><span class="line">// outer是可以省略的。</span><br><span class="line">select </span><br><span class="line">	a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">	emp a</span><br><span class="line">left outer join</span><br><span class="line">	emp b</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno;</span><br><span class="line"></span><br><span class="line">外连接：（右外连接/右连接）</span><br><span class="line">select </span><br><span class="line">	a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">	emp b</span><br><span class="line">right join</span><br><span class="line">	emp a</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno;</span><br><span class="line"></span><br><span class="line">// outer可以省略。</span><br><span class="line">select </span><br><span class="line">	a.ename &#x27;员工&#x27;, b.ename &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">	emp b</span><br><span class="line">right outer join</span><br><span class="line">	emp a</span><br><span class="line">on</span><br><span class="line">	a.mgr = b.empno;</span><br><span class="line"></span><br><span class="line">+--------+-------+</span><br><span class="line">| 员工      | 领导    |</span><br><span class="line">+--------+-------+</span><br><span class="line">| SMITH  | FORD  |</span><br><span class="line">| ALLEN  | BLAKE |</span><br><span class="line">| WARD   | BLAKE |</span><br><span class="line">| JONES  | KING  |</span><br><span class="line">| MARTIN | BLAKE |</span><br><span class="line">| BLAKE  | KING  |</span><br><span class="line">| CLARK  | KING  |</span><br><span class="line">| SCOTT  | JONES |</span><br><span class="line">| KING   | NULL  |</span><br><span class="line">| TURNER | BLAKE |</span><br><span class="line">| ADAMS  | SCOTT |</span><br><span class="line">| JAMES  | BLAKE |</span><br><span class="line">| FORD   | JONES |</span><br><span class="line">| MILLER | CLARK |</span><br><span class="line">+--------+-------+</span><br></pre></td></tr></table></figure>

<blockquote>
<p>外连接最重要的特点是：主表的数据无条件的全部查询出来。</p>
</blockquote>
<p>案例：找出哪个部门没有员工？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EMP表</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7788 | SCOTT  | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7839 | KING   | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES  | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7902 | FORD   | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7934 | MILLER | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">+-------+--------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">DEPT</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line"></span><br><span class="line">select </span><br><span class="line">	d.*</span><br><span class="line">from</span><br><span class="line">	emp e</span><br><span class="line">right join</span><br><span class="line">	dept d</span><br><span class="line">on</span><br><span class="line">	e.deptno = d.deptno</span><br><span class="line">where</span><br><span class="line">	e.empno is null;</span><br><span class="line"></span><br><span class="line">+--------+------------+--------+</span><br><span class="line">| DEPTNO | DNAME      | LOC    |</span><br><span class="line">+--------+------------+--------+</span><br><span class="line">|     40 | OPERATIONS | BOSTON |</span><br><span class="line">+--------+------------+--------+</span><br></pre></td></tr></table></figure>

<h5 id="三张表怎么连接查询"><a href="#三张表怎么连接查询" class="headerlink" title="三张表怎么连接查询"></a><font color="#f2711c">三张表怎么连接查询</font></h5><p>案例：找出每一个员工的部门名称以及工资等级。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EMP e</span><br><span class="line">+-------+--------+---------+--------+</span><br><span class="line">| empno | ename  | sal     | deptno |</span><br><span class="line">+-------+--------+---------+--------+</span><br><span class="line">|  7369 | SMITH  |  800.00 |     20 |</span><br><span class="line">|  7499 | ALLEN  | 1600.00 |     30 |</span><br><span class="line">|  7521 | WARD   | 1250.00 |     30 |</span><br><span class="line">|  7566 | JONES  | 2975.00 |     20 |</span><br><span class="line">|  7654 | MARTIN | 1250.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | 2850.00 |     30 |</span><br><span class="line">|  7782 | CLARK  | 2450.00 |     10 |</span><br><span class="line">|  7788 | SCOTT  | 3000.00 |     20 |</span><br><span class="line">|  7839 | KING   | 5000.00 |     10 |</span><br><span class="line">|  7844 | TURNER | 1500.00 |     30 |</span><br><span class="line">|  7876 | ADAMS  | 1100.00 |     20 |</span><br><span class="line">|  7900 | JAMES  |  950.00 |     30 |</span><br><span class="line">|  7902 | FORD   | 3000.00 |     20 |</span><br><span class="line">|  7934 | MILLER | 1300.00 |     10 |</span><br><span class="line">+-------+--------+---------+--------+</span><br><span class="line">DEPT d</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">| DEPTNO | DNAME      | LOC      |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">|     10 | ACCOUNTING | NEW YORK |</span><br><span class="line">|     20 | RESEARCH   | DALLAS   |</span><br><span class="line">|     30 | SALES      | CHICAGO  |</span><br><span class="line">|     40 | OPERATIONS | BOSTON   |</span><br><span class="line">+--------+------------+----------+</span><br><span class="line">SALGRADE s</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">| GRADE | LOSAL | HISAL |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line">|     1 |   700 |  1200 |</span><br><span class="line">|     2 |  1201 |  1400 |</span><br><span class="line">|     3 |  1401 |  2000 |</span><br><span class="line">|     4 |  2001 |  3000 |</span><br><span class="line">|     5 |  3001 |  9999 |</span><br><span class="line">+-------+-------+-------+</span><br><span class="line"></span><br><span class="line">注意，解释一下：</span><br><span class="line">	....</span><br><span class="line">		A</span><br><span class="line">	join</span><br><span class="line">		B</span><br><span class="line">	join</span><br><span class="line">		C</span><br><span class="line">	on</span><br><span class="line">		...</span><br><span class="line">	</span><br><span class="line">	表示：A表和B表先进行表连接，连接之后A表继续和C表进行连接。</span><br><span class="line"></span><br><span class="line">	select </span><br><span class="line">		e.ename,d.dname,s.grade</span><br><span class="line">	from</span><br><span class="line">		emp e</span><br><span class="line">	join</span><br><span class="line">		dept d</span><br><span class="line">	on</span><br><span class="line">		e.deptno = d.deptno</span><br><span class="line">	join</span><br><span class="line">		salgrade s</span><br><span class="line">	on</span><br><span class="line">		e.sal between s.losal and s.hisal;</span><br><span class="line">	</span><br><span class="line">	+--------+------------+-------+</span><br><span class="line">	| ename  | dname      | grade |</span><br><span class="line">	+--------+------------+-------+</span><br><span class="line">	| SMITH  | RESEARCH   |     1 |</span><br><span class="line">	| ALLEN  | SALES      |     3 |</span><br><span class="line">	| WARD   | SALES      |     2 |</span><br><span class="line">	| JONES  | RESEARCH   |     4 |</span><br><span class="line">	| MARTIN | SALES      |     2 |</span><br><span class="line">	| BLAKE  | SALES      |     4 |</span><br><span class="line">	| CLARK  | ACCOUNTING |     4 |</span><br><span class="line">	| SCOTT  | RESEARCH   |     4 |</span><br><span class="line">	| KING   | ACCOUNTING |     5 |</span><br><span class="line">	| TURNER | SALES      |     3 |</span><br><span class="line">	| ADAMS  | RESEARCH   |     1 |</span><br><span class="line">	| JAMES  | SALES      |     1 |</span><br><span class="line">	| FORD   | RESEARCH   |     4 |</span><br><span class="line">	| MILLER | ACCOUNTING |     2 |</span><br><span class="line">	+--------+------------+-------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>案例：找出每一个员工的部门名称、工资等级、以及上级领导。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select </span><br><span class="line">	e.ename &#x27;员工&#x27;,d.dname,s.grade,e1.ename &#x27;领导&#x27;</span><br><span class="line">from</span><br><span class="line">	emp e</span><br><span class="line">join</span><br><span class="line">	dept d</span><br><span class="line">on</span><br><span class="line">	e.deptno = d.deptno</span><br><span class="line">join</span><br><span class="line">	salgrade s</span><br><span class="line">on</span><br><span class="line">	e.sal between s.losal and s.hisal</span><br><span class="line">left join</span><br><span class="line">	emp e1</span><br><span class="line">on</span><br><span class="line">	e.mgr = e1.empno;</span><br><span class="line"></span><br><span class="line">+--------+------------+-------+-------+</span><br><span class="line">| 员工      | dname      | grade | 领导    |</span><br><span class="line">+--------+------------+-------+-------+</span><br><span class="line">| SMITH  | RESEARCH   |     1 | FORD  |</span><br><span class="line">| ALLEN  | SALES      |     3 | BLAKE |</span><br><span class="line">| WARD   | SALES      |     2 | BLAKE |</span><br><span class="line">| JONES  | RESEARCH   |     4 | KING  |</span><br><span class="line">| MARTIN | SALES      |     2 | BLAKE |</span><br><span class="line">| BLAKE  | SALES      |     4 | KING  |</span><br><span class="line">| CLARK  | ACCOUNTING |     4 | KING  |</span><br><span class="line">| SCOTT  | RESEARCH   |     4 | JONES |</span><br><span class="line">| KING   | ACCOUNTING |     5 | NULL  |</span><br><span class="line">| TURNER | SALES      |     3 | BLAKE |</span><br><span class="line">| ADAMS  | RESEARCH   |     1 | SCOTT |</span><br><span class="line">| JAMES  | SALES      |     1 | BLAKE |</span><br><span class="line">| FORD   | RESEARCH   |     4 | JONES |</span><br><span class="line">| MILLER | ACCOUNTING |     2 | CLARK |</span><br><span class="line">+--------+------------+-------+-------+</span><br></pre></td></tr></table></figure>

<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>子查询就是嵌套的select语句，可以理解为子查询是一张表</p>
<h5 id="在where语句中使用子查询，也就是在where语句中加入select语句"><a href="#在where语句中使用子查询，也就是在where语句中加入select语句" class="headerlink" title="在where语句中使用子查询，也就是在where语句中加入select语句"></a><font color="#f2711c">在where语句中使用子查询，也就是在where语句中加入select语句</font></h5><ul>
<li>查询员工信息，查询哪些人是管理者，要求显示出其员工编号和员工姓名</li>
</ul>
<ol>
<li>首先取得管理者的编号<blockquote>
<p>select distinct MGR from EMP where MGR is not null;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select distinct MGR from EMP where MGR is not null;</span><br><span class="line">+------+</span><br><span class="line">| MGR  |</span><br><span class="line">+------+</span><br><span class="line">| 7902 |</span><br><span class="line">| 7698 |</span><br><span class="line">| 7839 |</span><br><span class="line">| 7566 |</span><br><span class="line">| 7788 |</span><br><span class="line">| 7782 |</span><br><span class="line">+------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li>查询员工编号<blockquote>
<p>select EMPNO,ENAME from EMP where EMPNO in (select distinct MGR from EMP where MGR is not null);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select EMPNO,ENAME from EMP where EMPNO in (select distinct MGR from EMP where MGR is not null);</span><br><span class="line">+-------+-------+</span><br><span class="line">| EMPNO | ENAME |</span><br><span class="line">+-------+-------+</span><br><span class="line">|  7902 | FORD  |</span><br><span class="line">|  7698 | BLAKE |</span><br><span class="line">|  7839 | KING  |</span><br><span class="line">|  7566 | JONES |</span><br><span class="line">|  7788 | SCOTT |</span><br><span class="line">|  7782 | CLARK |</span><br><span class="line">+-------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>查询哪些人的薪水高于员工的平均薪水，需要显示员工编号，员工姓名，薪水<br>实现思路：</li>
</ul>
<ol>
<li>取得平均薪水<blockquote>
<p>select avg(sal) from EMP;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select avg(sal) from EMP;</span><br><span class="line">+-------------+</span><br><span class="line">| avg(sal)    |</span><br><span class="line">+-------------+</span><br><span class="line">| 2073.214286 |</span><br><span class="line">+-------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li>取得大于平均薪水的员工<blockquote>
<p>select empno, ename, sal from EMP where sal &gt; (select avg(sal) from EMP);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt;  select empno, ename, sal from EMP where sal &gt; (select avg(sal) from EMP);</span><br><span class="line">+-------+-------+---------+</span><br><span class="line">| empno | ename | sal     |</span><br><span class="line">+-------+-------+---------+</span><br><span class="line">|  7566 | JONES | 2975.00 |</span><br><span class="line">|  7698 | BLAKE | 2850.00 |</span><br><span class="line">|  7782 | CLARK | 2450.00 |</span><br><span class="line">|  7788 | SCOTT | 3000.00 |</span><br><span class="line">|  7839 | KING  | 5000.00 |</span><br><span class="line">|  7902 | FORD  | 3000.00 |</span><br><span class="line">+-------+-------+---------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="在from语句中使用子查询，可以将该子查询看做一张表"><a href="#在from语句中使用子查询，可以将该子查询看做一张表" class="headerlink" title="在from语句中使用子查询，可以将该子查询看做一张表"></a><font color="#f2711c">在from语句中使用子查询，可以将该子查询看做一张表</font></h5><ul>
<li>查询员工信息，查询哪些人是管理者，要求显示出其员工编号和员工姓名</li>
</ul>
<ol>
<li>首先取得管理者的编号，去除重复的<blockquote>
<p>select distinct mgr from EMP where mgr is not null;</p>
</blockquote>
</li>
<li>将以上查询作为一张表，放到from语句的后面<blockquote>
<p>select e.empno,e.ename from EMP e join (select distinct mgr from EMP where mgr is not null) m on e.empno = m.mgr;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select e.empno,e.ename from EMP e join (select distinct mgr from EMP where mgr is not null) m on e.empno = m.mgr;</span><br><span class="line">+-------+-------+</span><br><span class="line">| empno | ename |</span><br><span class="line">+-------+-------+</span><br><span class="line">|  7902 | FORD  |</span><br><span class="line">|  7698 | BLAKE |</span><br><span class="line">|  7839 | KING  |</span><br><span class="line">|  7566 | JONES |</span><br><span class="line">|  7788 | SCOTT |</span><br><span class="line">|  7782 | CLARK |</span><br><span class="line">+-------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>查询各部门的平均薪水所属等级，需要显示部门编号，平均薪水，等级编号</li>
</ul>
<ol>
<li>首先取得各个部门平均薪水<blockquote>
<p>select deptno,avg(sal) from EMP group by deptno</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select deptno,avg(sal) from EMP group by deptno;</span><br><span class="line">+--------+-------------+</span><br><span class="line">| deptno | avg(sal)    |</span><br><span class="line">+--------+-------------+</span><br><span class="line">|     10 | 2916.666667 |</span><br><span class="line">|     20 | 2175.000000 |</span><br><span class="line">|     30 | 1566.666667 |</span><br><span class="line">+--------+-------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li>将部门的平均薪水作为一张表与薪水等级表建立连接，取得等级<blockquote>
<p>select m.deptno,avg_sal,n.grade from (select deptno,avg(sal) avg_sal from EMP group by deptno) m join SALGRADE n on (m.avg_sal between n.LOSAL and n.HISAL);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select m.deptno,avg_sal,n.grade from (select deptno,avg(sal) avg_sal from EMP group by deptno) m join SALGRADE n on (m.avg_sal between n.LOSAL and n.HISAL);</span><br><span class="line">+--------+-------------+-------+</span><br><span class="line">| deptno | avg_sal     | grade |</span><br><span class="line">+--------+-------------+-------+</span><br><span class="line">|     10 | 2916.666667 |     4 |</span><br><span class="line">|     20 | 2175.000000 |     4 |</span><br><span class="line">|     30 | 1566.666667 |     3 |</span><br><span class="line">+--------+-------------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="在select语句中使用子查询"><a href="#在select语句中使用子查询" class="headerlink" title="在select语句中使用子查询"></a><font color="#f2711c">在select语句中使用子查询</font></h5><ul>
<li>查询员工信息，并显示出员工所属的部门名称<br>第一种做法，将员工表和部门表连接<blockquote>
<p>select e.ename, d.dname from EMP e, dept d where e.deptno=d.deptno;<br>第二种做法，在select语句中再次嵌套select语句完成部分名称的查询<br>select e.ename, (select d.dname from dept d where e.deptno=d.deptno) as dname from EMP e;</p>
</blockquote>
</li>
</ul>
<h4 id="union合并集合（相加）"><a href="#union合并集合（相加）" class="headerlink" title="union合并集合（相加）"></a><font color="#f2711c">union合并集合（相加）</font></h4><ol>
<li>查询job包含MANAGER和包含SALESMAN的员工<blockquote>
<p>select * from EMP where job in(‘MANAGER’, ‘SALESMAN’);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP where job in(&#x27;MANAGER&#x27;, &#x27;SALESMAN&#x27;);</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER  | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER  | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li>采用union来合并<blockquote>
<p>select * from EMP where job=’MANAGER’<br>union<br>select * from EMP where job=’SALESMAN’</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP where job=&#x27;MANAGER&#x27;</span><br><span class="line">    -&gt; union</span><br><span class="line">    -&gt; select * from EMP where job=&#x27;SALESMAN&#x27;;</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7566 | JONES  | MANAGER  | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7698 | BLAKE  | MANAGER  | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK  | MANAGER  | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7844 | TURNER | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="limit的使用"><a href="#limit的使用" class="headerlink" title="limit的使用"></a>limit的使用</h4><p>mysql提供了limit，主要用于提取前几条或者中间某几行数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table limit m,n</span><br><span class="line">其中m是记录开始的index，从0开始，表示第一条记录</span><br><span class="line">n是指从第m+1条开始，取n条</span><br><span class="line">select * from tablename limit 2,4</span><br><span class="line">即取出第3条至第6条，4条记录</span><br></pre></td></tr></table></figure>

<h5 id="取得前5条数据"><a href="#取得前5条数据" class="headerlink" title="取得前5条数据"></a><font color="#f2711c">取得前5条数据</font></h5><blockquote>
<p>select * from EMP limit 0,5</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP limit 5;</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK    | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER  | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from EMP limit 0,5;</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME  | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH  | CLERK    | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN  | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD   | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES  | MANAGER  | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">+-------+--------+----------+------+------------+---------+---------+--------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="从第二条开始取两条数据"><a href="#从第二条开始取两条数据" class="headerlink" title="从第二条开始取两条数据"></a><font color="#f2711c">从第二条开始取两条数据</font></h5><blockquote>
<p>select * from EMP limit 1,2;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP limit 1,2;</span><br><span class="line">+-------+-------+----------+------+------------+---------+--------+--------+</span><br><span class="line">| EMPNO | ENAME | JOB      | MGR  | HIREDATE   | SAL     | COMM   | DEPTNO |</span><br><span class="line">+-------+-------+----------+------+------------+---------+--------+--------+</span><br><span class="line">|  7499 | ALLEN | SALESMAN | 7698 | 1981-02-20 | 1600.00 | 300.00 |     30 |</span><br><span class="line">|  7521 | WARD  | SALESMAN | 7698 | 1981-02-22 | 1250.00 | 500.00 |     30 |</span><br><span class="line">+-------+-------+----------+------+------------+---------+--------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="取得薪水最高的前5名"><a href="#取得薪水最高的前5名" class="headerlink" title="取得薪水最高的前5名"></a><font color="#f2711c">取得薪水最高的前5名</font></h5><blockquote>
<p>select * from EMP order by sal desc limit 5;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP order by sal desc limit 5;</span><br><span class="line">+-------+-------+-----------+------+------------+---------+------+--------+</span><br><span class="line">| EMPNO | ENAME | JOB       | MGR  | HIREDATE   | SAL     | COMM | DEPTNO |</span><br><span class="line">+-------+-------+-----------+------+------------+---------+------+--------+</span><br><span class="line">|  7839 | KING  | PRESIDENT | NULL | 1981-11-17 | 5000.00 | NULL |     10 |</span><br><span class="line">|  7902 | FORD  | ANALYST   | 7566 | 1981-12-03 | 3000.00 | NULL |     20 |</span><br><span class="line">|  7788 | SCOTT | ANALYST   | 7566 | 1987-04-19 | 3000.00 | NULL |     20 |</span><br><span class="line">|  7566 | JONES | MANAGER   | 7839 | 1981-04-02 | 2975.00 | NULL |     20 |</span><br><span class="line">|  7698 | BLAKE | MANAGER   | 7839 | 1981-05-01 | 2850.00 | NULL |     30 |</span><br><span class="line">+-------+-------+-----------+------+------------+---------+------+--------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="表"><a href="#表" class="headerlink" title="表"></a>表</h4><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a><font color="#f2711c">创建表</font></h5><h6 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a><font color="#f2711c">语法格式</font></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table tableName(</span><br><span class="line">  columnName dataType(length),</span><br><span class="line">  ......</span><br><span class="line">  columnName dataType(length)</span><br><span class="line">);</span><br><span class="line">set character_set_results=&#x27;gbk&#x27;;</span><br><span class="line"></span><br><span class="line">show variables like &#x27;%char%&#x27;</span><br><span class="line"></span><br><span class="line">创建表的时候，表中有字段，每一个字段有：</span><br><span class="line">     * 字段名</span><br><span class="line">     * 字段数据类型</span><br><span class="line">     * 字段长度限制</span><br><span class="line">     * 字段约束</span><br></pre></td></tr></table></figure>
<h6 id="MySql常用数据类型"><a href="#MySql常用数据类型" class="headerlink" title="MySql常用数据类型"></a><font color="#f2711c">MySql常用数据类型</font></h6><table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Char(长度)</td>
<td>定长字符串，存储空间大小固定，适合作为主键或外键</td>
</tr>
<tr>
<td>Varchar(长度)</td>
<td>变长字符串，存储空间等于实际数据空间</td>
</tr>
<tr>
<td>double(有效数字位数，小数位)</td>
<td>数值型</td>
</tr>
<tr>
<td>Float(有效数字位，小数位)</td>
<td>数值型</td>
</tr>
<tr>
<td>Int(长度)</td>
<td>整型</td>
</tr>
<tr>
<td>bigint(长度)</td>
<td>长整型</td>
</tr>
<tr>
<td>Date</td>
<td>日期型 年月日</td>
</tr>
<tr>
<td>DateTime</td>
<td>日期型 年月日 时分秒 毫秒</td>
</tr>
<tr>
<td>time</td>
<td>日期型 时分秒</td>
</tr>
<tr>
<td>BLOB</td>
<td>Binary Large OBject（二进制大对象）</td>
</tr>
<tr>
<td>CLOB</td>
<td>Character Large OBject（字符大对象）</td>
</tr>
</tbody></table>
<h6 id="建立学生信息表"><a href="#建立学生信息表" class="headerlink" title="建立学生信息表"></a><font color="#f2711c">建立学生信息表</font></h6><ul>
<li>建立学生信息表，字段包括：学号、姓名、性别、出生日期、email、班级标识别<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table t_student</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; student_id int(10),</span><br><span class="line">    -&gt; student_name varchar(20),</span><br><span class="line">    -&gt; sex char(2),</span><br><span class="line">    -&gt; birthday date,</span><br><span class="line">    -&gt; email varchar(30),</span><br><span class="line">    -&gt; class_id int(3)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc t_student;</span><br><span class="line">+--------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field        | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------------+-------------+------+-----+---------+-------+</span><br><span class="line">| student_id   | int(10)     | YES  |     | NULL    |       |</span><br><span class="line">| student_name | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| sex          | char(2)     | YES  |     | NULL    |       |</span><br><span class="line">| birthday     | date        | YES  |     | NULL    |       |</span><br><span class="line">| email        | varchar(30) | YES  |     | NULL    |       |</span><br><span class="line">| class_id     | int(3)      | YES  |     | NULL    |       |</span><br><span class="line">+--------------+-------------+------+-----+---------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h6 id="向t-student表中加入数据"><a href="#向t-student表中加入数据" class="headerlink" title="向t_student表中加入数据"></a><font color="#f2711c">向t_student表中加入数据</font></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> mysql&gt; insert into t_student(student_id,student_name,sex,birthday,email,class_id) values (1001,&#x27;zhangsan&#x27;,&#x27;m&#x27;,&#x27;1988-01-01&#x27;,&#x27;qqq@163.com&#x27;,10);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_student;</span><br><span class="line">+------------+--------------+------+------------+-------------+----------+</span><br><span class="line">| student_id | student_name | sex  | birthday   | email       | class_id |</span><br><span class="line">+------------+--------------+------+------------+-------------+----------+</span><br><span class="line">|       1001 | zhangsan     | m    | 1988-01-01 | qqq@163.com |       10 |</span><br><span class="line">+------------+--------------+------+------------+-------------+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="向t-student表中加入数据（使用默认值）"><a href="#向t-student表中加入数据（使用默认值）" class="headerlink" title="向t_student表中加入数据（使用默认值）"></a><font color="#f2711c">向t_student表中加入数据（使用默认值）</font></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop table if exists t_student</span><br><span class="line">    -&gt; create table t_student( student_id int(10), student_name varchar(20), sex char(2) default &#x27;m&#x27;, birthday date, email varchar(30), classes_id int(3) )</span><br><span class="line">    -&gt; insert into t_student(student_id, student_name, birthday, email, classes_id) values (1002,&#x27;zhangsan&#x27;,&#x27;1988-01-01&#x27;,&#x27;qqq@163&#x27;,10);</span><br><span class="line">mysql&gt; select * from t_student;</span><br><span class="line">+------------+--------------+------+------------+---------+------------+</span><br><span class="line">| student_id | student_name | sex  | birthday   | email   | classes_id |</span><br><span class="line">+------------+--------------+------+------------+---------+------------+</span><br><span class="line">|       1002 | zhangsan     | m    | 1988-01-01 | qqq@163 |         10 |</span><br><span class="line">+------------+--------------+------+------------+---------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h5 id="增加-删除-修改表结构"><a href="#增加-删除-修改表结构" class="headerlink" title="增加/删除/修改表结构"></a><font color="#f2711c">增加/删除/修改表结构</font></h5><p>采用alter table 来增加/删除/修改表结构，不影响表中的数据</p>
<h6 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a><font color="#f2711c">添加字段</font></h6><ul>
<li><p>如：需求发生改变，需要向t_student中加入联系电话字段，字段名称为：contatct_tel 类型为varchar(40)</p>
<blockquote>
<p>alter table t_student add  contact_tel varchar(40);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table t_student add contact_tel varchar(40);</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc t_student;</span><br><span class="line">+--------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field        | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------------+-------------+------+-----+---------+-------+</span><br><span class="line">| student_id   | int(10)     | YES  |     | NULL    |       |</span><br><span class="line">| student_name | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| sex          | char(2)     | YES  |     | m       |       |</span><br><span class="line">| birthday     | date        | YES  |     | NULL    |       |</span><br><span class="line">| email        | varchar(30) | YES  |     | NULL    |       |</span><br><span class="line">| classes_id   | int(3)      | YES  |     | NULL    |       |</span><br><span class="line">| contact_tel  | varchar(40) | YES  |     | NULL    |       |</span><br><span class="line">+--------------+-------------+------+-----+---------+-------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><p>用mysql创建完表后，如何设置主键</p>
<blockquote>
<p>alter table t_student add PRIMARY KEY (student_id);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table t_student add PRIMARY KEY (student_id);</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc t_student;</span><br><span class="line">+--------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field        | Type         | Null | Key | Default | Extra |</span><br><span class="line">+--------------+--------------+------+-----+---------+-------+</span><br><span class="line">| student_id   | int(10)      | NO   | PRI | NULL    |       |</span><br><span class="line">| student_name | varchar(100) | YES  |     | NULL    |       |</span><br><span class="line">| sex          | char(2)      | YES  |     | m       |       |</span><br><span class="line">| birthday     | date         | YES  |     | NULL    |       |</span><br><span class="line">| email        | varchar(100) | YES  |     | NULL    |       |</span><br><span class="line">| classes_id   | int(3)       | YES  |     | NULL    |       |</span><br><span class="line">+--------------+--------------+------+-----+---------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h6 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a><font color="#f2711c">修改字段</font></h6></li>
<li><p>如：student_name无法满足需求，长度需要更改为100</p>
<blockquote>
<p>alter table t_student modify student_name varchar(100);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc t_student;</span><br><span class="line">+--------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field        | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------------+-------------+------+-----+---------+-------+</span><br><span class="line">| student_id   | int(10)     | YES  |     | NULL    |       |</span><br><span class="line">| student_name | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| sex          | char(2)     | YES  |     | m       |       |</span><br><span class="line">| birthday     | date        | YES  |     | NULL    |       |</span><br><span class="line">| email        | varchar(30) | YES  |     | NULL    |       |</span><br><span class="line">| classes_id   | int(3)      | YES  |     | NULL    |       |</span><br><span class="line">| contact_tel  | varchar(40) | YES  |     | NULL    |       |</span><br><span class="line">+--------------+-------------+------+-----+---------+-------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table t_student modify student_name varchar(100);</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc t_student;</span><br><span class="line">+--------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field        | Type         | Null | Key | Default | Extra |</span><br><span class="line">+--------------+--------------+------+-----+---------+-------+</span><br><span class="line">| student_id   | int(10)      | YES  |     | NULL    |       |</span><br><span class="line">| student_name | varchar(100) | YES  |     | NULL    |       |</span><br><span class="line">| sex          | char(2)      | YES  |     | m       |       |</span><br><span class="line">| birthday     | date         | YES  |     | NULL    |       |</span><br><span class="line">| email        | varchar(30)  | YES  |     | NULL    |       |</span><br><span class="line">| classes_id   | int(3)       | YES  |     | NULL    |       |</span><br><span class="line">| contact_tel  | varchar(40)  | YES  |     | NULL    |       |</span><br><span class="line">+--------------+--------------+------+-----+---------+-------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h6 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a><font color="#f2711c">删除字段</font></h6></li>
<li><p>如：删除联系电话字段</p>
<blockquote>
<p>alter table t_student drop contact_tel;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc t_student;</span><br><span class="line">+--------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field        | Type         | Null | Key | Default | Extra |</span><br><span class="line">+--------------+--------------+------+-----+---------+-------+</span><br><span class="line">| student_id   | int(10)      | YES  |     | NULL    |       |</span><br><span class="line">| student_name | varchar(100) | YES  |     | NULL    |       |</span><br><span class="line">| sex          | char(2)      | YES  |     | m       |       |</span><br><span class="line">| birthday     | date         | YES  |     | NULL    |       |</span><br><span class="line">| email        | varchar(30)  | YES  |     | NULL    |       |</span><br><span class="line">| classes_id   | int(3)       | YES  |     | NULL    |       |</span><br><span class="line">| contact_tel  | varchar(40)  | YES  |     | NULL    |       |</span><br><span class="line">+--------------+--------------+------+-----+---------+-------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table t_student drop contact_tel;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; desc t_student;</span><br><span class="line">+--------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field        | Type         | Null | Key | Default | Extra |</span><br><span class="line">+--------------+--------------+------+-----+---------+-------+</span><br><span class="line">| student_id   | int(10)      | YES  |     | NULL    |       |</span><br><span class="line">| student_name | varchar(100) | YES  |     | NULL    |       |</span><br><span class="line">| sex          | char(2)      | YES  |     | m       |       |</span><br><span class="line">| birthday     | date         | YES  |     | NULL    |       |</span><br><span class="line">| email        | varchar(30)  | YES  |     | NULL    |       |</span><br><span class="line">| classes_id   | int(3)       | YES  |     | NULL    |       |</span><br><span class="line">+--------------+--------------+------+-----+---------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="添加、修改和删除表数据"><a href="#添加、修改和删除表数据" class="headerlink" title="添加、修改和删除表数据"></a><font color="#f2711c">添加、修改和删除表数据</font></h5><h6 id="insert"><a href="#insert" class="headerlink" title="insert"></a><font color="#f2711c">insert</font></h6><ul>
<li><p><font color="#f2711c">insert语法格式</font></p>
<blockquote>
<p>insert into 表名(字段，…) values (值…)</p>
</blockquote>
</li>
<li><p><font color="#f2711c">省略字段的插入</font><br>不建议使用此种方式，因为当数据库表中的字段位置发生改变的时候会影响到insert语句</p>
<blockquote>
<p>insert into EMP values(9999,’zhangsan’,’MANAGER’,null,null,3000,500,10);</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into EMP values(9999,&#x27;zhangsan&#x27;,&#x27;MANAGER&#x27;,null,null,3000,500,10);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from EMP;</span><br><span class="line">+-------+----------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME    | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+----------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH    | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN    | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD     | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES    | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN   | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE    | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK    | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7788 | SCOTT    | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7839 | KING     | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER   | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7876 | ADAMS    | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES    | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7902 | FORD     | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7934 | MILLER   | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">|  9999 | zhangsan | MANAGER   | NULL | NULL       | 3000.00 |  500.00 |     10 |</span><br><span class="line">+-------+----------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">15 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><font color="#f2711c">指定字段的插入</font><br>建议使用此种方式<blockquote>
<p>insert into t_student(student_id,student_name,sex,birthday,email,classes_id) values (1003,’dh’,’n’,now(),‘lsabella@163’,11);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t_student(student_id,student_name,sex,birthday,email,classes_id) values (1003,&#x27;dh&#x27;,&#x27;n&#x27;,now(),&#x27;lsabella@163&#x27;,11);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_student;</span><br><span class="line">+------------+--------------+------+------------+--------------+------------+</span><br><span class="line">| student_id | student_name | sex  | birthday   | email        | classes_id |</span><br><span class="line">+------------+--------------+------+------------+--------------+------------+</span><br><span class="line">|       1002 | baishu       | m    | 1988-01-01 | qqq@163      |         10 |</span><br><span class="line">|       1003 | dh           | n    | 2021-11-03 | lsabella@163 |         11 |</span><br><span class="line">+------------+--------------+------+------------+--------------+------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="danger">
出现了主键重复的错误，主键表示了记录的唯一性，不能重复
</div></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t_student(student_id,student_name,sex,birthday,email,classes_id) values (1002,&#x27;haha&#x27;,&#x27;n&#x27;,now(),&#x27;haha@163&#x27;,11);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1002&#x27; for key &#x27;PRIMARY&#x27;</span><br></pre></td></tr></table></figure>

<ul>
<li><font color="#f2711c">如何插入日期</font><div class="info">
（1）插入的日期格式和显示的日期格式一致
</div></li>
</ul>
<blockquote>
<p>insert into t_student(student_id,student_name,sex,birthday,email,classes_id) values (1004,’haha1’,’n’,’1991-01-01’,‘haha@163’,11);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t_student(student_id,student_name,sex,birthday,email,classes_id) values (1004,&#x27;haha1&#x27;,&#x27;n&#x27;,&#x27;1991-01-01&#x27;,&#x27;haha@163&#x27;,11);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_student;</span><br><span class="line">+------------+--------------+------+------------+--------------+------------+</span><br><span class="line">| student_id | student_name | sex  | birthday   | email        | classes_id |</span><br><span class="line">+------------+--------------+------+------------+--------------+------------+</span><br><span class="line">|       1002 | baishu       | m    | 1988-01-01 | qqq@163      |         10 |</span><br><span class="line">|       1003 | dh           | n    | 2021-11-03 | lsabella@163 |         11 |</span><br><span class="line">|       1004 | haha1        | n    | 1991-01-01 | haha@163     |         11 |</span><br><span class="line">+------------+--------------+------+------------+--------------+------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="info">
（2）采用str_to_date
</div>

<blockquote>
<p>insert into t_student(student_id,student_name,sex,birthday,email,classes_id) values (1005,’haha2’,’n’,str_to_date(‘1985-01-01’,’%Y-%m-%d’),‘haha@163’,11);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t_student(student_id,student_name,sex,birthday,email,classes_id) values (1005,&#x27;haha2&#x27;,&#x27;n&#x27;,str_to_date(&#x27;1985-01-01&#x27;,&#x27;%Y-%m-%d&#x27;),&#x27;haha@163&#x27;,11);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_student;</span><br><span class="line">+------------+--------------+------+------------+--------------+------------+</span><br><span class="line">| student_id | student_name | sex  | birthday   | email        | classes_id |</span><br><span class="line">+------------+--------------+------+------------+--------------+------------+</span><br><span class="line">|       1002 | baishu       | m    | 1988-01-01 | qqq@163      |         10 |</span><br><span class="line">|       1003 | dh           | n    | 2021-11-03 | lsabella@163 |         11 |</span><br><span class="line">|       1004 | haha1        | n    | 1991-01-01 | haha@163     |         11 |</span><br><span class="line">|       1005 | haha2        | n    | 1985-01-01 | haha@163     |         11 |</span><br><span class="line">+------------+--------------+------+------------+--------------+------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<div class="info">
（3）添加系统日期（now()）
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t_student(student_id,student_name,sex,birthday,email,classes_id) values (1006,&#x27;haha3&#x27;,&#x27;n&#x27;,now(),&#x27;haha@163&#x27;,11);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li><font color="#f2711c">表复制</font><blockquote>
<p>create table t_student_bak as select student_id,student_name,sex,email,classes_id from t_student;</p>
</blockquote>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table t_student_bak as select student_id,student_name,sex,email,classes_id from t_student;</span><br><span class="line">Query OK, 5 rows affected (0.02 sec)</span><br><span class="line">Records: 5  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+-----------------------+</span><br><span class="line">| Tables_in_baishu_demo |</span><br><span class="line">+-----------------------+</span><br><span class="line">| DEPT                  |</span><br><span class="line">| EMP                   |</span><br><span class="line">| SALGRADE              |</span><br><span class="line">| t_student             |</span><br><span class="line">| t_student_bak         |</span><br><span class="line">+-----------------------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_student_bak;</span><br><span class="line">+------------+--------------+------+--------------+------------+</span><br><span class="line">| student_id | student_name | sex  | email        | classes_id |</span><br><span class="line">+------------+--------------+------+--------------+------------+</span><br><span class="line">|       1002 | baishu       | m    | qqq@163      |         10 |</span><br><span class="line">|       1003 | dh           | n    | lsabella@163 |         11 |</span><br><span class="line">|       1004 | haha1        | n    | haha@163     |         11 |</span><br><span class="line">|       1005 | haha2        | n    | haha@163     |         11 |</span><br><span class="line">|       1006 | haha3        | n    | haha@163     |         11 |</span><br><span class="line">+------------+--------------+------+--------------+------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上方式，会自动创建表，将符合查询条件的数据自动复制到创建的表中</p>
<ul>
<li><font color="#f2711c">如何将查询的数据直接放到已经存在的表中，可以使用条件</font></li>
</ul>
<blockquote>
<p>insert into t_student_bak select * from t_student where student_id = 1003;</p>
</blockquote>
<blockquote>
<p>insert into t_student_bak select student_id,student_name,sex,birthday,classes_id from t_student where student_id = 1003;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t_student_bak;</span><br><span class="line">+------------+--------------+------+------------+----------+------------+</span><br><span class="line">| student_id | student_name | sex  | birthday   | email    | classes_id |</span><br><span class="line">+------------+--------------+------+------------+----------+------------+</span><br><span class="line">|       1002 | baishu       | m    | 1988-01-01 | qqq@163  |         10 |</span><br><span class="line">|       1004 | haha1        | n    | 1991-01-01 | haha@163 |         11 |</span><br><span class="line">|       1005 | haha2        | n    | 1985-01-01 | haha@163 |         11 |</span><br><span class="line">|       1006 | haha3        | n    | 2021-11-03 | haha@163 |         11 |</span><br><span class="line">+------------+--------------+------+------------+----------+------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_student_bak select * from t_student where student_id = 1003;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_student_bak;</span><br><span class="line">+------------+--------------+------+------------+--------------+------------+</span><br><span class="line">| student_id | student_name | sex  | birthday   | email        | classes_id |</span><br><span class="line">+------------+--------------+------+------------+--------------+------------+</span><br><span class="line">|       1002 | baishu       | m    | 1988-01-01 | qqq@163      |         10 |</span><br><span class="line">|       1004 | haha1        | n    | 1991-01-01 | haha@163     |         11 |</span><br><span class="line">|       1005 | haha2        | n    | 1985-01-01 | haha@163     |         11 |</span><br><span class="line">|       1006 | haha3        | n    | 2021-11-03 | haha@163     |         11 |</span><br><span class="line">|       1003 | dh           | n    | 2021-11-03 | lsabella@163 |         11 |</span><br><span class="line">+------------+--------------+------+------------+--------------+------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">表结构不一致</span><br><span class="line">mysql&gt; insert into t_student_bak select student_id,student_name,sex,birthday,classes_id from t_student where student_id = 1003;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<h6 id="update"><a href="#update" class="headerlink" title="update"></a><font color="#f2711c">update</font></h6><ul>
<li> <font color="#f2711c">语法格式</font><br>可以修改数据，可以根据条件修改数据<br>语法格式:update 表名 set 字段名称1=需要修改的值1, 字段名称2=需要修改的值2 where …<blockquote>
<p>update t_student_bak set student_name = ‘test1’ where student_id = 1003;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; update t_student_bak set student_name = &#x27;test1&#x27; where student_id = 1003;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line">mysql&gt; select * from t_student_bak;</span><br><span class="line">+------------+--------------+------+------------+------------+</span><br><span class="line">| student_id | student_name | sex  | birthday   | classes_id |</span><br><span class="line">+------------+--------------+------+------------+------------+</span><br><span class="line">|       1002 | baishu       | m    | 1988-01-01 |         10 |</span><br><span class="line">|       1004 | haha1        | n    | 1991-01-01 |         11 |</span><br><span class="line">|       1005 | haha2        | n    | 1985-01-01 |         11 |</span><br><span class="line">|       1006 | haha3        | n    | 2021-11-03 |         11 |</span><br><span class="line">|       1003 | test1        | n    | 2021-11-03 |         11 |</span><br><span class="line">+------------+--------------+------+------------+------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="delete"><a href="#delete" class="headerlink" title="delete"></a><font color="#f2711c">delete</font></h6><p>可以删除数据，可以根据条件删除数据<br>语法格式:delete from表名 where …</p>
<ul>
<li>删除津贴为null的员工<blockquote>
<p>delete from EMP where comm is null;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from EMP;</span><br><span class="line">+-------+----------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME    | JOB       | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+----------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7369 | SMITH    | CLERK     | 7902 | 1980-12-17 |  800.00 |    NULL |     20 |</span><br><span class="line">|  7499 | ALLEN    | SALESMAN  | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD     | SALESMAN  | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7566 | JONES    | MANAGER   | 7839 | 1981-04-02 | 2975.00 |    NULL |     20 |</span><br><span class="line">|  7654 | MARTIN   | SALESMAN  | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7698 | BLAKE    | MANAGER   | 7839 | 1981-05-01 | 2850.00 |    NULL |     30 |</span><br><span class="line">|  7782 | CLARK    | MANAGER   | 7839 | 1981-06-09 | 2450.00 |    NULL |     10 |</span><br><span class="line">|  7788 | SCOTT    | ANALYST   | 7566 | 1987-04-19 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7839 | KING     | PRESIDENT | NULL | 1981-11-17 | 5000.00 |    NULL |     10 |</span><br><span class="line">|  7844 | TURNER   | SALESMAN  | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  7876 | ADAMS    | CLERK     | 7788 | 1987-05-23 | 1100.00 |    NULL |     20 |</span><br><span class="line">|  7900 | JAMES    | CLERK     | 7698 | 1981-12-03 |  950.00 |    NULL |     30 |</span><br><span class="line">|  7902 | FORD     | ANALYST   | 7566 | 1981-12-03 | 3000.00 |    NULL |     20 |</span><br><span class="line">|  7934 | MILLER   | CLERK     | 7782 | 1982-01-23 | 1300.00 |    NULL |     10 |</span><br><span class="line">|  9999 | zhangsan | MANAGER   | NULL | NULL       | 3000.00 |  500.00 |     10 |</span><br><span class="line">+-------+----------+-----------+------+------------+---------+---------+--------+</span><br><span class="line">15 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; delete from EMP where comm is null;</span><br><span class="line">Query OK, 10 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from EMP;</span><br><span class="line">+-------+----------+----------+------+------------+---------+---------+--------+</span><br><span class="line">| EMPNO | ENAME    | JOB      | MGR  | HIREDATE   | SAL     | COMM    | DEPTNO |</span><br><span class="line">+-------+----------+----------+------+------------+---------+---------+--------+</span><br><span class="line">|  7499 | ALLEN    | SALESMAN | 7698 | 1981-02-20 | 1600.00 |  300.00 |     30 |</span><br><span class="line">|  7521 | WARD     | SALESMAN | 7698 | 1981-02-22 | 1250.00 |  500.00 |     30 |</span><br><span class="line">|  7654 | MARTIN   | SALESMAN | 7698 | 1981-09-28 | 1250.00 | 1400.00 |     30 |</span><br><span class="line">|  7844 | TURNER   | SALESMAN | 7698 | 1981-09-08 | 1500.00 |    0.00 |     30 |</span><br><span class="line">|  9999 | zhangsan | MANAGER  | NULL | NULL       | 3000.00 |  500.00 |     10 |</span><br><span class="line">+-------+----------+----------+------+------------+---------+---------+--------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="创建表加入约束"><a href="#创建表加入约束" class="headerlink" title="创建表加入约束"></a><font color="#f2711c">创建表加入约束</font></h5><div class="info">

<blockquote>
<p>常见的约束</p>
<ul>
<li>非空约束，not null</li>
<li>唯一约束，unique</li>
<li>主键约束，primary key</li>
<li>外键约束，foreign key</li>
<li>自定义检查约束，check（不建议使用）（在mysql中现在还不支持）</li>
</ul>
</blockquote>
</div>

<h6 id="非空约束，not-null"><a href="#非空约束，not-null" class="headerlink" title="非空约束，not null"></a><font color="#f2711c">非空约束，not null</font></h6><p>非空约束，针对某个字段设置其值不为空，如：学生的姓名不能为空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_student; </span><br><span class="line">create table t_student(</span><br><span class="line">	student_id  	int(10),</span><br><span class="line">	student_name 	varchar(20) not null,</span><br><span class="line">	sex		char(2)  default  &#x27;m&#x27;,</span><br><span class="line">	birthday	date, </span><br><span class="line">	email		varchar(30),</span><br><span class="line">	classes_id	int(3)	</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">insert into t_student(student_id, birthday, email, classes_id) </span><br><span class="line">values</span><br><span class="line">(1002, &#x27;1988-01-01&#x27;, &#x27;qqq@163.com&#x27;, 10)</span><br></pre></td></tr></table></figure>

<h6 id="唯一约束，unique"><a href="#唯一约束，unique" class="headerlink" title="唯一约束，unique"></a><font color="#f2711c">唯一约束，unique</font></h6><div class="info">
唯一性约束修饰的字段具有唯一性，不能重复。但可以为null。
</div>

<blockquote>
<p>案例：给某一列添加unique</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> drop table if exists t_user;</span><br><span class="line"> create table t_user(</span><br><span class="line"> id int,</span><br><span class="line">username varchar(255) unique  //列级约束</span><br><span class="line">);</span><br><span class="line">insert into t_user values(1,&#x27;zhangsan&#x27;);		</span><br><span class="line">insert into t_user values(2,&#x27;zhangsan&#x27;);  //出现编译错误，唯一性约束，该字段与上一行字段重复，但可以为null！</span><br><span class="line">ERROR 1062 (23000) : Duplicate entry &#x27;zhangsan&#x27; for key &#x27;username&#x27;</span><br><span class="line"></span><br><span class="line">insert into t_user(id) values(2);</span><br><span class="line">       insert into t_user(id) values(3);</span><br><span class="line">insert into t_user(id) values(4);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>案例：给两个列或者多个列添加unique</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> drop table if exists t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">    id int,</span><br><span class="line">    usercode varchar(255),</span><br><span class="line">    username varchar(255),</span><br><span class="line">    unique(usercode,username)  //多个字段联合起来添加一个约束unique 【表级约束】</span><br><span class="line">	  );</span><br><span class="line"></span><br><span class="line">insert into t_user values(1,&#x27;111&#x27;,&#x27;zs&#x27;);</span><br><span class="line">insert into t_user values(2,&#x27;111&#x27;,&#x27;ls&#x27;);</span><br><span class="line">insert into t_user values(3,&#x27;222&#x27;,&#x27;zs&#x27;);</span><br><span class="line">select * from t_user;</span><br><span class="line">insert into t_user values(4,&#x27;111&#x27;,&#x27;zs&#x27;);  //出现编译错误！</span><br><span class="line">ERROR 1062 (23000) : Duplicate entry &#x27;111-zs&#x27; for key &#x27;usercode&#x27;</span><br><span class="line"></span><br><span class="line">drop table if exists t_user;</span><br><span class="line">create table t_suer(</span><br><span class="line">    id int,</span><br><span class="line">    usercode varchar(255) unique,</span><br><span class="line">    username varchar(255) unique</span><br><span class="line">  );</span><br><span class="line">insert into t_user values(1,&#x27;111&#x27;,&#x27;zs&#x27;);</span><br><span class="line">insert into t_user values(2,&#x27;111&#x27;,&#x27;ls&#x27;);</span><br><span class="line">ERROR 1062 (23000) : Duplicate entry &#x27;111&#x27; for key &#x27;usercode&#x27;</span><br></pre></td></tr></table></figure>
<div class="danger">
 注意：not null约束只有列级约束，没有表级约束。
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_student; </span><br><span class="line">create table t_student(</span><br><span class="line">	student_id  	int(10),</span><br><span class="line">	student_name 	varchar(20) not null,</span><br><span class="line">	sex		char(2)  default  &#x27;m&#x27;,</span><br><span class="line">	birthday	date, </span><br><span class="line">	email		varchar(30)  unique,</span><br><span class="line">	classes_id	int(3)	</span><br><span class="line">)</span><br><span class="line">insert into t_student(student_id, student_name , sex, birthday, email, classes_id) </span><br><span class="line">values</span><br><span class="line">(1001,&#x27;zhangsan&#x27;,&#x27;m&#x27;, &#x27;1988-01-01&#x27;, &#x27;qqq@163.com&#x27;, 10)</span><br></pre></td></tr></table></figure>
以上插入了重复的email，所以出现了“违反唯一约束错误”，所以unique起作用了，同样可以为唯一约束起个约束名。
<div class="info">

<ul>
<li>查看约束</li>
</ul>
</div>

<p>关于约束名称可以到table_constraints中查询</p>
<blockquote>
<p>mysql&gt; use information_schema;</p>
</blockquote>
<blockquote>
<p>mysql&gt; select * from table_constraints where table_name = ‘t_student’;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; use information_schema;</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; select * from table_constraints where table_name = &#x27;t_student&#x27;;</span><br><span class="line">+--------------------+-------------------+-----------------+--------------+------------+-----------------+</span><br><span class="line">| CONSTRAINT_CATALOG | CONSTRAINT_SCHEMA | CONSTRAINT_NAME | TABLE_SCHEMA | TABLE_NAME | CONSTRAINT_TYPE |</span><br><span class="line">+--------------------+-------------------+-----------------+--------------+------------+-----------------+</span><br><span class="line">| def                | baishu_demo       | PRIMARY         | baishu_demo  | t_student  | PRIMARY KEY     |</span><br><span class="line">+--------------------+-------------------+-----------------+--------------+------------+-----------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div class="info">

<ul>
<li>约束的名称我们也可以自定义</li>
</ul>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_student; </span><br><span class="line">create table t_student(</span><br><span class="line">	student_id  	int(10),</span><br><span class="line">	student_name 	varchar(20) not null,</span><br><span class="line">	sex		char(2)  default  &#x27;m&#x27;,</span><br><span class="line">	birthday	date, </span><br><span class="line">  email		varchar(30)  ,</span><br><span class="line">	classes_id	int(3)	,</span><br><span class="line">  constraint email_unique unique(email) /*表级约束*/</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h6 id="主键约束，primary-key"><a href="#主键约束，primary-key" class="headerlink" title="主键约束，primary key"></a><font color="#f2711c">主键约束，primary key</font></h6><blockquote>
<p>怎么给一张表添加主键约束呢？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line">      create table t_user(</span><br><span class="line">          id int primary key,  //列级约束</span><br><span class="line">	  username varchar(255),</span><br><span class="line">	  email varchar(255)</span><br><span class="line">      );</span><br><span class="line">      insert into t_user(id,username,email) values(1,&#x27;zs&#x27;,&#x27;zs@123.com&#x27;);</span><br><span class="line">      insert into t_user(id,username,email) values(2,&#x27;ls&#x27;,&#x27;ls@123.com&#x27;);</span><br><span class="line">      insert into t_user(id,username,email) values(3,&#x27;ww&#x27;,&#x27;ww@123.com&#x27;);</span><br><span class="line">      select * from t_user;</span><br><span class="line">      +-----------------------------+</span><br><span class="line">      | id | username | email       |</span><br><span class="line">      +-----------------------------+</span><br><span class="line">      |  1 | zs       | zs@123.com  |</span><br><span class="line">      |  2 | ls       | ls@123.com  |</span><br><span class="line">      |  3 | ww       | ww@123.com  |</span><br><span class="line">      +----+----------+-------------+</span><br><span class="line"></span><br><span class="line">      insert into t_user(id,username,email) values(1,&#x27;jack&#x27;,&#x27;jack@123.com&#x27;);  //出现编译错误，主键约束，不能为null也不能重复！</span><br><span class="line">      ERROR 1364 (HY000) : Field &#x27;id&#x27; doesn&#x27;t have a default value</span><br></pre></td></tr></table></figure>
<div class="danger">

<p>根据以上的测试得出：id是主键，因为添加了主键约束，主键字段中的数据不能为null，也不能重复。</p>
<blockquote>
<p>主键的特点：不能为null，也不能重复</p>
</blockquote>
</div>

<blockquote>
<p>主键相关的术语？</p>
</blockquote>
<div class="info">

<p>主键约束 : primary key<br>主键字段 : id字段添加primary key之后，id叫做主键字段<br>主键值 : id字段中的每一个值都是主键值。</p>
</div>

<blockquote>
<p>主键有什么作用？</p>
</blockquote>
<div>

<ol>
<li>根据主键字段的字段数量来划分：</li>
</ol>
<ul>
<li>单一主键 (推荐的，常用的。)</li>
<li>复合主键(多个字段联合起来添加一个主键约束) (复合主键不建议使用，因为复合主键违背三范式。)</li>
</ul>
<ol start="2">
<li>根据主键性质来划分：</li>
</ol>
<ul>
<li>自然主键 ：主键值最好就是一个和业务没有任何关系的自然数。(这种方式是推荐的)</li>
<li>业务主键 : 主键值和系统的业务挂钩，例如：拿着银行卡的卡号做主键、拿着身份证号做为主键。(不推荐使用)最好不要拿着和业务挂钩的字段做为主键。因为以后的业务一旦发生改变的时候，主键也可能需要随着发生变化，但有的时候没有办法变化，因为变化可能会导致主键重复。</div></li>
</ul>
<blockquote>
<p>一张表的主键约束只能有1个。(必须记住)</p>
</blockquote>
<blockquote>
<p> 使用表级约束方式定义主键：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">id int,</span><br><span class="line">username varchar(255),</span><br><span class="line">primary key(id)</span><br><span class="line">);</span><br><span class="line">insert into t_user(id,username) values(1,&#x27;zs&#x27;);</span><br><span class="line">insert into t_user(id,username) values(2,&#x27;ls&#x27;);</span><br><span class="line">insert into t_user(id,username) values(3,&#x27;ws&#x27;);</span><br><span class="line">insert into t_user(id,username) values(4,&#x27;cs&#x27;);</span><br><span class="line">select * from t_user;</span><br><span class="line"></span><br><span class="line">insert into t_user(id,username) values(3,&#x27;cx&#x27;);  //出现编译错误！</span><br><span class="line">ERROR 1062 (23000) : Duplicate entry &#x27;4&#x27; for key &#x27;PRIMARY&#x27;</span><br><span class="line"></span><br><span class="line">以下内容是演示一下复合主键，不需要掌握：</span><br><span class="line">  drop table if exists t_user;</span><br><span class="line">  create table t_user(</span><br><span class="line">  id int,</span><br><span class="line">  username varchar(255),</span><br><span class="line">  password varchar(255),</span><br><span class="line">  primary key(id,username)</span><br><span class="line">  );</span><br><span class="line">  insert ......</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mysql提供主键值自增：(非常重要。)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_user;</span><br><span class="line">create table t_user(</span><br><span class="line">id int primary key auto_increment,  //id字段自动维护一个自增的数字，从1开始，以1递增。</span><br><span class="line">username varchar(255)</span><br><span class="line">);</span><br><span class="line">insert into t_user(username) values(&#x27;a&#x27;); </span><br><span class="line">insert into t_user(username) values(&#x27;b&#x27;);</span><br><span class="line">insert into t_user(username) values(&#x27;c&#x27;);</span><br><span class="line">insert into t_user(username) values(&#x27;d&#x27;);</span><br><span class="line">insert into t_user(username) values(&#x27;e&#x27;);</span><br><span class="line">insert into t_user(username) values(&#x27;f&#x27;);</span><br><span class="line">select * from t_user;</span><br><span class="line"></span><br><span class="line">提示：Oracle当中也提供了一个自增机制，叫做：序列(sequence)对象。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用列级约束定义主键：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table t_student(</span><br><span class="line">    -&gt; student_id int(10) primary key,/* 列级约束 */</span><br><span class="line">    -&gt; student_name varchar(20) not null,</span><br><span class="line">    -&gt; sex char(2) default &#x27;m&#x27;,</span><br><span class="line">    -&gt; birthday date,</span><br><span class="line">    -&gt; email varchar(30),</span><br><span class="line">    -&gt; classes_id int(3)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line">mysql&gt; insert into t_student(student_id, student_name , sex, birthday, email, classes_id)</span><br><span class="line">    -&gt; values</span><br><span class="line">    -&gt; (1001,&#x27;zhangsan&#x27;,&#x27;m&#x27;, &#x27;1988-01-01&#x27;, &#x27;qqq@163.com&#x27;, 10);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">mysql&gt; insert into t_student(student_id, student_name , sex, birthday, email, classes_id)</span><br><span class="line">    -&gt; values</span><br><span class="line">    -&gt; (1001,&#x27;zhangsan&#x27;,&#x27;m&#x27;, &#x27;1988-01-01&#x27;, &#x27;qqq@163.com&#x27;, 10);</span><br><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;1001&#x27; for key &#x27;PRIMARY&#x27;</span><br><span class="line">向以上表中加入学号为1001的两条记录，出现如下错误，因为加入了主键约束</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可通过表级约束为约束起个名称</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_student; </span><br><span class="line">create table t_student(</span><br><span class="line">	student_id  	int(10),</span><br><span class="line">	student_name 	varchar(20) not null,</span><br><span class="line">	sex		char(2)  default  &#x27;m&#x27;,</span><br><span class="line">	birthday	date, </span><br><span class="line">	email		varchar(30)  ,</span><br><span class="line">	classes_id	int(3),</span><br><span class="line">    CONSTRAINT p_id PRIMARY key (student_id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h6 id="外键约束，foreign-key"><a href="#外键约束，foreign-key" class="headerlink" title="外键约束，foreign key"></a><font color="#f2711c">外键约束，foreign key</font></h6><blockquote>
<p>关于外键约束的相关术语：</p>
</blockquote>
<div class="info">

<p>主键约束 : foreign key<br>主键字段 : 添加有外键约束的字段<br>主键值 : 外键字段中的每一个值。</p>
</div>

<blockquote>
<p>业务背景：<br>请设计数据库表，用来维护学生和班级的信息？</p>
</blockquote>
<ol>
<li> 第一种方案：一张表存储所有数据<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no(pk)          name          classno         classname</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"> 1               zs1            101          河南省平顶山市舞钢市垭口一高高三1班         </span><br><span class="line"> 2               zs2            101          河南省平顶山市舞钢市垭口一高高三1班 </span><br><span class="line"> 3               zs3            102          河南省平顶山市舞钢市垭口一高高三2班 </span><br><span class="line"> 4               zs4            102          河南省平顶山市舞钢市垭口一高高三2班</span><br><span class="line"> 5               zs5            102          河南省平顶山市舞钢市垭口一高高三2班 </span><br><span class="line"> 缺点：冗余。【不推荐】</span><br></pre></td></tr></table></figure></li>
<li>两张表(班级表和学生表)<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t_class 班级表</span><br><span class="line">cno(pk)         cname</span><br><span class="line">-------------------------------------------------------------</span><br><span class="line">        101           河南省平顶山市舞钢市垭口一高高三1班 </span><br><span class="line"> 102           河南省平顶山市舞钢市垭口一高高三2班 </span><br><span class="line"></span><br><span class="line"> t_student 学生表</span><br><span class="line"> sno(pk)        sname          classno(该字段添加外键约束fk)</span><br><span class="line"> -----------------------------------------------------------</span><br><span class="line">  1              zs1              101</span><br><span class="line">  2              zs2              101</span><br><span class="line">  3              zs3              102</span><br><span class="line">  4              zs4              102</span><br><span class="line">  5              zs5              102</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>将以上表的建表语句写出来<br>t_student中的classno字段引用t_class表中的cno字段，此时t_student表叫做子表。t_class表叫做父表。</p>
</blockquote>
<p>删除数据的时候，先删除子表，再删除父表。<br>添加数据的时候，先添加父表，再添加子表。<br>创建表的时候，先创建父表，再创建子表。<br>删除表的时候，先删除子表，再删除父表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_student;</span><br><span class="line">drop table if exists t_class;</span><br><span class="line"></span><br><span class="line">create table t_class(</span><br><span class="line"> cno int,</span><br><span class="line"> cname varchar(255),</span><br><span class="line"> primary key(cno)</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line"> create table t_student(</span><br><span class="line">   sno int,</span><br><span class="line">   sname varchar(255),</span><br><span class="line">   classno int,</span><br><span class="line">   primary key(sno),</span><br><span class="line">   foreign key(classno) references t_class(cno)</span><br><span class="line"> );</span><br><span class="line"> </span><br><span class="line"> insert into t_class values(101,&#x27;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#x27;);</span><br><span class="line"> insert into t_class values(102,&#x27;yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy&#x27;);</span><br><span class="line"></span><br><span class="line"> insert into t_student values(1,&#x27;zs1&#x27;,101);</span><br><span class="line"> insert into t_student values(2,&#x27;zs2&#x27;,101);</span><br><span class="line"> insert into t_student values(3,&#x27;zs3&#x27;,102);</span><br><span class="line"> insert into t_student values(4,&#x27;zs4&#x27;,102);</span><br><span class="line"> insert into t_student values(5,&#x27;zs5&#x27;,102);</span><br><span class="line"> insert into t_student values(6,&#x27;zs6&#x27;,102);</span><br><span class="line"> select * from t_class;</span><br><span class="line"> select * from t_student;</span><br><span class="line"></span><br><span class="line"> insert into t_student values(7,&#x27;lisi&#x27;,103);  //编译错误，引用的103，父表中没有该字段！</span><br><span class="line"> ERROR 1452 (23000) : Cannot add or update a child row :aforeign key constraint fails (bjpowernode INT YT......)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>外键值可以为NULL？<br> 外键可以为null。</p>
</blockquote>
<blockquote>
<p>外键字段引用其他表的某个字段的时候，被引用的字段必须是主键吗？<br> 注意：被引用的字段不一定是主键，但至少是具有unique约束，具有唯一性，不可重复！</p>
</blockquote>
<p>详细步骤如下：</p>
<div class="info">

<ul>
<li>首先建立班级表t_classes</li>
</ul>
</div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table t_classes(</span><br><span class="line">    -&gt; classes_id int(3),</span><br><span class="line">    -&gt; classes_name varchar(40),</span><br><span class="line">    -&gt; constraint pk_classes_id primary key(classes_id)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<div class="info">

<ul>
<li>在t_student中加入外键约束</li>
</ul>
</div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table t_student(</span><br><span class="line">    -&gt; student_id int(10),</span><br><span class="line">    -&gt; student_name varchar(20),</span><br><span class="line">    -&gt; sex char(2),</span><br><span class="line">    -&gt; birthday date,</span><br><span class="line">    -&gt; email varchar(30),</span><br><span class="line">    -&gt; classes_id int(3),</span><br><span class="line">    -&gt; constraint student_id_pk primary key(student_id),</span><br><span class="line">    -&gt; constraint fk_classes_id foreign key(classes_id) references t_classes(classes_id)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>

<div class="info">

<ul>
<li>向t_student中加入数据</li>
</ul>
</div>

<blockquote>
<p>insert into t_student(student_id, student_name, sex, birthday, email, classes_id) values(1001, ‘zhangsan’, ‘m’, ‘1988-01-01’, ‘<a href="mailto:&#113;&#113;&#113;&#x40;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;">&#113;&#113;&#113;&#x40;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;</a>‘, 10)</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t_student(student_id, student_name, sex, birthday, email, classes_id) values(1001, &#x27;zhangsan&#x27;, &#x27;m&#x27;, &#x27;1988-01-01&#x27;, &#x27;qqq@163.com&#x27;, 10);</span><br><span class="line">ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`baishu_demo`.`t_student`, CONSTRAINT `fk_classes_id` FOREIGN KEY (`classes_id`) REFERENCES `t_classes` (`classes_id`))</span><br><span class="line"></span><br><span class="line">出现错误，因为在班级表中不存在班级编号为10班级，外键约束起到了作用</span><br><span class="line">存在外键的表就是子表，参照的表就是父表，所以存在一个父子关系，也就是主从关系，主表就是班级表，从表就是学生表 </span><br></pre></td></tr></table></figure>

<p>当classes_id设置为null，成功</p>
<blockquote>
<p>insert into t_student(student_id, student_name, sex, birthday, email, classes_id) values(1001, ‘zhangsan’, ‘m’, ‘1988-01-01’, ‘<a href="mailto:&#113;&#x71;&#113;&#64;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#109;">&#113;&#x71;&#113;&#64;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#109;</a>‘, null);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t_student(student_id, student_name, sex, birthday, email, classes_id) values(1001, &#x27;zhangsan&#x27;, &#x27;m&#x27;, &#x27;1988-01-01&#x27;, &#x27;qqq@163.com&#x27;, null);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<div class="danger">
以上成功的插入了学生信息，当时classes_id没有值，这样会影响参照完整性，所以我们建议将外键字段设置为非空
</div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_student;</span><br><span class="line">create table t_student(</span><br><span class="line">	student_id  	int(10),</span><br><span class="line">	student_name 	varchar(20),</span><br><span class="line">	sex		char(2),</span><br><span class="line">	birthday	date,</span><br><span class="line">	email		varchar(30),</span><br><span class="line">	classes_id	int (3) not null,</span><br><span class="line">	constraint  student_id_pk primary key(student_id),</span><br><span class="line">	constraint	fk_classes_id foreign key(classes_id) references t_classes(classes_id)	     </span><br><span class="line">)</span><br><span class="line">insert into t_student(student_id, student_name, sex, birthday, email, classes_id) values(1001, &#x27;zhangsan&#x27;, &#x27;m&#x27;, &#x27;1988-01-01&#x27;, &#x27;qqq@163.com&#x27;, null);</span><br></pre></td></tr></table></figure>
<p>再次插入班级编号为null的数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t_student(student_id, student_name, sex, birthday, email, classes_id) values(1001, &#x27;zhangsan&#x27;, &#x27;m&#x27;, &#x27;1988-01-01&#x27;, &#x27;qqq@163.com&#x27;, null);</span><br><span class="line">ERROR 1048 (23000): Column &#x27;classes_id&#x27; cannot be null</span><br></pre></td></tr></table></figure>

<div class="info">
添加数据到班级表，添加数据到学生表，删除班级数据，将会出现如下错误：
</div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t_classes (classes_id,classes_name) values (10,&#x27;366&#x27;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_student(</span><br><span class="line">    -&gt; student_id, student_name, sex, birthday, email, classes_id</span><br><span class="line">    -&gt; ) values (</span><br><span class="line">    -&gt; 1001, &#x27;zhangsan&#x27;, &#x27;m&#x27;, &#x27;1988-01-01&#x27;, &#x27;qqq@163.com&#x27;, 10</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update t_classes set  classes_id = 20 where classes_name = &#x27;366&#x27;;</span><br><span class="line">ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`baishu_demo`.`t_student`, CONSTRAINT `fk_classes_id` FOREIGN KEY (`classes_id`) REFERENCES `t_classes` (`classes_id`))</span><br></pre></td></tr></table></figure>
<div class="danger">
因为子表（t_student）存在一个外键classes_id，它参照了父表（t_classes）中的主键，所以先删除子表中的引用记录，再修改父表中的数据。
</div>

<blockquote>
<p>delete from t_classes where classes_id = 10;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; delete from t_classes where classes_id = 10;</span><br><span class="line">ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`baishu_demo`.`t_student`, CONSTRAINT `fk_classes_id` FOREIGN KEY (`classes_id`) REFERENCES `t_classes` (`classes_id`))</span><br><span class="line">因为子表（t_student）存在一个外键classes_id，它参照了父表（t_classes）中的主键，所以先删除父表，那么将会影响子表的参照完整性，所以正确的做法是，先删除子表中的数据，再删除父表中的数据，采用drop table也不行，必须先drop子表，再drop父表</span><br><span class="line">我们也可以采取以下章节的措施 级联删除。</span><br></pre></td></tr></table></figure>

<h6 id="级联更新与级联删除"><a href="#级联更新与级联删除" class="headerlink" title="级联更新与级联删除"></a><font color="#f2711c">级联更新与级联删除</font></h6><div class="info">
on update cascade;
</div>
<div class="danger">
mysql对有些约束的修改比较麻烦，所以我们可以先删除，再添加
我们只修改了父表中的数据，子表中的数据也会跟着变动。
</div>

<blockquote>
<p>alter table t_student drop foreign key fk_classes_id;</p>
</blockquote>
<blockquote>
<p>alter table t_student add constraint fk_classes_id_1 foreign key(classes_id) references t_classes(classes_id)  on update cascade;</p>
</blockquote>
<blockquote>
<p>update t_classes set classes_id = 20 where classes_name = ‘366’;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter table t_student drop foreign key fk_classes_id;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; alter table t_student add constraint fk_classes_id_1 foreign key(classes_id) references t_classes(classes_id)  on update cascade;</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; update t_classes set classes_id = 20 where classes_name = &#x27;366&#x27;;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_classes;</span><br><span class="line">+------------+--------------+</span><br><span class="line">| classes_id | classes_name |</span><br><span class="line">+------------+--------------+</span><br><span class="line">|         20 | 366          |</span><br><span class="line">+------------+--------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_student;</span><br><span class="line">+------------+--------------+------+------------+-------------+------------+</span><br><span class="line">| student_id | student_name | sex  | birthday   | email       | classes_id |</span><br><span class="line">+------------+--------------+------+------------+-------------+------------+</span><br><span class="line">|       1001 | zhangsan     | m    | 1988-01-01 | qqq@163.com |         20 |</span><br><span class="line">+------------+--------------+------+------------+-------------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; desc t_student;</span><br><span class="line">+--------------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field        | Type        | Null | Key | Default | Extra |</span><br><span class="line">+--------------+-------------+------+-----+---------+-------+</span><br><span class="line">| student_id   | int(10)     | NO   | PRI | NULL    |       |</span><br><span class="line">| student_name | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">| sex          | char(2)     | YES  |     | NULL    |       |</span><br><span class="line">| birthday     | date        | YES  |     | NULL    |       |</span><br><span class="line">| email        | varchar(30) | YES  |     | NULL    |       |</span><br><span class="line">| classes_id   | int(3)      | NO   | MUL | NULL    |       |</span><br><span class="line">+--------------+-------------+------+-----+---------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<div class="info">
on delete cascade;
</div>
<div class="danger">
mysql对有些约束的修改时不支持的，所以我们可以先删除，再添加
</div>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table t_student drop foreign key fk_classes_id;</span><br><span class="line"></span><br><span class="line">alter table t_student add constraint fk_classes_id_1 foreign key(classes_id) references t_classes(classes_id) on delete cascade;</span><br><span class="line"></span><br><span class="line">delete from t_classes where classes_id = 20;</span><br></pre></td></tr></table></figure>

<h5 id="t-student和t-classes完整示例"><a href="#t-student和t-classes完整示例" class="headerlink" title="t_student和t_classes完整示例"></a><font color="#f2711c">t_student和t_classes完整示例</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table if exists t_classes;</span><br><span class="line">create table t_classes(</span><br><span class="line">	classes_id	int (3),</span><br><span class="line">	classes_name	varchar(30)	not null,</span><br><span class="line">	constraint	pk_classes_id	primary key(classes_id) </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">drop table if exists t_student;</span><br><span class="line">create table t_student(</span><br><span class="line">	student_id	int(10),</span><br><span class="line">	student_name 	varchar(50) not null,</span><br><span class="line">	sex		char(2) not null,</span><br><span class="line">	birthday	date not null,</span><br><span class="line">	email		varchar(30) unique,</span><br><span class="line">	classes_id	int (3) not null,</span><br><span class="line">	constraint	pk_student_id	primary key(student_id),</span><br><span class="line">	constraint	fk_classes_id	foreign key(classes_id) references t_classes(classes_id) </span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a><font color="#f2711c">存储引擎</font></h4><h5 id="完整的建表语句"><a href="#完整的建表语句" class="headerlink" title="完整的建表语句"></a><font color="#f2711c">完整的建表语句</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t_x` (</span><br><span class="line">`id` int(11) DEFAULT NULL</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<div class="danger">

<blockquote>
<p>注意：在MySQL当中，凡是标识符使用飘号括起来的。最好别用，不通用。<br>建表的时候可以指定存储引擎，也可以指定字符集。<br>mysql默认使用的存储引擎是InnoDB方式。默认采用的字符集是UTF-8。</p>
</blockquote>
</div>

<h5 id="什么是存储引擎呢？"><a href="#什么是存储引擎呢？" class="headerlink" title="什么是存储引擎呢？"></a><font color="#f2711c">什么是存储引擎呢？</font></h5><p>存储引擎这个名字只有在mysql中存在。(Oracle中有对应的机制，但不叫做存储引擎。Oracle中没有特殊的名字，就是”表的存储方式”)<br>mysql支持很多存储引擎，每个存储引擎都对应了一种不同的存储方式。<br>每一个存储引擎都有自己的优缺点，需要在合适的时机选择合适的存储引擎。</p>
<h5 id="查看当前mysql支持的存储引擎？"><a href="#查看当前mysql支持的存储引擎？" class="headerlink" title="查看当前mysql支持的存储引擎？"></a><font color="#f2711c">查看当前mysql支持的存储引擎？</font></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ysql&gt; show engines \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">      Engine: InnoDB</span><br><span class="line">     Support: DEFAULT</span><br><span class="line">     Comment: Supports transactions, row-level locking, and foreign keys</span><br><span class="line">Transactions: YES</span><br><span class="line">          XA: YES</span><br><span class="line">  Savepoints: YES</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">      Engine: MRG_MYISAM</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Collection of identical MyISAM tables</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">      Engine: MEMORY</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Hash based, stored in memory, useful for temporary tables</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 4. row ***************************</span><br><span class="line">      Engine: BLACKHOLE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: /dev/null storage engine (anything you write to it disappears)</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 5. row ***************************</span><br><span class="line">      Engine: MyISAM</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: MyISAM storage engine</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 6. row ***************************</span><br><span class="line">      Engine: CSV</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: CSV storage engine</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 7. row ***************************</span><br><span class="line">      Engine: ARCHIVE</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Archive storage engine</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 8. row ***************************</span><br><span class="line">      Engine: PERFORMANCE_SCHEMA</span><br><span class="line">     Support: YES</span><br><span class="line">     Comment: Performance Schema</span><br><span class="line">Transactions: NO</span><br><span class="line">          XA: NO</span><br><span class="line">  Savepoints: NO</span><br><span class="line">*************************** 9. row ***************************</span><br><span class="line">      Engine: FEDERATED</span><br><span class="line">     Support: NO</span><br><span class="line">     Comment: Federated MySQL storage engine</span><br><span class="line">Transactions: NULL</span><br><span class="line">          XA: NULL</span><br><span class="line">  Savepoints: NULL</span><br><span class="line">9 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h5 id="常见的存储引擎？"><a href="#常见的存储引擎？" class="headerlink" title="常见的存储引擎？"></a><font color="#f2711c">常见的存储引擎？</font></h5><p>  Engine: MyISAM<br>  Support: YES<br>  Comment: MyISAM storage engine<br>    Transactions: NO<br>  XA: NO<br>  Savepoints: NO</p>
<p>  MyISAM这种存储引擎不支持事务。<br>  MyISAM是mysql最常用的存储引擎，但是这种存储引擎不是默认的。<br>  MyISAM采用三个文件组织一个表：<br>  xxx.frm(存储格式的文件)<br>    xxx.MYD(存储表中数据的文件)<br>    xxx.MYI(存储表中索引的文件)<br>      优点：可被压缩，节省存储空间。并且可以转换为只读表，提高检索效率。<br>      缺点:不支持事务。</p>
<hr>
<p>  Engine: InnoDB<br>  Support: DEFAULT<br>  Comment: Supports transactions, row-level locking, and foreign keys<br>    Transactions: YES<br>  XA: YES<br>  Savepoints: YES</p>
<p>  优点：支持事务、行级锁、外键等。这种存储引擎数据的安全得到保障。</p>
<p>  表的结构存储在xxx.frm文件中<br>  数据存储在tablespace这样的表空间中(逻辑概念)，无法被压缩，无法转换成只读。<br>  这种InnoDB存储引擎在MySQL数据库崩溃之后提供自动恢复机制。<br>  InoDB支持级联删除和级联更新。</p>
<hr>
<p>  Engine: MEMORY<br>  Support: YES<br>  Comment: Hash based, stored in memory, useful for temporary tables<br>    Transactions: NO<br>  XA: NO<br>  Savepoints: NO</p>
<p>  缺点：不支持事务。数据容易丢失。因为所有数据和索引都是存储在内存当中的。<br>  优点：查询速度最快。<br>  以前叫做HEPA引擎。</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a><font color="#f2711c">事务</font></h4><h5 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a><font color="#f2711c">什么是事务？</font></h5><p>一个事务是一个完整的业务逻辑单元，不可再分。</p>
<ul>
<li>比如：银行账户，从A账户向B账户转账10000元，需要执行两条update语句。<blockquote>
<p>update t_act set balance = balance - 10000 where actno = ‘act-001’;<br>update t_act set balance = balance + 10000 where actno = ‘act-002’;</p>
</blockquote>
</li>
</ul>
<p>以上两条DML语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败。<br>想要保证以上的两条DML语句同时成功或者同时失败，那么就要使用数据库的”事务机制”。</p>
<h5 id="和事务相关的语句只有：DML语句。-insert-delete-update"><a href="#和事务相关的语句只有：DML语句。-insert-delete-update" class="headerlink" title="和事务相关的语句只有：DML语句。(insert delete update)"></a><font color="#f2711c">和事务相关的语句只有：DML语句。(insert delete update)</font></h5><div class="danger">为什么？</div>
因为他们这三个语句都是和数据库表当中的"数据"相关的。
事务的存在是为了保证数据的完整性，安全性。

<h5 id="假设所有的业务都能使用1条DML语句搞定，还需要事务机制吗？"><a href="#假设所有的业务都能使用1条DML语句搞定，还需要事务机制吗？" class="headerlink" title="假设所有的业务都能使用1条DML语句搞定，还需要事务机制吗？"></a><font color="#f2711c">假设所有的业务都能使用1条DML语句搞定，还需要事务机制吗？</font></h5><p>不需要事务机制。<br>但实际情况不是这样的，通常一个”事儿(事务【业务】)”需要多条DML语句共同联合完成。</p>
<h5 id="事务的特性？"><a href="#事务的特性？" class="headerlink" title="事务的特性？"></a><font color="#f2711c">事务的特性？</font></h5><p>事务包括四大特性：ACID<br>A:原子性：事务是最小的工作单元，不可再分。<br>B:一致性：事务必须保证多条DML语句同时成功或者同时失败。<br>C:隔离性：事务A与事务B之间具有隔离。<br>D:持久性：持久性说的是最终数据必须持久化到硬盘中，事务才算成功结束。</p>
<h5 id="关于事务之间的隔离性？"><a href="#关于事务之间的隔离性？" class="headerlink" title="关于事务之间的隔离性？"></a><font color="#f2711c">关于事务之间的隔离性？</font></h5><p>事务隔离性存在隔离级别，理论上隔离级别包括4个：</p>
<ul>
<li>第一级别：读未提交(read uncommitted)<br>对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。<br>读未提交存在脏读(Dirty Read) 现象：表示读到了脏数据。</li>
<li>第二级别：读已提交(read committed)<br>对方事务提交之后的数据我方可以读取到。<br>读已提交存在的问题是：不可重复读。</li>
<li>第三级别：可重复读(repeatable read)<br>这种隔离级别解决了：不可重复读问题。<br>这种隔离级别存在的问题是：读取到的数据是幻象。</li>
<li>第四级别：序列化读/串行化读<br>解决了所有问题。<br>效率低，需要事务排队。</li>
</ul>
<h5 id="演示事务"><a href="#演示事务" class="headerlink" title="演示事务"></a><font color="#f2711c">演示事务</font></h5><ul>
<li><p>mysql事务默认情况下是自动提交的。<br>(什么是自动提交？只要执行任意一条DML语句则提交一次。)怎么关闭默认提交？start transaction;</p>
</li>
<li><p>建表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table t_user(</span><br><span class="line">    -&gt; id int primary key auto_increment,</span><br><span class="line">    -&gt; username varchar(255)</span><br><span class="line">    -&gt; );</span><br></pre></td></tr></table></figure></li>
<li><p>演示：mysql中的事务是支持自动提交的，只要执行一条DML语句，则提交一次。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; insert into t_user(username) values(&#x27;zs&#x27;);</span><br><span class="line">	   Querk OK, 1 row affected (0.03 sec)</span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">		+----+----------+</span><br><span class="line">		| id | username |</span><br><span class="line">		+----+----------+</span><br><span class="line">		|  1 | zs       |</span><br><span class="line">		+----+----------+</span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">	   Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">		 +----+----------+</span><br><span class="line">		 | id | username |</span><br><span class="line">		 +----+----------+</span><br><span class="line">		 |  1 | zs       |</span><br><span class="line">		 +----+----------+</span><br></pre></td></tr></table></figure></li>
<li><p>使用start transaction; 关闭自动提交机制。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start transaction;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_user(username) values(&quot;lisi&quot;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">|  2 | lisi     |</span><br><span class="line">+----+----------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_user(username) values(&quot;wangwu&quot;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">|  2 | lisi     |</span><br><span class="line">|  3 | wangwu   |</span><br><span class="line">+----+----------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback;    //回滚</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+----------+</span><br><span class="line">| id | username |</span><br><span class="line">+----+----------+</span><br><span class="line">|  1 | zs       |</span><br><span class="line">+----+----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start transaction;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_user(username) values(&quot;wangwu&quot;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_user(username) values(&quot;object&quot;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_user(username) values(&quot;joke&quot;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t_user(username) values(&quot;xiaozhaozhao&quot;);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+--------------+</span><br><span class="line">| id | username     |</span><br><span class="line">+----+--------------+</span><br><span class="line">|  1 | zs           |</span><br><span class="line">|  4 | wangwu       |</span><br><span class="line">|  5 | object       |</span><br><span class="line">|  6 | joke         |</span><br><span class="line">|  7 | xiaozhaozhao |</span><br><span class="line">+----+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; commit;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+--------------+</span><br><span class="line">| id | username     |</span><br><span class="line">+----+--------------+</span><br><span class="line">|  1 | zs           |</span><br><span class="line">|  4 | wangwu       |</span><br><span class="line">|  5 | object       |</span><br><span class="line">|  6 | joke         |</span><br><span class="line">|  7 | xiaozhaozhao |</span><br><span class="line">+----+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t_user;</span><br><span class="line">+----+--------------+</span><br><span class="line">| id | username     |</span><br><span class="line">+----+--------------+</span><br><span class="line">|  1 | zs           |</span><br><span class="line">|  4 | wangwu       |</span><br><span class="line">|  5 | object       |</span><br><span class="line">|  6 | joke         |</span><br><span class="line">|  7 | xiaozhaozhao |</span><br><span class="line">+----+--------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>  rollback : 回滚。<br>  commit ： 提交。<br>  start transaction : 关闭自动提交机制。</p>
</li>
<li><p>演示两个事务，假如隔离级别：</p>
<pre><code> 演示第1级别：读未提交
     set global transaction isolation level read uncommitted;
 演示第二级别；读已提交
     set global transaction isolation level read committed;
 演示第三级别:可重复读
     set global transaction isolation level repeatable read;
</code></pre>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a><font color="#f2711c">索引</font></h4><h5 id="什么是索引？有什么用？"><a href="#什么是索引？有什么用？" class="headerlink" title="什么是索引？有什么用？"></a><font color="#f2711c">什么是索引？有什么用？</font></h5><p>索引就相当于一本书的目录，通过目录可以快速的找到对应的资源。<br>在数据库方面，查询一张表的时候又两种检索方式：<br>（1）全表扫描<br>（2）根据索引检索（效率很高）<br>索引为什么可以提高检索效率呢？<br>  其实最根本的原理是缩小了扫描的范围。</p>
</li>
</ul>
<p>索引虽然可以提高检索效率，但是不能随意的添加索引，因为索引也是数据库中的对象，也需要数据库不断的维护。是有维护成本的。<br>比如：表中的数据经常被修改，这样就不适合添加索引，因为数据一旦修改，索引需要重新排序，进行维护。</p>
<p>添加索引是指给某一个字段，或者说某些字段添加索引。</p>
<p>select ename,sal from EMP where ename = ‘SMITH’;<br>当ename字段没有添加索引的时候，以上sql语句会进行全表扫描，扫描ename字段中所有的值。<br>当ename字段添加索引的时候，以上sql语句会根据索引扫描，快速定位。</p>
<h5 id="怎么创建索引对象？怎么删除索引对象？"><a href="#怎么创建索引对象？怎么删除索引对象？" class="headerlink" title="怎么创建索引对象？怎么删除索引对象？"></a><font color="#f2711c">怎么创建索引对象？怎么删除索引对象？</font></h5><p>创建索引对象：<br>  create index 索引名称 on 表名(字段名);<br>删除索引对象：<br>  drop index 索引名称 on 表名;</p>
<h5 id="什么时候考虑给字段添加索引？-满足什么条件"><a href="#什么时候考虑给字段添加索引？-满足什么条件" class="headerlink" title="什么时候考虑给字段添加索引？(满足什么条件)"></a><font color="#f2711c">什么时候考虑给字段添加索引？(满足什么条件)</font></h5><ul>
<li>数据量庞大。(根据客户的需求，根据线上的环境)</li>
<li>该字段很少的DML操作。(因为字段进行修改操作，索引也需要维护)</li>
<li>该字段经常出现在where子句中。(经常根据哪个字段维护)</li>
</ul>
<h5 id="注意：主键具有unique约束的字段会自动添加索引"><a href="#注意：主键具有unique约束的字段会自动添加索引" class="headerlink" title="注意：主键具有unique约束的字段会自动添加索引"></a><font color="#f2711c">注意：主键具有unique约束的字段会自动添加索引</font></h5><p>根据主键查询效率较高，尽量根据主键检索。</p>
<h5 id="查看sql语句的执行计划"><a href="#查看sql语句的执行计划" class="headerlink" title="查看sql语句的执行计划"></a><font color="#f2711c">查看sql语句的执行计划</font></h5><blockquote>
<p>create index emp_sal_index on EMP(sal);</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select ename,sal from EMP where sal = 5000;</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | EMP   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |</span><br><span class="line">+----+-------------+-------+------+---------------+------+---------+------+------+-------------+</span><br><span class="line"></span><br><span class="line">给薪资sal字段添加索引：</span><br><span class="line">create index emp_sal_index on EMP(sal);</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select ename,sal from EMP where sal = 5000;</span><br><span class="line">+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | EMP   | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 | Using where |</span><br><span class="line">+----+-------------+-------+------+---------------+---------------+---------+-------+------+-------------+</span><br><span class="line">rows检索次数减少了</span><br></pre></td></tr></table></figure>
<h5 id="索引底层采用的数据结构"><a href="#索引底层采用的数据结构" class="headerlink" title="索引底层采用的数据结构"></a><font color="#f2711c">索引底层采用的数据结构</font></h5><p>B + Tree</p>
<h5 id="索引的实现原理"><a href="#索引的实现原理" class="headerlink" title="索引的实现原理"></a><font color="#f2711c">索引的实现原理</font></h5><p>通过B Tree缩小扫描范围，底层索引进行了排序，分区，索引会携带数据在表中的”物理地址”，最终通过索引检索到数据之后，获取到关联的物理地址，<br>通过物理索引检索到数据之后，获取到关联的物理地址，通过物理地址定位表中的数据，效率是最高的。<br>select ename from EMP where ename = ‘SMITH’;<br>通过索引转换为：<br>select ename from EMP where  物理地址 = 0x123;</p>
<h5 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a><font color="#f2711c">索引的分类</font></h5><p>单一索引：给单个字段添加索引<br>复合索引：给多个字段联合起来添加一个索引<br>主键索引：主键上会自动添加索引<br>唯一索引：有unique约束的字段会自动添加索引<br>……</p>
<h5 id="索引什么时候失效？"><a href="#索引什么时候失效？" class="headerlink" title="索引什么时候失效？"></a><font color="#f2711c">索引什么时候失效？</font></h5><p>select ename from EMP where ename like ‘ %A% ‘;<br>模糊查询的时候，第一个通配符使用的是%，这个时候索引是是失效的。</p>
<h5 id="试图-View"><a href="#试图-View" class="headerlink" title="试图(View)"></a><font color="#f2711c">试图(View)</font></h5><h6 id="什么是视图？"><a href="#什么是视图？" class="headerlink" title="什么是视图？"></a><font color="#f2711c">什么是视图？</font></h6><p>站在不同的角度去看到数据。(同一张表的数据，通过不同的角度去看待)</p>
<h6 id="怎么创建视图？怎么删除视图？"><a href="#怎么创建视图？怎么删除视图？" class="headerlink" title="怎么创建视图？怎么删除视图？"></a><font color="#f2711c">怎么创建视图？怎么删除视图？</font></h6><p>create view myview as select empno,ename from EMP;<br>drop view myview;<br>注意：只有DQL语句才能以试图对象的方式创建出来。</p>
<h6 id="对试图进行增删改查，会影响到原表数据。-通过视图影响原表数据，不是直接操作的原表"><a href="#对试图进行增删改查，会影响到原表数据。-通过视图影响原表数据，不是直接操作的原表" class="headerlink" title="对试图进行增删改查，会影响到原表数据。(通过视图影响原表数据，不是直接操作的原表)"></a><font color="#f2711c">对试图进行增删改查，会影响到原表数据。(通过视图影响原表数据，不是直接操作的原表)</font></h6><p>可以对试图进行CRUD操作。</p>
<h6 id="面向视图操作？"><a href="#面向视图操作？" class="headerlink" title="面向视图操作？"></a><font color="#f2711c">面向视图操作？</font></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from myview;</span><br><span class="line">	+-------+--------+</span><br><span class="line">	| empno | ename  |</span><br><span class="line">	+-------+--------+</span><br><span class="line">	|  7369 | SMITH  |</span><br><span class="line">	|  7499 | ALLEN  |</span><br><span class="line">	|  7521 | WARD   |</span><br><span class="line">	|  7566 | JONES  |</span><br><span class="line">	|  7654 | MARTIN |</span><br><span class="line">	|  7698 | BLAKE  |</span><br><span class="line">	|  7782 | CLARK  |</span><br><span class="line">	|  7788 | SCOTT  |</span><br><span class="line">	|  7839 | KING   |</span><br><span class="line">	|  7844 | TURNER |</span><br><span class="line">	|  7876 | ADAMS  |</span><br><span class="line">	|  7900 | JAMES  |</span><br><span class="line">	|  7902 | FORD   |</span><br><span class="line">	|  7934 | MILLER |</span><br><span class="line">	+-------+--------+</span><br><span class="line"></span><br><span class="line">create table emp_bak as select * from EMP;</span><br><span class="line">create view myview1 as select empno,ename,sal from emp_bak;</span><br><span class="line">update myview1 set ename = &#x27;hehe&#x27;,sal = 1 where empno 7369;  //通过视图修改原表数据。</span><br><span class="line">delete from myview1 where empno = 7369;  //通过试图删除原表数据。</span><br></pre></td></tr></table></figure>
<h6 id="试图的作用？"><a href="#试图的作用？" class="headerlink" title="试图的作用？"></a><font color="#f2711c">试图的作用？</font></h6><p>试图可以隐藏表的实现细节。保密级别较高的系统，数据库只对外提供相关的视图，java程序员只对视图对象进行CRUD。</p>
<h5 id="DBA命令"><a href="#DBA命令" class="headerlink" title="DBA命令"></a><font color="#f2711c">DBA命令</font></h5><h6 id="在数据库当中的数据导出"><a href="#在数据库当中的数据导出" class="headerlink" title="在数据库当中的数据导出"></a><font color="#f2711c">在数据库当中的数据导出</font></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在windows的DOS命令窗口中执行： (导出整个库)</span><br><span class="line">    mysqldump bjpowernode&gt;D:\bjpowernode.sql -uroot -p999</span><br><span class="line">在windows的dos命令窗口中执行：(导出数据库中指定的表)</span><br><span class="line">    mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -uroot -p999</span><br></pre></td></tr></table></figure>
<h6 id="导入数据-1"><a href="#导入数据-1" class="headerlink" title="导入数据"></a><font color="#f2711c">导入数据</font></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database bjpowernode;</span><br><span class="line">use bjpowernode;</span><br><span class="line">source D:\bjpowernode.sql </span><br></pre></td></tr></table></figure>

<h5 id="数据库设计三范式-重点内容，面试经常会问"><a href="#数据库设计三范式-重点内容，面试经常会问" class="headerlink" title="数据库设计三范式(重点内容，面试经常会问)"></a><font color="#f2711c">数据库设计三范式(重点内容，面试经常会问)</font></h5><h6 id="什么是设计范式？"><a href="#什么是设计范式？" class="headerlink" title="什么是设计范式？"></a><font color="#f2711c">什么是设计范式？</font></h6><p>设计表的依据。按照这三个范式设计的表不会出现数据冗余。</p>
<h6 id="三范式都是哪些？"><a href="#三范式都是哪些？" class="headerlink" title="三范式都是哪些？"></a><font color="#f2711c">三范式都是哪些？</font></h6><ul>
<li>第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分。</li>
<li>第二范式：建立在第一范式的基础上，所有非主键字段完全依赖主键，不能产生部份依赖。<br>多对多？三张表，关系表两个外键。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t_student学生表</span><br><span class="line">sno(pk)        sname</span><br><span class="line">---------------------</span><br><span class="line">  1             张三</span><br><span class="line">  2             李四 </span><br><span class="line">  3             王五</span><br><span class="line"></span><br><span class="line">t_teacher 讲师表</span><br><span class="line">tno(pk)        tname</span><br><span class="line">----------------------</span><br><span class="line">  1						  王老师</span><br><span class="line">  2							张老师</span><br><span class="line">  3							李老师</span><br><span class="line"></span><br><span class="line">t_student_teacher_relation 学生讲师关系表</span><br><span class="line">id(pk)         sno(fk)          tno(fk)</span><br><span class="line">-------------------------------------------</span><br><span class="line">  1	             1                  3</span><br><span class="line">  2	             1	              	1</span><br><span class="line">  3	             2	              	2</span><br><span class="line">  4	             2                	3</span><br><span class="line">  5	             3	              	1</span><br><span class="line">  6	             3	              	3</span><br></pre></td></tr></table></figure></li>
<li>建立在第二范式的基础上，所有非主键字段直接依赖主键，不能产生传递依赖。<br>一对多？两张表，多的表加外键。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">班级t_class</span><br><span class="line">cno(pk)          cname</span><br><span class="line">--------------------------</span><br><span class="line">  1              班级1</span><br><span class="line">  2              班级2</span><br><span class="line"></span><br><span class="line">学生t_student</span><br><span class="line">sno(pk)         sname         classno(fk)</span><br><span class="line">--------------------------------------------</span><br><span class="line"> 101	     张1	            1</span><br><span class="line"> 102             张2	            2</span><br><span class="line"> 103	     张3	            2</span><br><span class="line"> 104	     张4	            1</span><br><span class="line"> 105	     张5	            2</span><br></pre></td></tr></table></figure>
提醒：在实际的开发中，以满足客户需求为主，有的时候会拿冗余换执行速度。</li>
</ul>
<h6 id="一对一怎么设计？"><a href="#一对一怎么设计？" class="headerlink" title="一对一怎么设计？"></a><font color="#f2711c">一对一怎么设计？</font></h6><p>一对一设计有两种方案：主键共享，外键唯一。</p>
<ul>
<li><p>主键共享</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t_user_login 用户登陆表</span><br><span class="line">id(pk)       username        password</span><br><span class="line">----------------------------------------</span><br><span class="line">  1             zs                123</span><br><span class="line">  2             ls                456</span><br><span class="line">   </span><br><span class="line">t_user_detail 用户详细信息表</span><br><span class="line">id(pk+fk)         realname          tel          ...</span><br><span class="line">----------------------------------------------------</span><br><span class="line">1                  张三            11111111112234</span><br><span class="line">2	                 李四            12112523432412</span><br></pre></td></tr></table></figure></li>
<li><p>外键唯一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t_user_login 用户登陆表</span><br><span class="line">id(pk)       username        password</span><br><span class="line">----------------------------------------</span><br><span class="line">  1             zs                123</span><br><span class="line">  2             ls                456</span><br><span class="line"></span><br><span class="line">t_user_detail 用户详细信息表</span><br><span class="line">id(pk)          realname            tel            userid(fk+unique)      </span><br><span class="line">----------------------------------------------------</span><br><span class="line">  1                张三            111111114          2</span><br><span class="line">  2	               李四            121432412          1</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>事件循环</title>
    <url>/2022/03/13/node/eventloop/</url>
    <content><![CDATA[<p>说到事件循环，经常会将浏览器和Node的事件循环进行对比，那么本文也会对这两个展开叙述。</p>
<h4 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h4><p>浏览器的事件循环大概可总结为以下几个阶段：<br><img src="/images/node/browser_eventloop.png" alt="browser_eventloop" loading="lazy"><br>一次循环过程：<br>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。<br><img src="/images/node/one_loop.png" alt="browser_loop" loading="lazy"><br>页面的时间循环系统：事件循环 + 消息队列：<br><img src="/images/node/browser_loop.png" alt="browser_loop" loading="lazy"></p>
<h4 id="node的-Event-Loop"><a href="#node的-Event-Loop" class="headerlink" title="node的 Event Loop"></a>node的 Event Loop</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制由libuv实现。<br>事件循环：libuv库提供两个最重要的东西是事件循环和线程池，两者共同构建了异步非阻塞I/O模型<br>事件驱动：事件驱动是在整个非阻塞I/O模型当中线程池通知事件循环它已经完成I/O操作的一种机制。</p>
<p>libuv的事件循环分为6个阶段，这6个阶段，按照顺序反复运行。每进一个阶段，从对应的回调队列中取出函数执行。<br><img src="/images/node/libuv.png" alt="libuv" loading="lazy"></p>
<h5 id="六个阶段"><a href="#六个阶段" class="headerlink" title="六个阶段"></a>六个阶段</h5><pre><code>外部输入数据--&gt;轮询阶段(poll)--&gt;检查阶段(check)--&gt;关闭事件回调阶段(close callback)--&gt;定时器检测阶段(timer)--&gt;I/O事件回调阶段(I/O callbacks)--&gt;闲置阶段(idle, prepare)--&gt;轮询阶段（按照该顺序反复运行）

timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调
I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调
idle, prepare 阶段：仅node内部使用
poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里
check 阶段：执行 setImmediate() 的回调
close callbacks 阶段：执行 socket 的 close 事件回调

每个阶段都有一个先入先出的（FIFO）的用于执行回调的队列，事件循环运行到每个阶段，都会从对应的回调队列中取出回调函数去执行，
直到队列当中的内容耗尽，或者执行的回调数量达到了最大。然后事件循环就会进入下一个阶段，然后又从下一个阶段对应的队列中取出回调函数执行，
这样反复直到事件循环的最后一个阶段。而事件循环也会一个一个按照循环执行，直到进程结束。

注意：上面六个阶段都不包括 process.nextTick()
</code></pre>
<p>接下去我们详细介绍timers、poll、check这3个阶段，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。</p>
<h6 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h6><pre><code>timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。
</code></pre>
<h6 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h6><pre><code>poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情
1.回到 timer 阶段执行回调
2.执行 I/O 回调
并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情

如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制
如果 poll 队列为空时，会有两件事发生

如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去

当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调
</code></pre>
<h6 id="check阶段"><a href="#check阶段" class="headerlink" title="check阶段"></a>check阶段</h6><pre><code>setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。 我们先来看个例子:

console.log(&#39;start&#39;)
setTimeout(() =&gt; &#123;
  console.log(&#39;timer1&#39;)
  Promise.resolve().then(function() &#123;
    console.log(&#39;promise1&#39;)
  &#125;)
&#125;, 0)
setTimeout(() =&gt; &#123;
  console.log(&#39;timer2&#39;)
  Promise.resolve().then(function() &#123;
    console.log(&#39;promise2&#39;)
  &#125;)
&#125;, 0)
Promise.resolve().then(function() &#123;
  console.log(&#39;promise3&#39;)
&#125;)
console.log(&#39;end&#39;)

start
end
promise3
timer1
promise1
timer2
promise2
</code></pre>
<h5 id="Micro-Task-与-Macro-Task"><a href="#Micro-Task-与-Macro-Task" class="headerlink" title="Micro-Task 与 Macro-Task"></a>Micro-Task 与 Macro-Task</h5><pre><code>Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。

常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。
常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。

混淆点:
1. 宏任务队列和微任务队列都只是概念，在node当中没有说哪个具体队列名字就叫做宏任务队列，
正确的认知应该是前面我们说的事件循环当中的6个阶段对应的6个基本的队列都属于宏队列
2. 比如timer阶段对应的是timer宏队列，I/O callback阶段对应的就是I/O callback宏队列,依次类推。
</code></pre>
<p>事件循环当中的6个宏队列和微队列的关系如下：</p>
<pre><code>微队列（microtask）在事件循环的各个阶段之间执行，或者说在事件循环的各个阶段对应的宏队列（macrotask）之间执行
</code></pre>
<p><img src="/images/node/mac_mic.png" alt="mac_mic" loading="lazy"></p>
<p>node10.X之前版本 与 node11.X之后版本区别：</p>
<pre><code>node10.X之前版本：宏队列当中的有几个宏任务，是要等到宏队列当中的所有宏任务全部执行完毕才会去执行微队列当中的微任务

node11.X之后版本：一旦执行一个阶段里对应宏队列当中的一个宏任务(setTimeout,setInterval和setImmediate三者其中之一，
不包括I/O)就立刻执行微任务队列，执行完微队列当中的所有微任务再回到刚才的宏队列执行下一个宏任务。跟浏览器端运行一致。
</code></pre>
<h5 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick"></a>process.nextTick</h5><p>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p>
<pre><code>执行机制：process.nextTick是用于在事件循环的下一次循环中调用回调函数的，将一个函数推迟到代码执行的下一个同步方法执行完毕，或异步事件回调函数开始执行时再执行

执行原理：Node每一次循环都是一个tick，每次tick，Chrome V8都会从时间队列当中取所有事件依次处理。遇到nextTick事件，将其加入事件队尾，等待下一次tick到来的时候执行

setTimeout(() =&gt; &#123;
  console.log(&#39;timer1&#39;)
  Promise.resolve().then(function() &#123;
    console.log(&#39;promise1&#39;)
  &#125;)
  &#125;, 0)
  process.nextTick(() =&gt; &#123;
  console.log(&#39;nextTick&#39;)
  process.nextTick(() =&gt; &#123;
    console.log(&#39;nextTick&#39;)
    process.nextTick(() =&gt; &#123;
      console.log(&#39;nextTick&#39;)
      process.nextTick(() =&gt; &#123;
        console.log(&#39;nextTick&#39;)
      &#125;)
    &#125;)
  &#125;)
&#125;)
// nextTick=&gt;nextTick=&gt;nextTick=&gt;nextTick=&gt;timer1=&gt;promise1
</code></pre>
<h4 id="Node与浏览器的-Event-Loop-差异"><a href="#Node与浏览器的-Event-Loop-差异" class="headerlink" title="Node与浏览器的 Event Loop 差异"></a>Node与浏览器的 Event Loop 差异</h4><p><img src="/images/node/compare_eventloop.png" alt="compare_eventloop" loading="lazy"></p>
<pre><code>浏览器和Node 环境下，microtask 任务队列的执行时机不同

Node端，microtask 在事件循环的各个阶段之间执行
浏览器端，microtask 在事件循环的 macrotask 执行完之后执行
</code></pre>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><pre><code>对于新版本node11及以后，在只执行浏览器和Node共有的宏任务的时候虽然过程不一样，但结果一样
</code></pre>
]]></content>
      <categories>
        <category>事件循环</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>浏览器</tag>
        <tag>事件循环</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Centos7 防火墙使用</title>
    <url>/2022/06/01/linux/firewall/</url>
    <content><![CDATA[<h4 id="什么是防火墙"><a href="#什么是防火墙" class="headerlink" title="什么是防火墙"></a>什么是防火墙</h4><p>防火墙（Firewall）技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。</p>
<h5 id="防火墙功能"><a href="#防火墙功能" class="headerlink" title="防火墙功能"></a>防火墙功能</h5><p>防火墙对流经它的网络通信进行扫描，这样能够过滤掉一些攻击，以免其在目标计算机上被执行。防火墙还可以关闭不使用的端口。而且它还能禁止特定端口的流出通信，封锁特洛伊木马。最后，它可以禁止来自特殊站点的访问，从而防止来自不明入侵者的所有通信。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol>
<li>记录计算机网络之中的数据信息</li>
<li>防止工作人员访问存在安全隐患的网站</li>
<li>控制不安全服务</li>
</ol>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>我们的计算机正因为防火墙而更加安全。<br>防火墙就好比是家里面的大门以及防盗窗，能够隔离以及防止绝大多数的恶意攻击和被非法入侵等，有了它的存在我们才能更加安全的使用计算机带来的便捷和服务。</p>
<h4 id="开启关闭防火墙"><a href="#开启关闭防火墙" class="headerlink" title="开启关闭防火墙"></a>开启关闭防火墙</h4><h5 id="启动防火墙"><a href="#启动防火墙" class="headerlink" title="启动防火墙"></a>启动防火墙</h5><pre><code>systemctl start firewalld
</code></pre>
<h5 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h5><pre><code>systemctl stop firewalld
</code></pre>
<h5 id="禁用防火墙"><a href="#禁用防火墙" class="headerlink" title="禁用防火墙"></a>禁用防火墙</h5><pre><code>systemctl disable firewalld
</code></pre>
<h5 id="重启防火墙"><a href="#重启防火墙" class="headerlink" title="重启防火墙"></a>重启防火墙</h5><pre><code>firewall-cmd --reload
</code></pre>
<p>firewall-cmd 是 firewalld的字符界面管理工具，firewalld是centos7的一大特性，最大的好处有两个：支持动态更新，不用重启服务；第二个就是加入了防火墙的“zone”概念。</p>
<h4 id="查看防火墙的状态"><a href="#查看防火墙的状态" class="headerlink" title="查看防火墙的状态"></a>查看防火墙的状态</h4><h5 id="当前版本"><a href="#当前版本" class="headerlink" title="当前版本"></a>当前版本</h5><pre><code>firewall-cmd --version
</code></pre>
<h5 id="查看帮助"><a href="#查看帮助" class="headerlink" title="查看帮助"></a>查看帮助</h5><pre><code>firewall-cmd --help
</code></pre>
<h5 id="当前状态"><a href="#当前状态" class="headerlink" title="当前状态"></a>当前状态</h5><pre><code>firewall-cmd --state 
</code></pre>
<h5 id="查看当前状态"><a href="#查看当前状态" class="headerlink" title="查看当前状态"></a>查看当前状态</h5><pre><code>systemctl status firewalld
</code></pre>
<h4 id="开放防火墙端口"><a href="#开放防火墙端口" class="headerlink" title="开放防火墙端口"></a>开放防火墙端口</h4><h5 id="端口开放情况"><a href="#端口开放情况" class="headerlink" title="端口开放情况"></a>端口开放情况</h5><pre><code>firewall-cmd --query-port=80/tcp
</code></pre>
<h5 id="查看开放的端口"><a href="#查看开放的端口" class="headerlink" title="查看开放的端口"></a>查看开放的端口</h5><pre><code>firewall-cmd --permanent --list-ports
</code></pre>
<p>–permanent：表示设置为持久</p>
<h5 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h5><pre><code>firewall-cmd --permanent --add-port=8080/tcp

firewall-cmd --permanent --add-port=8083-8085/tcp
</code></pre>
<h5 id="关闭端口"><a href="#关闭端口" class="headerlink" title="关闭端口"></a>关闭端口</h5><pre><code>firewall-cmd --permanent --remove-port=8083-8085/tcp
</code></pre>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>运维</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>常见Web图片对比：gif、jpg、png、webp</title>
    <url>/2020/03/07/html/imgcompare/</url>
    <content><![CDATA[<h4 id="图片格式分类"><a href="#图片格式分类" class="headerlink" title="图片格式分类"></a>图片格式分类</h4><p>无压缩： 无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片。BMP格式就是其中之一。</p>
<p>无损压缩：压缩算法对图片的所有的数据进行编码压缩，能在保证图片的质量的同时降低图片的尺寸。png是其中的代表。</p>
<p>有损压缩：压缩算法不会对图片所有的数据进行编码压缩，而是在压缩的时候，去除了人眼无法识别的图片细节。<br>因此有损压缩可以在同等图片质量的情况下大幅降低图片的尺寸。其中的代表是jpg。</p>
<h4 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h4><pre><code>采用LZW压缩算法进行编码，是一种无损的基于索引色的图片格式。由于采用了无损压缩，相比古老的bmp格式，尺寸较小，
缺点是由于gif只存储8位索引（也就是最多能表达2^8=256种颜色），色彩复杂、细节丰富的图片不适合保存为gif格式。
色彩简单的logo、icon、线框图适合采用gif格式。
</code></pre>
<h4 id="jpg"><a href="#jpg" class="headerlink" title="jpg"></a>jpg</h4><pre><code>jpg是一种有损的基于直接色的图片格式。由于采用直接色，jpg可使用的颜色有1600w之多（2^24），而人眼识别的颜色数量大约只有1w多种，
因此jpg非常适合色彩丰富图片、渐变色。jpg有损压缩移除肉眼无法识别的图片细节后，可以将图片的尺寸大幅度地减小。
但是jpg不适合icon、logo，因为相比gif/png-8，它在文件大小上丝毫没有优势。
</code></pre>
<h4 id="png-8"><a href="#png-8" class="headerlink" title="png-8"></a>png-8</h4><pre><code>png-8采用无损压缩，是基于8位索引色的位图格式。png-8相比gif对透明的支持更好，同等质量下，尺寸也更小。
非常适合作为gif的替代品。但png-8也一个明显的不足就是不支持动画。这也是png-8没办法完全替代gif的重要原因。
如果没有动画需求推荐使用png-8来替代gif。
</code></pre>
<h4 id="png-24"><a href="#png-24" class="headerlink" title="png-24"></a>png-24</h4><pre><code>png-24采用无损压缩，是基于直接色的位图格式。png-24的图片质量堪比bmp，但是却有bmp不具备的尺寸优势。
当然相比于jpg，gif，png-8，尺寸上还是要大。
正是因为其高品质，无损压缩，非常适合用于源文件或需要二次编辑的图片格式的保存。

png-24与jpg一样能表达丰富的图片细节，但并不能替代jpg。图片存储为png-24比存储为jpg，文件大小至少是jpg的5倍，
但在图片品质上的提升却微乎其微。所以除非对品质的要求极高，否则色彩丰富的网络图片还是推荐使用jpg。

png-24与png-8一样也支持透明
</code></pre>
<h4 id="webp"><a href="#webp" class="headerlink" title="webp"></a>webp</h4><pre><code>WebP图片是一种新的图像格式，由Google开发。与png、jpg相比，相同的视觉体验下，WebP图像的尺寸缩小了大约30％。
另外，WebP图像格式还支持有损压缩、无损压缩、透明和动画。理论上完全可以替代png、jpg、gif等图片格式，
当然目前webp的还没有得到全面的支持。
</code></pre>
<p>Google关于图片格式的选择指南</p>
<p><img src="/images/browser/google_guide.jpeg" alt="Google关于图片格式的选择指南" loading="lazy"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table>
<thead>
<tr>
<th>格式</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>gif</td>
<td>文件小，支持动画、透明，无兼容性问题</td>
<td>只支持256种颜色</td>
<td>色彩简单的logo、icon、动图</td>
</tr>
<tr>
<td>jpg</td>
<td>色彩丰富，文件小</td>
<td>有损压缩，反复保存图片质量下降明显</td>
<td>色彩丰富的图片/渐变图像</td>
</tr>
<tr>
<td>png</td>
<td>无损压缩，支持透明，简单图片尺寸小</td>
<td>不支持动画，色彩丰富的图片尺寸大</td>
<td>logo/icon/透明图</td>
</tr>
<tr>
<td>webp</td>
<td>文件小，支持有损和无损压缩，支持动画、透明</td>
<td>浏览器兼容性不好</td>
<td>支持webp格式的app和webview</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>图片</category>
      </categories>
      <tags>
        <tag>图片</tag>
      </tags>
  </entry>
</search>
