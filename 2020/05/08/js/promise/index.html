<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Baishu"><meta name="copyright" content="Baishu"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>手写Promise | Baishu的博客</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>function initScrollReveal() {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
}
document.addEventListener("DOMContentLoaded", initScrollReveal);
document.addEventListener("pjax:success", initScrollReveal);
</script><link rel="icon" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":"白舒小站","version":"1.10.2","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"搜索...","empty":"找不到您查询的内容: ${query}","hits":"找到 ${hits} 条结果","hits_time":"找到 ${hits} 条结果（用时 ${time} 毫秒）"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"local_search":{"path":"/search.xml"},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="promise可谓是面试必问题。一个事物的出现比定有其出现的道理，换句话说，是为了解决某个问题，而诞生的。那么我们就得聊一下，promise的出现究竟解决了什么问题 - 异步编码风格。 常见的Promise面试题1. Promise解决了什么问题 2. Promise的业界实现都有哪些 3. Promise常用的API有哪些 4. 能不能手写一个符合Promise&#x2F;A+规范的Promise? 5.">
<meta property="og:type" content="article">
<meta property="og:title" content="手写Promise">
<meta property="og:url" content="http://example.com/2020/05/08/js/promise/index.html">
<meta property="og:site_name" content="Baishu的博客">
<meta property="og:description" content="promise可谓是面试必问题。一个事物的出现比定有其出现的道理，换句话说，是为了解决某个问题，而诞生的。那么我们就得聊一下，promise的出现究竟解决了什么问题 - 异步编码风格。 常见的Promise面试题1. Promise解决了什么问题 2. Promise的业界实现都有哪些 3. Promise常用的API有哪些 4. 能不能手写一个符合Promise&#x2F;A+规范的Promise? 5.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/js/model.png">
<meta property="og:image" content="http://example.com/images/js/package.png">
<meta property="og:image" content="http://example.com/images/js/resolve.png">
<meta property="article:published_time" content="2020-05-08T04:41:29.000Z">
<meta property="article:modified_time" content="2020-05-08T14:12:31.000Z">
<meta property="article:author" content="Baishu">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/js/model.png"><script src="/js/ui/mode.js"></script></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Baishu"><img width="96" loading="lazy" src="/images/avatar.jpg" alt="Baishu"><span class="site-author-status" title="Looking for dawn.">⛽️</span></a><div class="site-author-name"><a href="/about/">Baishu</a></div><a class="site-name" href="/about/site.html">Baishu的博客</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">24</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">11</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">22</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/lsabella" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:baishu1024@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="我的小伙伴们" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-genderless-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84Promise%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">常见的Promise面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E4%B8%8D%E8%BF%9E%E7%BB%AD"><span class="toc-number">2.1.</span> <span class="toc-text">异步编程的问题：代码逻辑不连续</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E5%BC%82%E6%AD%A5%E4%BB%A3%E7%A0%81%EF%BC%8C%E8%AE%A9%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%8F%98%E5%BE%97%E7%BA%BF%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">封装异步代码，让处理流程变得线性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1"><span class="toc-number">2.3.</span> <span class="toc-text">新的问题：回调地狱</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise%EF%BC%9A%E6%B6%88%E7%81%AD%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8%E5%92%8C%E5%A4%9A%E6%AC%A1%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">Promise：消灭嵌套调用和多次错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-%E6%9D%A5%E9%87%8D%E6%9E%84-XFetch-%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">3.1.</span> <span class="toc-text">Promise 来重构 XFetch 的代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A9%E7%94%A8-XFetch-%E6%9D%A5%E6%9E%84%E9%80%A0%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">利用 XFetch 来构造请求流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-%E4%B8%A4%E6%AD%A5%E8%A7%A3%E5%86%B3%E5%B5%8C%E5%A5%97%E5%9B%9E%E8%B0%83%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.</span> <span class="toc-text">Promise 两步解决嵌套回调问题</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-%E6%98%AF%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">3.4.</span> <span class="toc-text">Promise 是怎么处理异常</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-%E4%B8%8E%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">Promise 与微任务</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E5%95%A5%E4%BD%BF%E7%94%A8setTimeout-%E5%AE%9E%E7%8E%B0-promise-%E5%BC%82%E6%AD%A5"><span class="toc-number">4.1.</span> <span class="toc-text">为啥使用setTimeout 实现 promise 异步</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E0-1%E6%89%8B%E5%86%99promise"><span class="toc-number">5.</span> <span class="toc-text">从0-1手写promise</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-A"><span class="toc-number">5.1.</span> <span class="toc-text">Promise&#x2F;A+</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%89%88-Promise"><span class="toc-number">5.2.</span> <span class="toc-text">基础版 Promise</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#then-%E7%9A%84%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8-amp-%E5%80%BC%E7%A9%BF%E9%80%8F%E7%89%B9%E6%80%A7"><span class="toc-number">5.3.</span> <span class="toc-text">then 的链式调用&amp;值穿透特性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-%E7%9A%84-API"><span class="toc-number">6.</span> <span class="toc-text">Promise 的 API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-resolve"><span class="toc-number">6.1.</span> <span class="toc-text">Promise.resolve</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-reject"><span class="toc-number">6.2.</span> <span class="toc-text">Promise.reject</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-catch"><span class="toc-number">6.3.</span> <span class="toc-text">Promise.prototype.catch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-prototype-finally"><span class="toc-number">6.4.</span> <span class="toc-text">Promise.prototype.finally</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-all"><span class="toc-number">6.5.</span> <span class="toc-text">Promise.all</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Promise-race"><span class="toc-number">6.6.</span> <span class="toc-text">Promise.race</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Promise"><span class="toc-number">7.</span> <span class="toc-text">1 - Promise</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2020/05/08/js/promise/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Baishu"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Baishu的博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">手写Promise</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2020-05-08 12:41:29" itemprop="dateCreated datePublished" datetime="2020-05-08T12:41:29+08:00">2020-05-08</time></div><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/javascript/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">javascript</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/javascript/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">javascript</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><p>promise可谓是面试必问题。一个事物的出现比定有其出现的道理，换句话说，是为了解决某个问题，而诞生的。那么我们就得聊一下，promise的出现究竟解决了什么问题 - 异步编码风格。</p>
<h4 id="常见的Promise面试题"><a href="#常见的Promise面试题" class="headerlink" title="常见的Promise面试题"></a>常见的Promise面试题</h4><pre><code>1. Promise解决了什么问题
2. Promise的业界实现都有哪些
3. Promise常用的API有哪些
4. 能不能手写一个符合Promise/A+规范的Promise?
5. Promise在事件循环中的执行过程是怎样的？
6. Promise有什么缺陷，可以如何解决 - Promise 没有中断方法
7. Promise 中为什么要引入微任务？
8. Promise 中是如何实现回调函数返回值穿透的？
9. Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获异常的函数？
</code></pre>
<h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h4><p> Web 页面的单线程架构模型，决定了编码形式 - 异步编程。基于异步编程模型的代码会打乱关键逻辑点，不符合人的线性思维方式，代码不易读。</p>
<h5 id="异步编程的问题：代码逻辑不连续"><a href="#异步编程的问题：代码逻辑不连续" class="headerlink" title="异步编程的问题：代码逻辑不连续"></a>异步编程的问题：代码逻辑不连续</h5><pre><code>JavaScript 的异步编程模型：
  页面中任务都是执行在主线程之上的，
  相对于页面来说，主线程就是它整个的世界，
  所以在执行一项耗时的任务时（比如下载网络文件任务、获取摄像头等设备信息任务），这些任务都会放到页面主线程之外的进程或者线程中去执行，
  这样就避免了耗时任务“霸占”页面主线程的情况。
</code></pre>
<p><img src="/images/js/model.png" alt="model" loading="lazy"><br>上图展示的是一个标准的异步编程模型，页面主线程发起了一个耗时的任务，并将任务交给另外一个进程去处理，这时页面主线程会继续执行消息队列中的任务。等该进程处理完这个任务后，会将该任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。排队结束之后，循环系统会取出消息队列中的任务进行处理，并触发相关的<code>回调</code>操作。</p>
<blockquote>
<p>页面编程特点：异步回调</p>
</blockquote>
<p>Web 页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式，到底是如何影响的呢？<br>假设有一个下载的需求，使用 XMLHttpRequest 来实现，具体的实现方式你可以参考下面这段代码：</p>
<pre><code>//执行状态
function onResolve(response)&#123;console.log(response) &#125;
function onReject(error)&#123;console.log(error) &#125;

let xhr = new XMLHttpRequest()
xhr.ontimeout = function(e) &#123; onReject(e)&#125;
xhr.onerror = function(e) &#123; onReject(e) &#125;
xhr.onreadystatechange = function () &#123; onResolve(xhr.response) &#125;

//设置请求类型，请求URL，是否同步信息
let URL = &#39;https://time.geekbang.com&#39;
xhr.open(&#39;Get&#39;, URL, true);

//设置参数
xhr.timeout = 3000 //设置xhr请求的超时时间
xhr.responseType = &quot;text&quot; //设置响应返回的数据格式
xhr.setRequestHeader(&quot;X_TEST&quot;,&quot;time.geekbang&quot;)

//发出请求
xhr.send();
</code></pre>
<p>我们执行上面这段代码，可以正常输出结果的。但是，这短短的一段代码里面竟然出现了五次回调，这么多的回调会导致代码的逻辑不连贯、不线性，非常不符合人的直觉，这就是异步回调影响到我们的编码方式。那有什么方法可以解决这个问题吗？当然有，我们可以封装这堆凌乱的代码，降低处理异步回调的次数。</p>
<h5 id="封装异步代码，让处理流程变得线性"><a href="#封装异步代码，让处理流程变得线性" class="headerlink" title="封装异步代码，让处理流程变得线性"></a>封装异步代码，让处理流程变得线性</h5><p>由于我们重点关注的是输入内容（请求信息）和输出内容（回复信息），至于中间的异步请求过程，我们不想在代码里面体现太多，因为这会干扰核心的代码逻辑。整体思路如下图所示：<br><img src="/images/js/package.png" alt="package" loading="lazy"><br>从图中你可以看到，我们将 XMLHttpRequest 请求过程的代码封装起来了，重点关注输入数据和输出结果。<br>那我们就按照这个思路来改造代码。首先，我们把输入的 HTTP 请求信息全部保存到一个 request 的结构中，包括请求地址、请求头、请求方式、引用地址、同步请求还是异步请求、安全设置等信息。request 结构如下所示：</p>
<pre><code>//makeRequest用来构造request对象
function makeRequest(request_url) &#123;
    let request = &#123;
        method: &#39;Get&#39;,
        url: request_url,
        headers: &#39;&#39;,
        body: &#39;&#39;,
        credentials: false,
        sync: true,
        responseType: &#39;text&#39;,
        referrer: &#39;&#39;
    &#125;
    return request
&#125;
</code></pre>
<p>然后就可以封装请求过程了，这里我们将所有的请求细节封装进 XFetch 函数，XFetch 代码如下所示：</p>
<pre><code>//[in] request，请求信息，请求头，延时值，返回类型等
//[out] resolve, 执行成功，回调该函数
//[out] reject  执行失败，回调该函数
function XFetch(request, resolve, reject) &#123;
    let xhr = new XMLHttpRequest()
    xhr.ontimeout = function (e) &#123; reject(e) &#125;
    xhr.onerror = function (e) &#123; reject(e) &#125;
    xhr.onreadystatechange = function () &#123;
        if (xhr.status = 200)
            resolve(xhr.response)
    &#125;
    xhr.open(request.method, URL, request.sync);
    xhr.timeout = request.timeout;
    xhr.responseType = request.responseType;
    //补充其他请求信息
    //...
    xhr.send();
&#125;
</code></pre>
<p>这个 XFetch 函数需要一个 request 作为输入，然后还需要两个回调函数 <code>resolve</code> 和 <code>reject</code>，当请求成功时回调 resolve 函数，当请求出现问题时回调 reject 函数。<br>具体的实现方式如下所示：</p>
<pre><code>XFetch(makeRequest(url1),
    function resolve(data) &#123;
        console.log(data)
    &#125;, function reject(e) &#123;
        console.log(e)
    &#125;)
</code></pre>
<h5 id="新的问题：回调地狱"><a href="#新的问题：回调地狱" class="headerlink" title="新的问题：回调地狱"></a>新的问题：回调地狱</h5><p>上面的示例代码已经比较符合人的线性思维了，在一些简单的场景下运行效果也是非常好的，不过一旦接触到稍微复杂点的项目时，你就会发现，如果嵌套了太多的回调函数就很容易使得自己陷入了回调地狱，不能自拔。你可以参考下面这段让人凌乱的代码：</p>
<pre><code>XFetch(makeRequest(url1),
      function resolve(response) &#123;
          console.log(response)
          XFetch(makeRequest(url2),
              function resolve(response) &#123;
                  console.log(response)
                  XFetch(makeRequest(url3)
                      function resolve(response) &#123;
                          console.log(response)
                      &#125;, function reject(e) &#123;
                          console.log(e)
                      &#125;)
              &#125;, function reject(e) &#123;
                  console.log(e)
              &#125;)
      &#125;, function reject(e) &#123;
          console.log(e)
      &#125;)
</code></pre>
<p>这段代码之所以看上去很乱，归结其原因有两点：</p>
<pre><code> 第一是嵌套调用，下面的任务依赖上个任务的请求结果，并在上个任务的回调函数内部执行新的业务逻辑，这样当嵌套层次多了之后，代码的可读性就变得非常差了。
 第二是任务的不确定性，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。
</code></pre>
<p>解决思路</p>
<pre><code>  第一是消灭嵌套调用；
  第二是合并多个任务的错误处理。
</code></pre>
<blockquote>
<p>Promise 已经帮助我们解决了这两个问题。那么接下来我们就来看看 Promise 是怎么消灭嵌套调用和合并多个任务的错误处理的。</p>
</blockquote>
<h4 id="Promise：消灭嵌套调用和多次错误处理"><a href="#Promise：消灭嵌套调用和多次错误处理" class="headerlink" title="Promise：消灭嵌套调用和多次错误处理"></a>Promise：消灭嵌套调用和多次错误处理</h4><h5 id="Promise-来重构-XFetch-的代码"><a href="#Promise-来重构-XFetch-的代码" class="headerlink" title="Promise 来重构 XFetch 的代码"></a>Promise 来重构 XFetch 的代码</h5><pre><code>function XFetch(request) &#123;
  function executor(resolve, reject) &#123;
      let xhr = new XMLHttpRequest()
      xhr.open(&#39;GET&#39;, request.url, true)
      xhr.ontimeout = function (e) &#123; reject(e) &#125;
      xhr.onerror = function (e) &#123; reject(e) &#125;
      xhr.onreadystatechange = function () &#123;
          if (this.readyState === 4) &#123;
              if (this.status === 200) &#123;
                  resolve(this.responseText, this)
              &#125; else &#123;
                  let error = &#123;
                      code: this.status,
                      response: this.response
                  &#125;
                  reject(error, this)
              &#125;
          &#125;
      &#125;
      xhr.send()
  &#125;
  return new Promise(executor)
&#125;
</code></pre>
<h5 id="利用-XFetch-来构造请求流程"><a href="#利用-XFetch-来构造请求流程" class="headerlink" title="利用 XFetch 来构造请求流程"></a>利用 XFetch 来构造请求流程</h5><pre><code>var x1 = XFetch(makeRequest(url1))
var x2 = x1.then(value =&gt; &#123;
    console.log(value)
    return XFetch(makeRequest(url2))
&#125;)
var x3 = x2.then(value =&gt; &#123;
    console.log(value)
    return XFetch(makeRequest(url3))
&#125;)
x3.catch(error =&gt; &#123;
    console.log(error)
&#125;)

  1.首先我们引入了 Promise，在调用 XFetch 时，会返回一个 Promise 对象。
  2.构建 Promise 对象时，需要传入一个 executor 函数，XFetch 的主要业务流程都在 executor 函数中执行。
  3.如果运行在 excutor 函数中的业务执行成功了，会调用 resolve 函数；如果执行失败了，则调用 reject 函数。
  4.在 excutor 函数中调用 resolve 函数时，会触发 promise.then 设置的回调函数；而调用 reject 函数时，会触发 promise.catch 设置的回调函数。
</code></pre>
<p>以上简单介绍了 Promise 一些主要的使用方法，通过引入 Promise，上面这段代码看起来就非常线性了，也非常符合人的直觉，是不是很酷？基于这段代码，我们就可以来分析 Promise 是如何消灭嵌套回调和合并多个错误处理了。</p>
<h5 id="Promise-两步解决嵌套回调问题"><a href="#Promise-两步解决嵌套回调问题" class="headerlink" title="Promise 两步解决嵌套回调问题"></a>Promise 两步解决嵌套回调问题</h5><blockquote>
<ol>
<li>Promise 实现了回调函数的延时绑定。</li>
</ol>
</blockquote>
<p>回调函数的延时绑定在代码上体现就是先创建 Promise 对象 x1，通过 Promise 的构造函数 executor 来执行业务逻辑；创建好 Promise 对象 x1 之后，再使用 x1.then 来设置回调函数。示范代码如下：</p>
<pre><code>//创建Promise对象x1，并在executor函数中执行业务逻辑
function executor(resolve, reject)&#123;
    resolve(100)
&#125;
let x1 = new Promise(executor)


//x1延迟绑定回调函数onResolve
function onResolve(value)&#123;
    console.log(value)
&#125;
x1.then(onResolve)
</code></pre>
<blockquote>
<ol start="2">
<li>需要将回调函数 onResolve 的返回值穿透到最外层。</li>
</ol>
</blockquote>
<p>因为我们会根据 onResolve 函数的传入值来决定创建什么类型的 Promise 任务，创建好的 Promise 对象需要返回到最外层，这样就可以摆脱嵌套循环了。你可以先看下面的代码：<br><img src="/images/js/resolve.png" alt="resolve" loading="lazy"></p>
<h5 id="Promise-是怎么处理异常"><a href="#Promise-是怎么处理异常" class="headerlink" title="Promise 是怎么处理异常"></a>Promise 是怎么处理异常</h5><pre><code>function executor(resolve, reject) &#123;
    let rand = Math.random();
    console.log(1)
    console.log(rand)
    if (rand &gt; 0.5)
        resolve()
    else
        reject()
&#125;
var p0 = new Promise(executor);

var p1 = p0.then((value) =&gt; &#123;
    console.log(&quot;succeed-1&quot;)
    return new Promise(executor)
&#125;)

var p3 = p1.then((value) =&gt; &#123;
    console.log(&quot;succeed-2&quot;)
    return new Promise(executor)
&#125;)

var p4 = p3.then((value) =&gt; &#123;
    console.log(&quot;succeed-3&quot;)
    return new Promise(executor)
&#125;)

p4.catch((error) =&gt; &#123;
    console.log(&quot;error&quot;)
&#125;)
console.log(2)
</code></pre>
<p>这段代码有四个 Promise 对象：p0～p4。无论哪个对象里面抛出异常，都可以通过最后一个对象 p4.catch 来捕获异常，通过这种方式可以将所有 Promise 对象的错误合并到一个函数来处理，这样就解决了每个任务都需要单独处理异常的问题。</p>
<p>之所以可以使用最后一个对象来捕获所有异常，是因为 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了。</p>
<pre><code>Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获

promise内部有resolved_和rejected_变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断rejected参数是否为函数，若是函数，错误时使用rejected处理错误；若不是，则错误时直接throw错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听unhandledrejection事件捕获未处理的promise错误
</code></pre>
<p>通过这种方式，我们就消灭了嵌套调用和频繁的错误处理，这样使得我们写出来的代码更加优雅，更加符合人的线性思维。</p>
<h4 id="Promise-与微任务"><a href="#Promise-与微任务" class="headerlink" title="Promise 与微任务"></a>Promise 与微任务</h4><p>讲了这么多，我们似乎还没有将微任务和 Promise 关联起来，那么 Promise 和微任务的关系到底体现哪里呢？我们可以结合下面这个简单的 Promise 代码来回答这个问题：</p>
<pre><code>function executor(resolve, reject) &#123;
    resolve(100)
&#125;
let demo = new Promise(executor)

function onResolve(value)&#123;
    console.log(value)
&#125;
demo.then(onResolve)
</code></pre>
<p>对于上面这段代码，我们需要重点关注下它的执行顺序。首先执行 new Promise 时，Promise 的构造函数会被执行，不过由于 Promise 是 V8 引擎提供的，所以暂时看不到 Promise 构造函数的细节。接下来，Promise 的构造函数会调用 Promise 的参数 executor 函数。然后在 executor 中执行了 resolve，resolve 函数也是在 V8 内部实现的，那么 resolve 函数到底做了什么呢？我们知道，执行 resolve 函数，会触发 demo.then 设置的回调函数 onResolve，所以可以推测，resolve 函数内部调用了通过 demo.then 设置的 onResolve 函数。不过这里需要注意一下，由于 Promise 采用了回调函数延迟绑定技术，所以在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行。这样按顺序陈述可能把你绕晕了，下面来模拟实现一个 Promise，我们会实现它的构造函数、resolve 方法以及 then 方法，以方便你能看清楚 Promise 的背后都发生了什么。这里我们就把这个对象称为 Bromise，下面就是 Bromise 的实现代码：</p>
<pre><code>function Bromise(executor) &#123;
    var onResolve_ = null
    var onReject_ = null
    //模拟实现resolve和then，暂不支持rejcet
    this.then = function (onResolve, onReject) &#123;
        onResolve_ = onResolve
    &#125;;
    function resolve(value) &#123;
          //setTimeout(()=&gt;&#123;
            onResolve_(value)
          // &#125;,0)
    &#125;
    executor(resolve, null);
&#125;
</code></pre>
<p>观察上面这段代码，我们实现了自己的构造函数、resolve、then 方法。接下来我们使用 Bromise 来实现我们的业务代码，实现后的代码如下所示：</p>
<pre><code>function executor(resolve, reject) &#123;
    resolve(100)
&#125;
//将Promise改成我们自己的Bromsie
let demo = new Bromise(executor)

function onResolve(value)&#123;
    console.log(value)
&#125;
demo.then(onResolve)
</code></pre>
<p>执行这段代码，我们发现执行出错，输出的内容是：</p>
<pre><code>Uncaught TypeError: onResolve_ is not a function
    at resolve (&lt;anonymous&gt;:10:13)
    at executor (&lt;anonymous&gt;:17:5)
    at new Bromise (&lt;anonymous&gt;:13:5)
    at &lt;anonymous&gt;:19:12
</code></pre>
<p>之所以出现这个错误，是由于 Bromise 的延迟绑定导致的，在调用到 onResolve_ 函数的时候，Bromise.then 还没有执行，所以执行上述代码的时候，当然会报“onResolve_ is not a function“的错误了。也正是因为此，我们要改造 Bromise 中的 resolve 方法，让 resolve 延迟调用 onResolve_。要让 resolve 中的 onResolve_ 函数延后执行，可以在 resolve 函数里面加上一个定时器，让其延时执行 onResolve_ 函数，你可以参考下面改造后的代码：</p>
<pre><code>function resolve(value) &#123;
          setTimeout(()=&gt;&#123;
              onResolve_(value)
            &#125;,0)
    &#125; 
</code></pre>
<p>上面采用了定时器来推迟 onResolve 的执行，不过使用定时器的效率并不是太高，好在我们有微任务，所以 Promise 又把这个定时器改造成了微任务了，这样既可以让 onResolve_ 延时被调用，又提升了代码的执行效率。这就是 Promise 中使用微任务的原由了。</p>
<h5 id="为啥使用setTimeout-实现-promise-异步"><a href="#为啥使用setTimeout-实现-promise-异步" class="headerlink" title="为啥使用setTimeout 实现 promise 异步"></a>为啥使用setTimeout 实现 promise 异步</h5><p>由于原生的 Promise 是V8引擎提供的微任务，我们无法还原V8引擎的实现，所以这里使用 setTimeout 模拟异步，所以原生的是微任务，这里是宏任务。</p>
<p>Promise A+ 规范3.1 中也提到了：<br>    Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.<br>    这可以通过“宏任务”机制（例如setTimeout或setImmediate）或“微任务”机制（例如MutatonObserver或）来实现process.nextTick。</p>
<blockquote>
<p>如果你想实现 promise 的微任务</p>
</blockquote>
<ul>
<li>可以 mutationObserver 替代 seiTimeout 来实现微任务。</li>
<li>queueMicrotask 实现微任务（queueMicrotask 兼容性不是很好，IE 下完全不支持。queueMicrotask 的 polyfill 是基于 promise 实现的，如果不支持 promise 会转成 setTimeout。）</li>
</ul>
<p>看了以上内容，让我们来回答下：</p>
<pre><code>1、Promise 中为什么要引入微任务？

由于promise采用.then延时绑定回调机制，而new Promise时又需要直接执行promise中的方法，即发生了先执行方法后添加回调的过程，此时需等待then方法绑定两个回调后才能继续执行方法回调，便可将回调添加到当前js调用栈中执行结束后的任务队列中，由于宏任务较多容易堵塞，则采用了微任务

2、Promise 中是如何实现回调函数返回值穿透的？
首先Promise的执行结果保存在promise的data变量中，然后是.then方法返回值为使用resolved或rejected回调方法新建的一个promise对象，即例如成功则返回new Promise（resolved），将前一个promise的data值赋给新建的promise

3、Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获
promise内部有resolved_和rejected_变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断rejected参数是否为函数，若是函数，错误时使用rejected处理错误；若不是，则错误时直接throw错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听unhandledrejection事件捕获未处理的promise错误
</code></pre>
<h4 id="从0-1手写promise"><a href="#从0-1手写promise" class="headerlink" title="从0-1手写promise"></a>从0-1手写promise</h4><h5 id="Promise-A"><a href="#Promise-A" class="headerlink" title="Promise/A+"></a>Promise/A+</h5><p>  手写一个 Promise，就要遵循<a target="_blank" rel="noopener" href="https://promisesaplus.com/">Promise/A+</a> 规范，业界所有 Promise 的类库都遵循这个规范。</p>
<h5 id="基础版-Promise"><a href="#基础版-Promise" class="headerlink" title="基础版 Promise"></a>基础版 Promise</h5><pre><code>const p1 = new Promise((resolve, reject) =&gt; &#123;
  console.log(&#39;create a promise&#39;);
  resolve(&#39;成功了&#39;);
&#125;)

console.log(&quot;after new promise&quot;);

const p2 = p1.then(data =&gt; &#123;
  console.log(data)
  throw new Error(&#39;失败了&#39;)
&#125;)

const p3 = p2.then(data =&gt; &#123;
  console.log(&#39;success&#39;, data)
&#125;, err =&gt; &#123;
  console.log(&#39;faild&#39;, err)
&#125;)

&quot;create a promise&quot;
&quot;after new promise&quot;
&quot;成功了&quot;
&quot;faild Error: 失败了&quot;
</code></pre>
<p>结合 Promise/A+ 规范，我们可以分析出 Promise 的基本特征：</p>
<pre><code>1.promise 有三个状态：pending，fulfilled，or rejected；「规范 Promise/A+ 2.1」
2.new promise时， 需要传递一个executor()执行器，执行器立即执行；
3.executor接受两个参数，分别是resolve和reject；
4.promise  的默认状态是 pending；
5.promise 有一个value保存成功状态的值，可以是undefined/thenable/promise；「规范 Promise/A+ 1.3」
6.promise 有一个reason保存失败状态的值；「规范 Promise/A+ 1.5」
7.promise 只能从pending到rejected, 或者从pending到fulfilled，状态一旦确认，就不会再改变；
8.promise 必须有一个then方法，then 接收两个参数，分别是 promise 成功的回调 onFulfilled, 和 promise 失败的回调 onRejected；「规范 Promise/A+ 2.2」
9.如果调用 then 时，promise 已经成功，则执行onFulfilled，参数是promise的value；
10.如果调用 then 时，promise 已经失败，那么执行onRejected, 参数是promise的reason；
11.如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调onRejected；
</code></pre>
<p>按照上面的特征，我们试着勾勒下 Promise 的形状：</p>
<pre><code>// 三个状态：PENDING、FULFILLED、REJECTED
const PENDING = &#39;PENDING&#39;;
const FULFILLED = &#39;FULFILLED&#39;;
const REJECTED = &#39;REJECTED&#39;;

class Promise &#123;
  constructor(executor) &#123;
    // 默认状态为 PENDING
    this.status = PENDING;
    // 存放成功状态的值，默认为 undefined
    this.value = undefined;
    // 存放失败状态的值，默认为 undefined
    this.reason = undefined;

    // 调用此方法就是成功
    let resolve = (value) =&gt; &#123;
      // 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法
      if(this.status ===  PENDING) &#123;
        this.status = FULFILLED;
        this.value = value;
      &#125;
    &#125; 

    // 调用此方法就是失败
    let reject = (reason) =&gt; &#123;
      // 状态为 PENDING 时才可以更新状态，防止 executor 中调用了两次 resovle/reject 方法
      if(this.status ===  PENDING) &#123;
        this.status = REJECTED;
        this.reason = reason;
      &#125;
    &#125;

    try &#123;
      // 立即执行，将 resolve 和 reject 函数传给使用者  
      executor(resolve,reject)
    &#125; catch (error) &#123;
      // 发生异常时执行失败逻辑
      reject(error)
    &#125;
  &#125;

  // 包含一个 then 方法，并接收两个参数 onFulfilled、onRejected
  then(onFulfilled, onRejected) &#123;
    if (this.status === FULFILLED) &#123;
      onFulfilled(this.value)
    &#125;

    if (this.status === REJECTED) &#123;
      onRejected(this.reason)
    &#125;
  &#125;
&#125;
</code></pre>
<p>写完代码我们可以测试一下：<br>    同步：<br>    const promise = new Promise((resolve, reject) =&gt; {<br>      resolve(‘成功’);<br>    }).then(<br>      (data) =&gt; {<br>        console.log(‘success’, data)<br>      },<br>      (err) =&gt; {<br>        console.log(‘faild’, err)<br>      }<br>    )</p>
<pre><code>&quot;success 成功&quot;

异步：
const promise = new Promise((resolve, reject) =&gt; &#123;
  // 传入一个异步操作
  setTimeout(() =&gt; &#123;
    resolve(&#39;成功&#39;);
  &#125;,1000);
&#125;).then(
  (data) =&gt; &#123;
    console.log(&#39;success&#39;, data)
  &#125;,
  (err) =&gt; &#123;
    console.log(&#39;faild&#39;, err)
  &#125;
)

promise 没有任何返回。
</code></pre>
<ul>
<li>因为 promise 调用 then 方法时，当前的 promise 并没有成功，一直处于 pending 状态。所以如果当调用 then 方法时，当前状态是 pending，我们需要先将成功和失败的回调分别存放起来，在executor()的异步任务被执行时，触发 resolve 或 reject，依次调用成功或失败的回调。</li>
</ul>
<p>结合这个思路，我们优化一下代码：<br>    const PENDING = ‘PENDING’;<br>    const FULFILLED = ‘FULFILLED’;<br>    const REJECTED = ‘REJECTED’;</p>
<pre><code>class Promise &#123;
  constructor(executor) &#123;
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    // 存放成功的回调
    this.onResolvedCallbacks = [];
    // 存放失败的回调
    this.onRejectedCallbacks= [];

    let resolve = (value) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = FULFILLED;
        this.value = value;
        // 依次将对应的函数执行
        this.onResolvedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125; 

    let reject = (reason) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = REJECTED;
        this.reason = reason;
        // 依次将对应的函数执行
        this.onRejectedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125;

    try &#123;
      executor(resolve,reject)
    &#125; catch (error) &#123;
      reject(error)
    &#125;
  &#125;

  then(onFulfilled, onRejected) &#123;
    if (this.status === FULFILLED) &#123;
      onFulfilled(this.value)
    &#125;

    if (this.status === REJECTED) &#123;
      onRejected(this.reason)
    &#125;

    if (this.status === PENDING) &#123;
      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onResolvedCallbacks.push(() =&gt; &#123;
        onFulfilled(this.value)
      &#125;);

      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onRejectedCallbacks.push(()=&gt; &#123;
        onRejected(this.reason);
      &#125;)
    &#125;
  &#125;
&#125;
</code></pre>
<p>测试一下：</p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123;
    resolve(&#39;成功&#39;);
  &#125;,1000);
&#125;).then(
  (data) =&gt; &#123;
    console.log(&#39;success&#39;, data)
  &#125;,
  (err) =&gt; &#123;
    console.log(&#39;faild&#39;, err)
  &#125;
)

1s后输出：&quot;success 成功&quot;
</code></pre>
<p>这其实是一个发布订阅模式，这种收集依赖 -&gt; 触发通知 -&gt; 取出依赖执行的方式，被广泛运用于发布订阅模式的实现。</p>
<h5 id="then-的链式调用-amp-值穿透特性"><a href="#then-的链式调用-amp-值穿透特性" class="headerlink" title="then 的链式调用&amp;值穿透特性"></a>then 的链式调用&amp;值穿透特性</h5><p>依据<a target="_blank" rel="noopener" href="https://promisesaplus.com/">Promise/A+</a>  规范梳理一下思路</p>
<pre><code>1.then 的参数 onFulfilled 和 onRejected 可以缺省，如果 onFulfilled 或者 onRejected不是函数，将其忽略，且依旧可以在下面的 then 中获取到之前返回的值；「规范 Promise/A+ 2.2.1、2.2.1.1、2.2.1.2」
2.promise 可以 then 多次，每次执行完 promise.then 方法后返回的都是一个“新的promise&quot;；「规范 Promise/A+ 2.2.7」
3.如果 then 的返回值 x 是一个普通值，那么就会把这个结果作为参数，传递给下一个 then 的成功的回调中；
4.如果 then 中抛出了异常，那么就会把这个异常作为参数，传递给下一个 then 的失败的回调中；「规范 Promise/A+ 2.2.7.2」
5.如果 then 的返回值 x 是一个 promise，那么会等这个 promise 执行完，promise 如果成功，就走下一个 then 的成功；如果失败，就走下一个 then 的失败；如果抛出异常，就走下一个 then 的失败；「规范 Promise/A+ 2.2.7.3、2.2.7.4」
6.如果 then 的返回值 x 和 promise 是同一个引用对象，造成循环引用，则抛出异常，把异常传递给下一个 then 的失败的回调中；「规范 Promise/A+ 2.3.1」
7.如果 then 的返回值 x 是一个 promise，且 x 同时调用 resolve 函数和 reject 函数，则第一次调用优先，其他所有调用被忽略；「规范 Promise/A+ 2.3.3.3.3」
</code></pre>
<p>我们将代码补充完整：</p>
<pre><code>const PENDING = &#39;PENDING&#39;;
const FULFILLED = &#39;FULFILLED&#39;;
const REJECTED = &#39;REJECTED&#39;;

const resolvePromise = (promise2, x, resolve, reject) =&gt; &#123;
  // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1
  if (promise2 === x) &#123; 
    return reject(new TypeError(&#39;Chaining cycle detected for promise #&lt;Promise&gt;&#39;))
  &#125;
  // Promise/A+ 2.3.3.3.3 只能调用一次
  let called;
  // 后续的条件要严格判断 保证代码能和别的库一起使用
  if ((typeof x === &#39;object&#39; &amp;&amp; x != null) || typeof x === &#39;function&#39;) &#123; 
    try &#123;
      // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1
      let then = x.then;
      if (typeof then === &#39;function&#39;) &#123; 
        // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3
        then.call(x, y =&gt; &#123; // 根据 promise 的状态决定是成功还是失败
          if (called) return;
          called = true;
          // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1
          resolvePromise(promise2, y, resolve, reject); 
        &#125;, r =&gt; &#123;
          // 只要失败就失败 Promise/A+ 2.3.3.3.2
          if (called) return;
          called = true;
          reject(r);
        &#125;);
      &#125; else &#123;
        // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4
        resolve(x);
      &#125;
    &#125; catch (e) &#123;
      // Promise/A+ 2.3.3.2
      if (called) return;
      called = true;
      reject(e)
    &#125;
  &#125; else &#123;
    // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4  
    resolve(x)
  &#125;
&#125;

class Promise &#123;
  constructor(executor) &#123;
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks= [];

    let resolve = (value) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125; 

    let reject = (reason) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125;

    try &#123;
      executor(resolve,reject)
    &#125; catch (error) &#123;
      reject(error)
    &#125;
  &#125;

  then(onFulfilled, onRejected) &#123;
    //解决 onFufilled，onRejected 没有传值的问题
    //Promise/A+ 2.2.1 / Promise/A+ 2.2.5 / Promise/A+ 2.2.7.3 / Promise/A+ 2.2.7.4
    onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : v =&gt; v;
    //因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获
    onRejected = typeof onRejected === &#39;function&#39; ? onRejected : err =&gt; &#123; throw err &#125;;
    // 每次调用 then 都返回一个新的 promise  Promise/A+ 2.2.7
    let promise2 = new Promise((resolve, reject) =&gt; &#123;
      if (this.status === FULFILLED) &#123;
        //Promise/A+ 2.2.2
        //Promise/A+ 2.2.4 --- setTimeout
        setTimeout(() =&gt; &#123;
          try &#123;
            //Promise/A+ 2.2.7.1
            let x = onFulfilled(this.value);
            // x可能是一个proimise
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            //Promise/A+ 2.2.7.2
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === REJECTED) &#123;
        //Promise/A+ 2.2.3
        setTimeout(() =&gt; &#123;
          try &#123;
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === PENDING) &#123;
        this.onResolvedCallbacks.push(() =&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);

        this.onRejectedCallbacks.push(()=&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject)
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);
      &#125;
    &#125;);
  
    return promise2;
  &#125;
&#125;
</code></pre>
<p>测试一下：</p>
<pre><code>const promise = new Promise((resolve, reject) =&gt; &#123;
  reject(&#39;失败&#39;);
&#125;).then().then().then(data=&gt;&#123;
  console.log(data);
&#125;,err=&gt;&#123;
  console.log(&#39;err&#39;,err);
&#125;)

输出：&quot;失败 err&quot;
</code></pre>
<h4 id="Promise-的-API"><a href="#Promise-的-API" class="headerlink" title="Promise 的 API"></a>Promise 的 API</h4><p>虽然上述的 promise 源码已经符合 Promise/A+ 的规范，但是原生的 Promise 还提供了一些其他方法，如:</p>
<pre><code>Promise.resolve()
Promise.reject()
Promise.prototype.catch()
Promise.prototype.finally()
Promise.all()
Promise.race(）
</code></pre>
<h5 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h5><pre><code>static resolve(data)&#123;
  return new Promise((resolve,reject)=&gt;&#123;
    resolve(data);
  &#125;)
&#125;
</code></pre>
<h5 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h5><p>默认产生一个失败的 promise，Promise.reject 是直接将值变成错误结果。</p>
<pre><code>static reject(reason)&#123;
  return new Promise((resolve,reject)=&gt;&#123;
    reject(reason);
  &#125;)
&#125;
</code></pre>
<h5 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch"></a>Promise.prototype.catch</h5><p>Promise.prototype.catch 用来捕获 promise 的异常，就相当于一个没有成功的 then。</p>
<pre><code>Promise.prototype.catch = function(errCallback)&#123;
  return this.then(null,errCallback)
&#125;
</code></pre>
<h5 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally"></a>Promise.prototype.finally</h5><p>finally 表示不是最终的意思，而是无论如何都会执行的意思。<br>如果返回一个 promise 会等待这个 promise 也执行完毕。如果返回的是成功的 promise，会采用上一次的结果；如果返回的是失败的 promise，会用这个失败的结果，传到 catch 中。</p>
<pre><code>Promise.prototype.finally = function(callback) &#123;
  return this.then((value)=&gt;&#123;
    return Promise.resolve(callback()).then(()=&gt;value)
  &#125;,(reason)=&gt;&#123;
    return Promise.resolve(callback()).then(()=&gt;&#123;throw reason&#125;)
  &#125;)  
&#125;
</code></pre>
<h5 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h5><p>promise.all 是解决并发问题的，多个异步并发获取最终的结果（如果有一个失败则失败）。</p>
<pre><code>Promise.all = function(values) &#123;
  if (!Array.isArray(values)) &#123;
    const type = typeof values;
    return new TypeError(`TypeError: $&#123;type&#125; $&#123;values&#125; is not iterable`)
  &#125;
  
  return new Promise((resolve, reject) =&gt; &#123;
    let resultArr = [];
    let orderIndex = 0;
    const processResultByKey = (value, index) =&gt; &#123;
      resultArr[index] = value;
      if (++orderIndex === values.length) &#123;
          resolve(resultArr)
      &#125;
    &#125;
    for (let i = 0; i &lt; values.length; i++) &#123;
      let value = values[i];
      if (value &amp;&amp; typeof value.then === &#39;function&#39;) &#123;
        value.then((value) =&gt; &#123;
          processResultByKey(value, i);
        &#125;, reject);
      &#125; else &#123;
        processResultByKey(value, i);
      &#125;
    &#125;
  &#125;);
&#125;
</code></pre>
<h5 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h5><p>Promise.race 用来处理多个请求，采用最快的（谁先完成用谁的）。</p>
<pre><code>Promise.race = function(promises) &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    // 一起执行就是for循环
    for (let i = 0; i &lt; promises.length; i++) &#123;
      let val = promises[i];
      if (val &amp;&amp; typeof val.then === &#39;function&#39;) &#123;
        val.then(resolve, reject);
      &#125; else &#123; // 普通值
        resolve(val)
      &#125;
    &#125;
  &#125;);
&#125;
</code></pre>
<blockquote>
<p>特别需要注意的是：因为Promise 是没有中断方法的，xhr.abort()、ajax 有自己的中断方法，axios 是基于 ajax 实现的；fetch 基于 promise，所以他的请求是无法中断的。</p>
</blockquote>
<p>这也是 promise 存在的缺陷，我们可以使用 race 来自己封装中断方法：</p>
<pre><code>function wrap(promise) &#123;
  // 在这里包装一个 promise，可以控制原来的promise是成功还是失败
  let abort;
  let newPromise = new Promise((resolve, reject) =&gt; &#123; // defer 方法
      abort = reject;
  &#125;);
  let p = Promise.race([promise, newPromise]); // 任何一个先成功或者失败 就可以获取到结果
  p.abort = abort;
  return p;
&#125;

const promise = new Promise((resolve, reject) =&gt; &#123;
  setTimeout(() =&gt; &#123; // 模拟的接口调用 ajax 肯定有超时设置
      resolve(&#39;成功&#39;);
  &#125;, 1000);
&#125;);

let newPromise = wrap(promise);

setTimeout(() =&gt; &#123;
  // 超过3秒 就算超时 应该让 proimise 走到失败态
  newPromise.abort(&#39;超时了&#39;);
&#125;, 3000);

newPromise.then((data =&gt; &#123;
    console.log(&#39;成功的结果&#39; + data)
&#125;)).catch(e =&gt; &#123;
    console.log(&#39;失败的结果&#39; + e)
&#125;)

1s后输出：&quot;成功的结果成功&quot;
</code></pre>
<h4 id="1-Promise"><a href="#1-Promise" class="headerlink" title="1 - Promise"></a>1 - Promise</h4><pre><code>const PENDING = &#39;PENDING&#39;;
const FULFILLED = &#39;FULFILLED&#39;;
const REJECTED = &#39;REJECTED&#39;;

const resolvePromise = (promise2, x, resolve, reject) =&gt; &#123;
  if (promise2 === x) &#123; 
    return reject(new TypeError(&#39;Chaining cycle detected for promise #&lt;Promise&gt;&#39;))
  &#125;
  let called;
  if ((typeof x === &#39;object&#39; &amp;&amp; x != null) || typeof x === &#39;function&#39;) &#123; 
    try &#123;
      let then = x.then;
      if (typeof then === &#39;function&#39;) &#123; 
        then.call(x, y =&gt; &#123; 
          if (called) return;
          called = true;
          resolvePromise(promise2, y, resolve, reject); 
        &#125;, r =&gt; &#123;
          if (called) return;
          called = true;
          reject(r);
        &#125;);
      &#125; else &#123;
        resolve(x);
      &#125;
    &#125; catch (e) &#123;
      if (called) return;
      called = true;
      reject(e)
    &#125;
  &#125; else &#123;
    resolve(x)
  &#125;
&#125;

class Promise &#123;
  constructor(executor) &#123;
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks= [];

    let resolve = (value) =&gt; &#123;
      if(value instanceof Promise)&#123;
        return value.then(resolve,reject)
      &#125;

      if(this.status ===  PENDING) &#123;
        this.status = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125; 

    let reject = (reason) =&gt; &#123;
      if(this.status ===  PENDING) &#123;
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn=&gt;fn());
      &#125;
    &#125;

    try &#123;
      executor(resolve,reject)
    &#125; catch (error) &#123;
      reject(error)
    &#125;
  &#125;

  then(onFulfilled, onRejected) &#123;
    onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : v =&gt; v;
    onRejected = typeof onRejected === &#39;function&#39; ? onRejected : err =&gt; &#123; throw err &#125;;
    let promise2 = new Promise((resolve, reject) =&gt; &#123;
      if (this.status === FULFILLED) &#123;
        setTimeout(() =&gt; &#123;
          try &#123;
            let x = onFulfilled(this.value);
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === REJECTED) &#123;
        setTimeout(() =&gt; &#123;
          try &#123;
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          &#125; catch (e) &#123;
            reject(e)
          &#125;
        &#125;, 0);
      &#125;

      if (this.status === PENDING) &#123;
        this.onResolvedCallbacks.push(() =&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);

        this.onRejectedCallbacks.push(()=&gt; &#123;
          setTimeout(() =&gt; &#123;
            try &#123;
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject)
            &#125; catch (e) &#123;
              reject(e)
            &#125;
          &#125;, 0);
        &#125;);
      &#125;
    &#125;);
  
    return promise2;
  &#125;

  catch(errCallback) &#123;
    return this.then(null,errCallback)
  &#125;

  finally(callback) &#123;
    return this.then((value)=&gt;&#123;
      return Promise.resolve(callback()).then(()=&gt;value)
    &#125;,(reason)=&gt;&#123;
      return Promise.resolve(callback()).then(()=&gt;&#123;throw reason&#125;)
    &#125;)  
  &#125;

  static resolve(data)&#123;
    return new Promise((resolve,reject)=&gt;&#123;
      resolve(data);
    &#125;)
  &#125;

  static reject(reason)&#123;
    return new Promise((resolve,reject)=&gt;&#123;
      reject(reason);
    &#125;)
  &#125; 

  static all(values) &#123;
    if (!Array.isArray(values)) &#123;
      const type = typeof values;
      return new TypeError(`TypeError: $&#123;type&#125; $&#123;values&#125; is not iterable`)
    &#125;

    return new Promise((resolve, reject) =&gt; &#123;
      let resultArr = [];
      let orderIndex = 0;
      const processResultByKey = (value, index) =&gt; &#123;
        resultArr[index] = value;
        if (++orderIndex === values.length) &#123;
            resolve(resultArr)
        &#125;
      &#125;
      for (let i = 0; i &lt; values.length; i++) &#123;
        let value = values[i];
        if (value &amp;&amp; typeof value.then === &#39;function&#39;) &#123;
          value.then((value) =&gt; &#123;
            processResultByKey(value, i);
          &#125;, reject);
        &#125; else &#123;
          processResultByKey(value, i);
        &#125;
      &#125;
    &#125;);
  &#125;

  static race(promises) &#123;
    return new Promise((resolve, reject) =&gt; &#123;
      for (let i = 0; i &lt; promises.length; i++) &#123;
        let val = promises[i];
        if (val &amp;&amp; typeof val.then === &#39;function&#39;) &#123;
          val.then(resolve, reject);
        &#125; else &#123;
          resolve(val)
        &#125;
      &#125;
    &#125;);
  &#125;
&#125;



Promise.defer = Promise.deferred = function () &#123;
  let dtd = &#123;&#125;
  dtd.promise = new Promise((resolve, reject) =&gt; &#123;
    dtd.resolve = resolve;
    dtd.reject = reject;
  &#125;)
  return dtd;
&#125;

module.exports = Promise
</code></pre>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Baishu</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://example.com/2020/05/08/js/promise/" title="手写Promise">http://example.com/2020/05/08/js/promise/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/05/13/js/commonjs/" rel="prev" title="CommonJS AMD CMD UMD esm 对比"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">CommonJS AMD CMD UMD esm 对比</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/05/01/node/what/" rel="next" title="Nodejs 学习路线"><span class="post-nav-text">Nodejs 学习路线</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2022 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Baishu</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.4.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.10.2</span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a><a class="popup-trigger hty-icon-button icon-search" id="search" href="javascript:;" title="搜索"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-search-line"></use></svg></span></a><script>window.addEventListener("DOMContentLoaded", () => {
  // Handle and trigger popup window
  document.querySelector(".popup-trigger").addEventListener("click", () => {
    document.querySelector(".popup").classList.add("show");
    setTimeout(() => {
      document.querySelector(".search-input").focus();
    }, 100);
  });

  // Monitor main search box
  const onPopupClose = () => {
    document.querySelector(".popup").classList.remove("show");
  };

  document.querySelector(".popup-btn-close").addEventListener("click", () => {
    onPopupClose();
  });

  window.addEventListener("keyup", event => {
    if (event.key === "Escape") {
      onPopupClose();
    }
  });
});
</script><script src="/js/search/local-search.js" defer></script><div class="popup search-popup"><div class="search-header"><span class="popup-btn-close close-icon hty-icon-button"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-close-line"></use></svg></span></div><div class="search-input-container"><input class="search-input" id="local-search-input" type="text" placeholder="搜索..." value=""></div><div id="local-search-result"></div></div></div></body></html>